<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C++ 部分特性梳理</title>
      <link href="/2023/01/30/note/"/>
      <url>/2023/01/30/note/</url>
      
        <content type="html"><![CDATA[<p>&emsp;咕咕咕，大概寒假结束前写完。欢迎催更。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL_vector简析</title>
      <link href="/2023/01/23/vector/"/>
      <url>/2023/01/23/vector/</url>
      
        <content type="html"><![CDATA[<p>&emsp;本文将更加细致的分析 std::vector 的具体原理以及实现。关于vector 的基础功能，请点击<a href="https://darksharpness.github.io/2022/10/23/%E6%B5%85%E8%B0%88C++STL/STL/#std-vector">这里</a>。需要注意的是，vector &lt;bool&gt; 是一个特化的模板，其实现不同于其他的vector类，本文将不会讨论这一个特殊的实现，感兴趣可自行查询相关信息: <a href="https://en.cppreference.com/w/cpp/container/vector_bool">cppreference</a></p><p>&emsp;本文重点分析 vector 的底层实现以及其运用到的 C++ 11 以后的特性等等，会讲到一部分但不是全部vector的功能，对于 OIer 可能帮助不大，这里先提醒一下。</p><h2 id="std-vector-的功能"><a href="#std-vector-的功能" class="headerlink" title="std::vector 的功能"></a>std::vector 的功能</h2><h3 id="模板和声明"><a href="#模板和声明" class="headerlink" title="模板和声明"></a>模板和声明</h3><p>&emsp;首先，我们可以在 <code>#include&lt;vector&gt;</code> 之后，通过 <code>std::vector &lt;T&gt; vec</code> 来声明一个存储了 T 类型变量的动态数组，初始为空。其中，用户还可以提供一个 allocator type 作为模板的第二个参数，但是一般情况下不会用到，本文也不会分析这一个参数。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>&emsp;vector 不仅可以初始化为空，也可以用同类型的vector初始化。除此之外，vector还支持初始化列表(要求C++11)，也可以在构造的时候直接设置初始数组的大小以及元素的值。如下所示:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line">vector &lt;<span class="type">int</span>&gt; vec0;     <span class="comment">// 空vector</span></span><br><span class="line">vector &lt;<span class="type">int</span>&gt; <span class="built_in">vec1</span>(<span class="number">10</span>); <span class="comment">// 初始数组长度为10的vector，这10个元素将分别调用默认无参数构造函数(对于int就是初始化为0)</span></span><br><span class="line">vector &lt;<span class="type">int</span>&gt; <span class="built_in">vec2</span>(<span class="number">10</span>,<span class="number">-1</span>); <span class="comment">// 初始化长度为10的vector，这10个元素初始化的值为-1</span></span><br><span class="line">vector &lt;<span class="type">int</span>&gt; vec3 = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;; <span class="comment">// 初始化为一个元素为1,3,4,5的数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// vector &lt;double&gt; vec4 = vec0; 不可以! 类型不同</span></span><br><span class="line">vector &lt;<span class="type">int</span>&gt; vec4 = vec0; <span class="comment">// 同类型vector 也可用于初始化</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="常用功能"><a href="#常用功能" class="headerlink" title="常用功能"></a>常用功能</h3><p>&emsp;vector 的功能有很多。最基础的就是通过成员函数push_back() 或 emplace_back() 往 vector 尾部添加一个元素，push_back() 仅支持一个元素作为参数，而emplace_back() 可以传入多个参数，把这些参数作为新添加的元素的构造函数的参数。需要注意的是，我们应当区分 emplace_back() 和 push_back()的本质，两者虽然都是往尾部添加一个元素，但是底层机制不太一样，笔者将会在后文着重讨论。当然，有push_back()也自然会有pop_back()函数。</p><p>&emsp;类似原生数组，vector 也可以通过下标访问元素，进行读/写操作。而对于下标越界的情况，直接通过下标访问并不会进行任何检查，带来一些未定义行为。如果你的确需要含有越界检查的访问，请使用at()成员函数，其对于下标越界的情况会抛出错误。vector也可以用back()和front()成员函数访问最后一个/第一个元素，并且是一个读/写访问。当然，你也可以通过data()直接的得到vector的第一个元素的地址。由于vector内部数据是连续储存，这相当于就是指向vector内部数组的指针，但是该指针在vector进行改变容量的操作后会失效。</p><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>&emsp;vector也支持迭代器，既有成员函数版本的begin(),end(),cbegin(),cend()，也有非成员函数版的。也有反向迭代器 (即在正向迭代器前面加一个r,例如rbegin(),crend())。同时，其内存连续存储，所以其也是随机访问迭代器。</p><h3 id="容积相关"><a href="#容积相关" class="headerlink" title="容积相关"></a>容积相关</h3><p>&emsp;vector还有许多关于容量的成员函数。首先是empty()用于判断vector()是否为空，size()返回 vector 内部元素的个数。除了以上两个常用的函数，其实还有一个capacity()，其返回的是，vector 已经申请的空间中可以存放元素的个数。这点可能比较绕，笔者将举例子阐释。例如 <code>class T</code> 在内存中占有字节数 $32$ Byte，vector 内部假设已经有了 $3$ 个 T 类型的元素，但是已经了申请 $128=32 \cdot 4$ Byte 的空间，那么其size()毫无疑问就是3，而capacity() 就是4。显然的，一个 vector 内部申请的可以存放元素的个数不少于其已经存放元素的个数。当然，用户不用担心这点，vector 内部会自动动态扩容的。</p><h3 id="元素相关"><a href="#元素相关" class="headerlink" title="元素相关"></a>元素相关</h3><p>&emsp;vector 还有很多的管理内部元素的成员函数。clear()可以清空所有的元素 ；insert() , emplace() 可以在指定位置(用迭代器表示) 插入一个元素 ；erase() 则类似的可以在指定位置删除元素  ；assign()可以重新初始化 vector 内部的元素，统一赋值 ； resize() 可以改变 vector 的 size() ；reserve() 可以为 vector 预留一定的空间 ；；shrink_to_fit() 可以把capacity()降低到和size()一样 ；swap() 可以交换两个同类型 vector 内部的元素，并且只要常数的时间复杂度。附代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">vector &lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="comment">/* vec : &#123;1,2,3&#125; */</span></span><br><span class="line"></span><br><span class="line">vec.<span class="built_in">clear</span>(); <span class="comment">// 清空vector</span></span><br><span class="line"><span class="comment">/* vec : &#123;&#125; */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> iter = vec.<span class="built_in">end</span>(); <span class="comment">// 指向尾部的 iterator</span></span><br><span class="line">vec.<span class="built_in">insert</span>(iter,<span class="number">1</span>); <span class="comment">// 在iter 前面插入一个元素</span></span><br><span class="line"><span class="comment">/* vec : &#123;1&#125; , size : 1 , capacity : 1 */</span></span><br><span class="line"></span><br><span class="line">iter = vec.<span class="built_in">begin</span>();   <span class="comment">// 注意，vector 元素个数改变后可能会导致迭代器失效! 请及时更新迭代器。</span></span><br><span class="line">vec.<span class="built_in">emplace</span>(iter,<span class="number">3</span>); <span class="comment">// 在iter 前面，用一系列参数作为构造函数构造一个新的元素，类似 emplace_back() </span></span><br><span class="line"><span class="comment">// (insert 和 emplace 具体差别请参考 push_back与emplace_back)</span></span><br><span class="line"><span class="comment">/* vec : &#123;3,1&#125; , size : 2 , capacity : 2 */</span></span><br><span class="line"></span><br><span class="line">vec.<span class="built_in">erase</span>(vec.<span class="built_in">end</span>()); <span class="comment">// 删除迭代器指向的的元素</span></span><br><span class="line"><span class="comment">/* vec : &#123;3&#125; , size : 1 , capacity : 2 */</span></span><br><span class="line"></span><br><span class="line">vec.<span class="built_in">resize</span>(<span class="number">3</span>); <span class="comment">// 将vec size()设置为3，如果新的size()大于原来的的size() , 新的元素将会采取默认构造函数</span></span><br><span class="line"><span class="comment">/* vec : &#123;3,0,0&#125; , size : 3 , capacity : 3 */</span></span><br><span class="line"></span><br><span class="line">vec.<span class="built_in">resize</span>(<span class="number">4</span>,<span class="number">1</span>) <span class="comment">// 类似，但是新的元素用传入的第二个参数拷贝构造</span></span><br><span class="line"><span class="comment">/* vec : &#123;3,0,0,1&#125; , size : 4 , capacity : 4 */</span></span><br><span class="line"></span><br><span class="line">vec.<span class="built_in">resize</span>(<span class="number">2</span>);</span><br><span class="line"><span class="comment">/* vec : &#123;3,0&#125; , size : 2 , capacity : 4 */</span></span><br><span class="line"></span><br><span class="line">vec.<span class="built_in">shrink_to_fit</span>(); <span class="comment">// 把多余的 capacity 扔掉</span></span><br><span class="line"><span class="comment">/* vec : &#123;3,0&#125; , size : 2 , capacity : 2 */</span></span><br><span class="line"></span><br><span class="line">vec.<span class="built_in">reserve</span>(<span class="number">3</span>); <span class="comment">// 预留一定空间，若小于当前capacity()则什么都不做</span></span><br><span class="line"><span class="comment">/* vec : &#123;3,0&#125; , size : 2 , capacity : 3 */</span></span><br><span class="line"></span><br><span class="line">vec.<span class="built_in">assign</span>(<span class="number">4</span>,<span class="number">1</span>); <span class="comment">// 强行把vector的size()变为4，并且每个元素值等于第二个参数(如果没有就调用默认构造函数)</span></span><br><span class="line"><span class="comment">/* vec : &#123;1,1,1,1&#125; , size : 4 , capacity : 4 */</span></span><br><span class="line"></span><br><span class="line">vector &lt;<span class="type">int</span>&gt; tmp = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>&#125;;</span><br><span class="line">tmp.<span class="built_in">swap</span>(vec); <span class="comment">// 常数时间交换两个 vector 元素</span></span><br><span class="line"><span class="comment">/* vec : &#123;2,3,3&#125; , size : 3 , capacity : 3 */</span></span><br><span class="line"><span class="comment">/* tmp : &#123;1,1,1,1&#125; , size : 4 , capacity : 4 */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>&emsp;最后，vector 还有一些常见的运算符操作，例如 = 赋值以及 == , &lt; , &gt; 等基本逻辑运算符。</p><h2 id="std-vector-的底层原理"><a href="#std-vector-的底层原理" class="headerlink" title="std::vector 的底层原理"></a>std::vector 的底层原理</h2><p>&emsp;vector 是一个动态的数组，拥有自动扩容的能力(push_back操作)，而且具有均摊 $O(1)$ 的添加元素时间复杂度，常常用于各类程序中。</p><p>&emsp;从底层的角度来看，vector本质上是储存了三个指针，分别指向内存区域的头部、内存区域尾部 以及 元素存储的尾部。当然，也可以存储头部指针、size()、capacity() 代替。$</p><p>&emsp;之所以 vector 能够支持 $O(1)$ 的添加元素时间复杂度 ，是因为其采用了 “倍增” 的扩容方式。当 size() == capacity() 的时候 ，再push_back()必须要扩容，因为申请的内存空间不足了。而此时，如果只申请 size() + 1 个元素的空间，那么，下次push_back()又要申请一次。这么实现，push_back() $n$ 次就达到了 $O(n^2)$ 的时间复杂度了。而基于 “倍增” 的思想，我们每次push_back需要扩容的时候，扩大capacity()为size()的两倍(例外: 当size() == $0$ 的时候，capacity()就变为 $1$ )。这样子，假设push_back() $n$次，$ 2^{m-1} \le n \lt 2^m$，那么最多扩容 $m + 1$ 次，扩容的总时间复杂度为:</p><script type="math/tex; mode=display">O(\sum_{i=0}^{m}{2^i}) = O(2^{m+1}) = O(n)</script><p>&emsp;这样一来，$n$ 次扩容就只要均摊 $O(n)$ 的时间复杂度，而且最多只会用两倍的空间，这在时空复杂度上都是十分高效的。以上便是 std::vector 最根本的原理。</p><h2 id="std-vector-的实现细节"><a href="#std-vector-的实现细节" class="headerlink" title="std::vector 的实现细节"></a>std::vector 的实现细节</h2><h3 id="构造函数赋值和swap"><a href="#构造函数赋值和swap" class="headerlink" title="构造函数赋值和swap()"></a>构造函数赋值和swap()</h3><p>&emsp;由于是指针管理内部数据，因此交换两个容器就只需要交换3个指针即可，所以是常数时间复杂度。同时，在 C++ 11 以后，移动构造函数、移动赋值函数也只需要移动三个指针即可，因此也是常数时间复杂度，其十分高效。而拷贝构造、拷贝赋值等操作则是一个一个的拷贝元素，时间复杂度为线性。</p><h3 id="size-和-capacity"><a href="#size-和-capacity" class="headerlink" title="size() 和 capacity()"></a>size() 和 capacity()</h3><p>&emsp;前面有讲过，size() 返回的是内部存放的元素的个数，而capacity() 则是已经预留空间的元素数，也已经举例讲过。更详细的说，我们可以把 vector 内部看作维护了三个指针 head,tail,end。其中 head 指向申请的内存块的首地址，end 指向了申请的内存块的尾地址(0-base，所以其实是在最后一个可用元素后面一个的位置)，tail 则是指向当前存放最后一个元素后面一个的位置。此时，size() 就等于 tail - head，而 capacity() 就等于 end - head，满足 head $\lt$ tail $\le$ end 。需要注意的是，[head,tail) 之间的元素都是执行过一次构造函数的，但是 [tail,end) 之间的元素的都是未初始化的，没有执行过构造函数。对于一些复杂类，这样的初始构造函数是十分重要的。</p><h3 id="push-back-和-emplace-back"><a href="#push-back-和-emplace-back" class="headerlink" title="push_back() 和 emplace_back()"></a>push_back() 和 emplace_back()</h3><p>&emsp;前面提到的 push_back() 和 emplace_back()，不同便是在于 emplace_back() 极大地利用了 C++ 11 的特性。push_back() 只能接受一个 T 类型参数，可以是左值或者右值。对于左值，新的元素将通过拷贝构造初始化；对于右值，将会执行移动构造函数来初始化新的元素。而emplace_back()可以接受多个参数，其可以通过完美转发，直接用这些参数作为新元素的构造函数，来构造尾部的新元素。</p><p>&emsp;两者在用 T 类型、单个参数初始化的时候表现几乎一致，但是在非 T 类型或者多个参数初始化的时候，emplace_back() 效率显著高于 push_back()。具体来说，如果往尾部添加一个左值 T 对象，那么两者完全一致，都是执行一次拷贝构造。同理，传入一个右值 T 类型的对象，那么两者也同样，都是执行一次移动构造。但是，当传入一系列参数作为新元素的构造参数时，push_back()需要显式的调用 T() 在外部构造，然后vector 内部还会移动构造一次。而emplace_back()则直接在内部构造，只有一次构造，可以省去一次移动构造。</p><p>下面将举例分析。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">temp</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> x;</span><br><span class="line">    <span class="type">double</span> y;</span><br><span class="line">    <span class="type">char</span> ch[<span class="number">1024</span>];</span><br><span class="line">    <span class="built_in">temp</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">temp</span>(<span class="type">const</span> temp &amp;) = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">temp</span>(temp &amp;&amp;)      = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">temp</span>(<span class="type">const</span> <span class="type">char</span> *str,<span class="type">double</span> __y) &#123;</span><br><span class="line">        x = <span class="built_in">strlen</span>(str);</span><br><span class="line">        <span class="built_in">strcpy</span>(ch,str);</span><br><span class="line">        y = __y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">vector &lt;temp&gt; vec;</span><br><span class="line"></span><br><span class="line">vec.<span class="built_in">push_back</span>(<span class="built_in">temp</span>(<span class="string">&quot;DarkSharpness&quot;</span>,<span class="number">1.99</span>));</span><br><span class="line">vec.<span class="built_in">emplace_back</span>(<span class="string">&quot;DarkSharpness&quot;</span>,<span class="number">1.99</span>);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>&emsp;在以上这段代码中，push_back 非 T (本例中为 temp) 类的参数需要先构造出一个 T 类对象 ，而内部则用这个临时对象来移动构造出一个元素。而emplace_back 则直接在内部用这些参数执行构造函数。而如果 T 类对象的移动构造并不是非常高效，甚至可能等同拷贝构造(例如用固定长度的字符数组表示的字符串，正如本例子中的temp，那么此时，emplace_back便可以省去不必要的移动构造过程，大大提升效率。</p><p>&emsp;值得注意的是，emplace_back和push_back有强异常保证。这意味着当扩容过程中发生了异常，那么原来的 vector 不会有任何的改变。这看起来没什么，但是这可能会极大的影响到程序的效率。因为在扩容时，需要将老的数据移到新的内存。一般来说，老数据都是没用的，应该调用的是移动构造而不是拷贝构造。但是，如果移动构造函数没有 noexcept 标识符，那么如果在移动某个元素 x 到 y 的过程中发生了异常，x的部分元素已经被移动到了 y ，我们不知道当前移动了多少，不知道如何把这部分数据移回 x ，也不确定移动回去会不会再发生异常。因此，原来 x 元素损坏了，数据丢失。为了满足强异常保证，此时只能使用拷贝构造。注意到了这点，我们对于明显不会抛出异常的移动构造函数应该加上 noexcept，否则可能影响程序效率，特别是对于拷贝开销大而移动开销小的类。详见<a href="https://en.cppreference.com/w/cpp/container/vector/emplace_back">cppreference</a>。</p><p>&emsp;在 C++ 11 之后，笔者认为应当用 emplace_back()替代push_back()以追求更高的效率。如果要减少模板的实例化(emplace_back是模板)并且对象易于移动(例如 std::string)，或者<br>追求旧版本的兼容性，那么再用push_back()。</p><h3 id="emplace-和-insert"><a href="#emplace-和-insert" class="headerlink" title="emplace() 和 insert()"></a>emplace() 和 insert()</h3><p>&emsp;两者都是在指定的 iterator 前面插入一个元素，具体区别类似 emplace_back() 与 push_back()。当元素在尾部的时候，其同样有一定的强异常保证，即在 vector 尾部插入元素的异常表现完全等同 emplace_back() 与 push_back()。复杂度也是线性的，而且有多种变种，具体请参考cppreference: <a href="https://en.cppreference.com/w/cpp/container/vector/insert">insert</a>，<a href="https://en.cppreference.com/w/cpp/container/vector/emplace">emplace</a>。</p><h3 id="reserve-和-resize"><a href="#reserve-和-resize" class="headerlink" title="reserve() 和 resize()"></a>reserve() 和 resize()</h3><p>&emsp;这两个函数比较特殊，其均有改变 vector 的的大小的作用，只不过 reserve() 会预留空间，但是resize() 在预留空间(如果是扩容)的同时，还会对超过原来size()部分新建的元素执行构造函数。</p><p>&emsp;很多时候，当用户能明确得知 vector 大小的时候，的确需要 resize() 或 reserve()。然而，并不是所有时候都需要用resize() 或 reserve() 。因为两者会精确改变 vector 的 capacity() ，这很可能使得 vector 高效 push_back() 的特性失效。举例:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vector &lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">vec.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">vec.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line"><span class="comment">/* 只需要扩容一次，capacity = 6 */</span></span><br><span class="line"></span><br><span class="line">vector &lt;<span class="type">int</span>&gt; tmp = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">tmp.<span class="built_in">resize</span>(tmp.<span class="built_in">size</span>() + <span class="number">1</span>);</span><br><span class="line">tmp.<span class="built_in">resize</span>(tmp.<span class="built_in">size</span>() + <span class="number">1</span>);</span><br><span class="line"><span class="comment">/* 需要扩容两次，capacity = 5 */</span></span><br></pre></td></tr></table></figure><p>&emsp;就笔者个人经验而言，一般情况下会在 vector 一开始的时候 reserve() 到最大可能的size() 然后 push_back() 不超过这个size() ； 或者 resize() 到指定大小，然后对小于size()的下标的元素，进行读/写操作，类似对一个定长 array 操作。总之，一般要避免连续的 reserve() 和 resize()。</p><h3 id="shrink-to-fit"><a href="#shrink-to-fit" class="headerlink" title="shrink_to_fit()"></a>shrink_to_fit()</h3><p>&emsp;这是一个比较玄学的函数，用来使 capacity() 缩小到 size()，减小空间占用。除非你明确释放内存(比如之后的vector的 size() 不会再增长只会减小，并且想要节约空间)，否则请不要使用这个函数，其会使得 vector 的优化(即多预留空间)带来的高效率 push_back() 失效。</p><h3 id="clear"><a href="#clear" class="headerlink" title="clear()"></a>clear()</h3><p>&emsp;这个函数用来清空 vector 内部的元素，它会使得 size() 减小到0，但是 capacity() 不变，这是为了保证高效的 push_back() 操作。参考之前的实现，有一小部分用户 (比如曾经的我) 可能错以为 clear() 就是移动一个指针事情(tail = head) ，以为是常数复杂度。这样的观点是错误的。事实上，vector的clear()操作其实是线性复杂度，正比于内部元素个数。这是因为内部的元素可能是非平凡类，这种时候内部元素在销毁的时候必须执行析构函数(例如 std::map，析构函数需要释放内部的内存，不然会内存泄漏)。当然，这时候又有小可爱(比如我)想要问: 那么对于简单类，比如 int,double，其不需要析构函数来释放空间，那不是会降低效率吗。然而，cpp的编译器(至少gcc)要求了，对于空的析构(比如 ~int())，其会被优化掉，甚至连循环都会被优化掉。其会被优化为空，所以不用考虑这些细节对于效率的影响。</p><p><img src="https://s2.loli.net/2023/01/28/Z9kN6oHOedLfMBz.png" alt="写在gcc标准库注释里面的"></p><p><img src="https://s2.loli.net/2023/01/28/E2M41zGa3fyjQHL.png" alt="析构单个pointer"></p><h2 id="参考-vector-实现"><a href="#参考-vector-实现" class="headerlink" title="参考 vector 实现"></a>参考 vector 实现</h2><p>&emsp;笔者在寒假也写了一个类似 std::vector 的实现，其大致如下，具体可见 <a href="https://github.com/DarkSharpness/DarkSharpness/blob/main/Template/Dark/Container/dynamic_array.h">github仓库</a>。注意，没有任何可信的保证，程序可能存在很多 bug! 而且没有任何异常处理，push_back() emplace_back() 没有任何异常保证。总之，仅供学习、参考，没有任何保证! 以下是 2023/01/25 16:42 UTC+8 的参考版本，附加了一点点注释。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _DARK_DYNAMIC_ARRAY_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _DARK_DYNAMIC_ARRAY_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../include/basic.h&quot;</span> <span class="comment">// 只用到了一个 Log2 函数，可以忽略</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../iterator&quot;</span>        <span class="comment">// 一个iterator 库</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span>             <span class="comment">// std::allocator</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;initializer_list&gt;</span>   <span class="comment">// 初始化列表</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> dark &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// dark::dynamic_array 就是 std::vector</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief A dynamic %array that can expand itself automatically.</span></span><br><span class="line"><span class="comment"> * In other words, user don&#x27;t need to consider the allocation and </span></span><br><span class="line"><span class="comment"> * deallocation of space.</span></span><br><span class="line"><span class="comment"> * Note that if the elements within are pointers, the data pointed </span></span><br><span class="line"><span class="comment"> * to won&#x27;t be touched. It&#x27;s user&#x27;s responsibility to manage them.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @tparam value_t The type of elements stored within the %array.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">value_t</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">dynamic_array</span> : <span class="keyword">private</span> std::allocator &lt;<span class="type">value_t</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">value_t</span> *head; <span class="comment">/* Head pointer to first element. */</span></span><br><span class="line">    <span class="type">value_t</span> *tail; <span class="comment">/* Tail pointer to one past the last element. */</span></span><br><span class="line">    <span class="type">value_t</span> *term; <span class="comment">/* Terminal pointer to the end of storage. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Allocate memory of __n elements. */</span></span><br><span class="line">    <span class="function"><span class="type">value_t</span> *<span class="title">alloc</span><span class="params">(<span class="type">size_t</span> __n)</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;<span class="built_in">allocate</span>(__n); &#125;</span><br><span class="line">    <span class="comment">/* Deallocate of the memory of head. */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dealloc</span><span class="params">()</span> </span>&#123; <span class="keyword">this</span>-&gt;<span class="built_in">deallocate</span>(head,<span class="built_in">capacity</span>()); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Destory __n elements */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">destroy_n</span><span class="params">(<span class="type">value_t</span> *pointer,<span class="type">size_t</span> __n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(__n--) &#123; <span class="keyword">this</span>-&gt;<span class="built_in">destroy</span>(pointer++); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* End of unfolding. */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reserved_push_back</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Push back a sequence of elements with space reserved in advance. */</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">U</span>,<span class="keyword">class</span> ...Args&gt;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reserved_push_back</span><span class="params">(U &amp;&amp;obj,Args &amp;&amp;...objs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">construct</span>(tail++,std::forward &lt;U&gt; (obj));</span><br><span class="line">        <span class="built_in">reserved_push_back</span>(std::forward &lt;Args&gt; (objs)...);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Construct a new empty %array. */</span></span><br><span class="line">    <span class="built_in">dynamic_array</span>() : <span class="built_in">head</span>(<span class="literal">nullptr</span>),<span class="built_in">tail</span>(<span class="literal">nullptr</span>),<span class="built_in">term</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="comment">/* Destroy all the elements and deallocate the space. */</span></span><br><span class="line">    ~<span class="built_in">dynamic_array</span>() <span class="keyword">noexcept</span> &#123; <span class="keyword">this</span>-&gt;<span class="built_in">destroy_n</span>(head,<span class="built_in">size</span>()); <span class="built_in">dealloc</span>(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Construct a new %array from an initializer_list. */</span></span><br><span class="line">    <span class="built_in">dynamic_array</span>(std::initializer_list &lt;<span class="type">value_t</span>&gt; __l) </span><br><span class="line">        : <span class="built_in">dynamic_array</span>(__l.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;iter : __l) &#123; <span class="keyword">this</span>-&gt;<span class="built_in">construct</span>(tail++,std::<span class="built_in">move</span>(iter)); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Construct a new %array with __n elements&#x27; space reserved. */</span></span><br><span class="line">    <span class="built_in">dynamic_array</span>(<span class="type">size_t</span> __n) &#123;</span><br><span class="line">        term = (head = tail = <span class="built_in">alloc</span>(__n)) + __n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief Construct a new %array filled with given length and element.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @param __n The initial length of the %array.</span></span><br><span class="line"><span class="comment">     * @param obj The element to fill the %array.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">dynamic_array</span>(<span class="type">size_t</span> __n,<span class="type">const</span> <span class="type">value_t</span> &amp;obj) </span><br><span class="line">        : <span class="built_in">dynamic_array</span>(__n) &#123;</span><br><span class="line">        <span class="keyword">while</span>(tail != term) &#123; <span class="keyword">this</span>-&gt;<span class="built_in">construct</span>(tail++,obj); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief Construct a new %array with identical elements with another %array.</span></span><br><span class="line"><span class="comment">     * Note that no vacancy of %array remains, </span></span><br><span class="line"><span class="comment">     * which means the new %array&#x27;s size() equals its capacity(). </span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @param rhs The %array to copy from.</span></span><br><span class="line"><span class="comment">     * @attention Linear time complexity with respect to the size() of rhs,</span></span><br><span class="line"><span class="comment">     * multiplied by the construction time of one element.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">dynamic_array</span>(<span class="type">const</span> dynamic_array &amp;rhs) </span><br><span class="line">        : <span class="built_in">dynamic_array</span>(rhs.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span> &amp;iter : rhs) &#123; <span class="keyword">this</span>-&gt;<span class="built_in">construct</span>(tail++,iter);&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief Construct a new %array with identical elements with another %array.</span></span><br><span class="line"><span class="comment">     * It will just take away the pointers from another %array.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @param rhs The %array to move from.</span></span><br><span class="line"><span class="comment">     * @attention Constant time complexity in any case.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">dynamic_array</span>(dynamic_array &amp;&amp;rhs) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        head = rhs.head;</span><br><span class="line">        tail = rhs.tail;</span><br><span class="line">        term = rhs.term;</span><br><span class="line">        rhs.head = rhs.tail = rhs.term = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief Copy assign a new %array with identical elements with another %array.</span></span><br><span class="line"><span class="comment">     * Note that no vacancy of %array remains, </span></span><br><span class="line"><span class="comment">     * which means the new %array&#x27;s size() equals its capacity(). </span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @param rhs The %array to copy from.</span></span><br><span class="line"><span class="comment">     * @attention Linear time complexity with respect to the size() of rhs,</span></span><br><span class="line"><span class="comment">     * multiplied by the construction time of one element,</span></span><br><span class="line"><span class="comment">     * Note that there might be an additional time cost linear to the </span></span><br><span class="line"><span class="comment">     * elements destroyed.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    dynamic_array &amp;<span class="keyword">operator</span> = (<span class="type">const</span> dynamic_array &amp;rhs) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span> != &amp;rhs) &#123; <span class="built_in">copy_range</span>(rhs.<span class="built_in">begin</span>(),rhs.<span class="built_in">size</span>()); &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief Construct a new %array with identical elements with another %array.</span></span><br><span class="line"><span class="comment">     * It will just move the pointers from another %array.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @param rhs The %array to move from.</span></span><br><span class="line"><span class="comment">     * @attention Constant time complexity in any case.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    dynamic_array &amp;<span class="keyword">operator</span> = (dynamic_array &amp;&amp;rhs) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span> != &amp;rhs) &#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;~<span class="built_in">dynamic_array</span>();</span><br><span class="line">            head = rhs.head;</span><br><span class="line">            tail = rhs.tail;</span><br><span class="line">            term = rhs.term;</span><br><span class="line">            rhs.head = rhs.tail = rhs.term = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Swap the content of two %array in constant time. */</span></span><br><span class="line">    <span class="function">dynamic_array &amp;<span class="title">swap</span><span class="params">(dynamic_array &amp;rhs)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        std::<span class="built_in">swap</span>(head,rhs.head);</span><br><span class="line">        std::<span class="built_in">swap</span>(tail,rhs.tail);</span><br><span class="line">        std::<span class="built_in">swap</span>(term,rhs.term);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Swap the content of two %array in constant time. */</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">swap</span><span class="params">(dynamic_array &amp;lhs,dynamic_array &amp;rhs)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        std::<span class="built_in">swap</span>(lhs.head,rhs.head);</span><br><span class="line">        std::<span class="built_in">swap</span>(lhs.tail,rhs.tail);</span><br><span class="line">        std::<span class="built_in">swap</span>(lhs.term,rhs.term);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/* Count of elements within the %array. */</span></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> tail - head; &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief Count of elements the %array can hold </span></span><br><span class="line"><span class="comment">     * before the next allocation.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">capacity</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> term - head; &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief Count of vacancy in the back of the %array  </span></span><br><span class="line"><span class="comment">     * before the next allocation.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">vacancy</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> term - tail; &#125;</span><br><span class="line">    <span class="comment">/* Test whether the %array is empty */</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span>  <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> head == tail; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Doing nothing to the %array. */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief Push one element to the back of the %array.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @param obj The object pushed back to initialize the element. </span></span><br><span class="line"><span class="comment">     * @attention Amortized constant time complexity,</span></span><br><span class="line"><span class="comment">     * multiplied by the construction time of one element.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">U</span>&gt;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(U &amp;&amp;obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tail == term) &#123; <span class="built_in">reserve</span>(<span class="built_in">size</span>() &lt;&lt; <span class="number">1</span> | <span class="built_in">empty</span>()); &#125; </span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">construct</span>(tail++,std::forward &lt;U&gt; (obj));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief Push a sequnce of elements to the back of the %array.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @param objs The objects pushed back to initialize the element.</span></span><br><span class="line"><span class="comment">     * @attention Amortized linear time complexity with respect to count of objs,</span></span><br><span class="line"><span class="comment">     * multiplied by the construction time of one element.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> ...Args&gt;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(Args &amp;&amp;...objs)</span> </span>&#123;</span><br><span class="line">        <span class="type">size_t</span> count = <span class="keyword">sizeof</span>...(objs); <span class="comment">// count &gt;= 2 </span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">vacancy</span>() &lt; count) &#123;</span><br><span class="line">            <span class="type">size_t</span> space = <span class="built_in">capacity</span>() + <span class="built_in">empty</span>();</span><br><span class="line">            <span class="built_in">reserve</span>(space &lt;&lt; (<span class="built_in">LOG2</span>((<span class="built_in">size</span>() + count - <span class="number">1</span>) / space) + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reserved_push_back</span>(std::forward &lt;Args&gt; (objs)...);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief Construct one element after the back of the %array.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @param obj The object pushed back to initialize the element. </span></span><br><span class="line"><span class="comment">     * @attention Amortized constant time complexity,</span></span><br><span class="line"><span class="comment">     * multiplied by the construction time of one element.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> ...Args&gt;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">emplace_back</span><span class="params">(Args &amp;&amp;...objs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tail == term) &#123; <span class="built_in">reserve</span>(<span class="built_in">size</span>() &lt;&lt; <span class="number">1</span> | <span class="built_in">empty</span>()); &#125;</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">construct</span>(tail++,std::forward &lt;Args&gt; (objs)...);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Destroy the last element in the back, with no returning. */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop_back</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">this</span>-&gt;<span class="built_in">destroy</span>(--tail); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief Clear all the elements in the %array.</span></span><br><span class="line"><span class="comment">     * Note that the capacity() of the %array won&#x27;t shrink.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @attention Linear complexity with respect to size(),</span></span><br><span class="line"><span class="comment">     * multiplied by the deconstruction time of one element.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">destroy_n</span>(head,<span class="built_in">size</span>());</span><br><span class="line">        tail = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief Clear the vacancy of the %array.</span></span><br><span class="line"><span class="comment">     * Note that it will disable the optimization of the %array.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @attention Linear complexity with respect to size(),</span></span><br><span class="line"><span class="comment">     * multiplied by the deconstruction time of one element.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">shrink</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tail != term) &#123;</span><br><span class="line">            <span class="type">value_t</span> *temp = <span class="built_in">alloc</span>(<span class="built_in">size</span>());</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span> ; i &lt; <span class="built_in">size</span>() ; ++i) &#123;</span><br><span class="line">                <span class="keyword">this</span>-&gt;<span class="built_in">construct</span>(temp + i,std::<span class="built_in">move</span>(head[i]));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>-&gt;~<span class="built_in">dynamic_array</span>();</span><br><span class="line">            term = tail = temp + <span class="built_in">size</span>();</span><br><span class="line">            head = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief Resize the %array to __n.</span></span><br><span class="line"><span class="comment">     * The original data with index smaller than __n won&#x27;t be touched.  </span></span><br><span class="line"><span class="comment">     * If __n is greater than size(), elements will be appended to the back.</span></span><br><span class="line"><span class="comment">     * These new elements will be assigned by default construction function.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @param __n The new size of the %array.</span></span><br><span class="line"><span class="comment">     * @attention Linear complexity with respect to __n ,</span></span><br><span class="line"><span class="comment">     * multiplied by the construction time of one element.</span></span><br><span class="line"><span class="comment">     * Note that there might be an additional time cost linear to the </span></span><br><span class="line"><span class="comment">     * elements destroyed.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">(<span class="type">size_t</span> __n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(__n &lt;= <span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="type">size_t</span> count = <span class="built_in">size</span>() - __n;</span><br><span class="line">            tail -= count;</span><br><span class="line">            <span class="keyword">this</span>-&gt;<span class="built_in">destroy_n</span>(tail,count);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">reserve</span>(__n);</span><br><span class="line">            <span class="type">size_t</span> count = __n - <span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">while</span>(count--) &#123; <span class="keyword">this</span>-&gt;<span class="built_in">construct</span>(tail++); &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief Resize the %array to __n.</span></span><br><span class="line"><span class="comment">     * The original data with index smaller than __n won&#x27;t be touched.  </span></span><br><span class="line"><span class="comment">     * If __n is greater than size(), elements will be appended to the back.</span></span><br><span class="line"><span class="comment">     * These new elements will be assigned by val.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @param __n The new size of the %array.</span></span><br><span class="line"><span class="comment">     * @param val The object to assign the new value.</span></span><br><span class="line"><span class="comment">     * @attention Linear complexity with respect to __n ,</span></span><br><span class="line"><span class="comment">     * multiplied by the construction time of one element.</span></span><br><span class="line"><span class="comment">     * Note that there might be an additional time cost linear to the </span></span><br><span class="line"><span class="comment">     * elements destroyed.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">(<span class="type">size_t</span> __n,<span class="type">const</span> <span class="type">value_t</span> &amp;val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(__n &lt;= <span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="type">size_t</span> count = <span class="built_in">size</span>() - __n;</span><br><span class="line">            tail -= count;</span><br><span class="line">            <span class="keyword">this</span>-&gt;<span class="built_in">destroy_n</span>(tail,count);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">reserve</span>(__n);</span><br><span class="line">            <span class="type">size_t</span> count = __n - <span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">while</span>(count--) &#123; <span class="keyword">this</span>-&gt;<span class="built_in">construct</span>(tail++,val); &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief Reserve space for __n elements.</span></span><br><span class="line"><span class="comment">     * If __n &lt; capacity(), nothing will be done.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @param __n The space reserved for elements.</span></span><br><span class="line"><span class="comment">     * @attention Linear time complexity with respect to __n,</span></span><br><span class="line"><span class="comment">     * only if __n &gt;= capacity(), multiplied by the time of (de-)construction. </span></span><br><span class="line"><span class="comment">     * Otherwise, constant time complexity.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reserve</span><span class="params">(<span class="type">size_t</span> __n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">capacity</span>() &lt; __n) &#123;</span><br><span class="line">            <span class="type">value_t</span> *temp = <span class="built_in">alloc</span>(__n);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span> ; i &lt; <span class="built_in">size</span>() ; ++i) &#123;</span><br><span class="line">                <span class="keyword">this</span>-&gt;<span class="built_in">construct</span>(temp + i,std::<span class="built_in">move</span>(head[i]));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>-&gt;~<span class="built_in">dynamic_array</span>();</span><br><span class="line">            term = temp + __n;</span><br><span class="line">            tail = temp + <span class="built_in">size</span>();</span><br><span class="line">            head = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief Resize the %array to __n and assign all the elements by </span></span><br><span class="line"><span class="comment">     * default construction function of value_t. </span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @param __n The new size of the %array.</span></span><br><span class="line"><span class="comment">     * @attention Linear complexity with respect to __n ,</span></span><br><span class="line"><span class="comment">     * multiplied by the construction time of one element.</span></span><br><span class="line"><span class="comment">     * Note that there might be an additional time cost linear to the </span></span><br><span class="line"><span class="comment">     * elements destroyed.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">assign</span><span class="params">(<span class="type">size_t</span> __n)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">value_t</span> val = <span class="built_in">value_t</span>();</span><br><span class="line">        <span class="keyword">if</span>(__n &lt;= <span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="type">size_t</span> count = <span class="built_in">size</span>() - __n;</span><br><span class="line">            tail -= count;</span><br><span class="line">            <span class="keyword">this</span>-&gt;<span class="built_in">destroy_n</span>(tail,count);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;iter : *<span class="keyword">this</span>) &#123; iter = val; &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;iter : *<span class="keyword">this</span>) &#123; iter = val; &#125;</span><br><span class="line">            <span class="built_in">reserve</span>(__n);</span><br><span class="line">            <span class="type">size_t</span> count = __n - <span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">while</span>(count--) <span class="keyword">this</span>-&gt;<span class="built_in">construct</span>(tail++);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief Resize the %array to __n and assign all the elements by val. </span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @param __n The new size of the %array.</span></span><br><span class="line"><span class="comment">     * @param val The object to assign the value.</span></span><br><span class="line"><span class="comment">     * @attention Linear complexity with respect to __n ,</span></span><br><span class="line"><span class="comment">     * multiplied by the construction time of one element.</span></span><br><span class="line"><span class="comment">     * Note that there might be an additional time cost linear to the </span></span><br><span class="line"><span class="comment">     * elements destroyed.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">assign</span><span class="params">(<span class="type">size_t</span> __n,<span class="type">const</span> <span class="type">value_t</span> &amp;val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(__n &lt;= <span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="type">size_t</span> count = <span class="built_in">size</span>() - __n;</span><br><span class="line">            tail -= count;</span><br><span class="line">            <span class="keyword">this</span>-&gt;<span class="built_in">destroy_n</span>(tail,count);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;iter : *<span class="keyword">this</span>) &#123; iter = val; &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;iter : *<span class="keyword">this</span>) &#123; iter = val; &#125;</span><br><span class="line">            <span class="built_in">reserve</span>(__n);</span><br><span class="line">            <span class="type">size_t</span> count = __n - <span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">while</span>(count--) <span class="keyword">this</span>-&gt;<span class="built_in">construct</span>(tail++,val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief Copy elements from a range [first,last).</span></span><br><span class="line"><span class="comment">     * Note that the Iterator must be random access iterator.</span></span><br><span class="line"><span class="comment">     * Otherwise, you should provide the count of elements.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @tparam Iterator A random access iterator type.</span></span><br><span class="line"><span class="comment">     * @param first Iterator to the first element.</span></span><br><span class="line"><span class="comment">     * @param last  Iterator to one past the last element.</span></span><br><span class="line"><span class="comment">     * @attention Linear time complexity with respect to (last - first)</span></span><br><span class="line"><span class="comment">     * multiplied by the time of moving one element.</span></span><br><span class="line"><span class="comment">     * Note that there might be an additional time cost linear to the </span></span><br><span class="line"><span class="comment">     * elements destroyed.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Iterator</span>&gt;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">copy_range</span><span class="params">(Iterator first,Iterator last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">copy_range</span>(first,last - first);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief Copy elements from a range [first,last).</span></span><br><span class="line"><span class="comment">     * The number of elements in the range should be exactly __n,</span></span><br><span class="line"><span class="comment">     * or unexpected error may happen.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @param first Iterator to the first element.</span></span><br><span class="line"><span class="comment">     * @param last  Iterator to one past the last element.</span></span><br><span class="line"><span class="comment">     * @param __n   Count of all the elements in the range.</span></span><br><span class="line"><span class="comment">     * @attention Linear time complexity with respect to __n,</span></span><br><span class="line"><span class="comment">     * multiplied by the time of copying one element.</span></span><br><span class="line"><span class="comment">     * Note that there might be an additional time cost linear to the </span></span><br><span class="line"><span class="comment">     * elements destroyed.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Iterator</span>&gt;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">copy_range</span><span class="params">(Iterator first,<span class="type">size_t</span> __n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(__n &lt;= <span class="built_in">capacity</span>()) &#123;</span><br><span class="line">            <span class="type">value_t</span> *temp = head;</span><br><span class="line">            <span class="keyword">while</span>(__n-- &amp;&amp; temp != tail) &#123; *(temp++) = *(first++); &#125;</span><br><span class="line">            ++__n;</span><br><span class="line">            <span class="keyword">while</span>(__n--) &#123; <span class="keyword">this</span>-&gt;<span class="built_in">construct</span>(tail++,*(first++)); &#125;</span><br><span class="line">            <span class="keyword">this</span>-&gt;<span class="built_in">destroy_n</span>(temp,tail - temp);</span><br><span class="line">            tail = temp;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;~<span class="built_in">dynamic_array</span>();</span><br><span class="line">            term = (tail = head = <span class="built_in">alloc</span>(__n)) + __n;</span><br><span class="line">            <span class="keyword">while</span>(__n--) &#123; <span class="keyword">this</span>-&gt;<span class="built_in">construct</span>(tail++,*(first++)); &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief Move elements from a range [first,last).</span></span><br><span class="line"><span class="comment">     * Note that the Iterator must be random access iterator.</span></span><br><span class="line"><span class="comment">     * Otherwise, you should provide the count of elements.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @tparam Iterator A random access iterator type.</span></span><br><span class="line"><span class="comment">     * @param first Iterator to the first element.</span></span><br><span class="line"><span class="comment">     * @param last  Iterator to one past the last element.</span></span><br><span class="line"><span class="comment">     * @attention Linear time complexity with respect to (last - first),</span></span><br><span class="line"><span class="comment">     * multiplied by the time of moving one element.</span></span><br><span class="line"><span class="comment">     * Note that there might be an additional time cost linear to the </span></span><br><span class="line"><span class="comment">     * elements destroyed.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Iterator</span>&gt;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">move_range</span><span class="params">(Iterator first,Iterator last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">move_range</span>(first,last - first);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief Move elements from a range [first,last).</span></span><br><span class="line"><span class="comment">     * The number of elements in the range should be exactly __n,</span></span><br><span class="line"><span class="comment">     * or unexpected error may happen.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @param first Iterator to the first element.</span></span><br><span class="line"><span class="comment">     * @param last  Iterator to one past the last element.</span></span><br><span class="line"><span class="comment">     * @param __n   Count of all the elements in the range.</span></span><br><span class="line"><span class="comment">     * @attention Linear time complexity with respect to __n,</span></span><br><span class="line"><span class="comment">     * multiplied by the time of moving one element.</span></span><br><span class="line"><span class="comment">     * Note that there might be an additional time cost linear to the </span></span><br><span class="line"><span class="comment">     * elements destroyed.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Iterator</span>&gt;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">move_range</span><span class="params">(Iterator first,<span class="type">size_t</span> __n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(__n &lt;= <span class="built_in">capacity</span>()) &#123;</span><br><span class="line">            <span class="type">value_t</span> *temp = head;</span><br><span class="line">            <span class="keyword">while</span>(__n-- &amp;&amp; temp != tail) &#123; *(temp++) = std::<span class="built_in">move</span>(*(first++)); &#125;</span><br><span class="line">            ++__n;</span><br><span class="line">            <span class="keyword">while</span>(__n--) &#123; <span class="keyword">this</span>-&gt;<span class="built_in">construct</span>(tail++,std::<span class="built_in">move</span>(*(first++))); &#125;</span><br><span class="line">            <span class="keyword">this</span>-&gt;<span class="built_in">destroy_n</span>(temp,tail - temp);</span><br><span class="line">            tail = temp;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;~<span class="built_in">dynamic_array</span>();</span><br><span class="line">            term = (tail = head = <span class="built_in">alloc</span>(__n)) + __n;</span><br><span class="line">            <span class="keyword">while</span>(__n--) &#123; <span class="keyword">this</span>-&gt;<span class="built_in">construct</span>(tail++,std::<span class="built_in">move</span>(*(first++))); &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/* Return the pointer to the first element. */</span></span><br><span class="line">    <span class="function"><span class="type">value_t</span> *<span class="title">data</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> head; &#125;</span><br><span class="line">    <span class="comment">/* Return the pointer to the first element. */</span></span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">value_t</span> *<span class="title">data</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> head; &#125;</span><br><span class="line">    <span class="comment">/* Subscript access to the data in the %array.  */</span></span><br><span class="line">    <span class="type">value_t</span> &amp;<span class="keyword">operator</span> [] (<span class="type">size_t</span> __n) &#123; <span class="keyword">return</span> head[__n]; &#125;</span><br><span class="line">    <span class="comment">/* Subscript access to the data in the %array.  */</span></span><br><span class="line">    <span class="type">const</span> <span class="type">value_t</span> &amp;<span class="keyword">operator</span> [] (<span class="type">size_t</span> __n) <span class="type">const</span> &#123; <span class="keyword">return</span> head[__n]; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Reference to the first element. */</span></span><br><span class="line">    <span class="function"><span class="type">value_t</span> &amp;<span class="title">front</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> *<span class="built_in">begin</span>();&#125;</span><br><span class="line">    <span class="comment">/* Reference to the  last element. */</span></span><br><span class="line">    <span class="function"><span class="type">value_t</span> &amp;<span class="title">back</span><span class="params">()</span>  </span>&#123;<span class="keyword">return</span> *--<span class="built_in">end</span>();&#125;</span><br><span class="line">    <span class="comment">/* Const reference to the first element. */</span></span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">value_t</span> &amp;<span class="title">front</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> *<span class="built_in">cbegin</span>();&#125;</span><br><span class="line">    <span class="comment">/* Const reference to the  last element. */</span></span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">value_t</span> &amp;<span class="title">back</span><span class="params">()</span>  <span class="type">const</span> </span>&#123;<span class="keyword">return</span> *--<span class="built_in">cend</span>();&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> iterator       = RandomAccess::iterator       &lt;<span class="type">value_t</span>&gt;;</span><br><span class="line">    <span class="keyword">using</span> const_iterator = RandomAccess::const_iterator &lt;<span class="type">value_t</span>&gt;;</span><br><span class="line">    <span class="keyword">using</span> reverse_iterator = RandomAccess::reverse_iterator &lt;<span class="type">value_t</span>&gt;;</span><br><span class="line">    <span class="keyword">using</span> const_reverse_iterator = RandomAccess::const_reverse_iterator &lt;<span class="type">value_t</span>&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Iterator to the first element. */</span></span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span>  </span>&#123; <span class="keyword">return</span> head; &#125;</span><br><span class="line">    <span class="comment">/* Iterator to one past the last element. */</span></span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span>    </span>&#123; <span class="keyword">return</span> tail; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Const_iterator to the first element. */</span></span><br><span class="line">    <span class="function">const_iterator <span class="title">begin</span><span class="params">()</span>  <span class="type">const</span> </span>&#123;<span class="keyword">return</span> head;&#125;</span><br><span class="line">    <span class="comment">/* Const_iterator to one past the last element. */</span></span><br><span class="line">    <span class="function">const_iterator <span class="title">end</span><span class="params">()</span>    <span class="type">const</span> </span>&#123;<span class="keyword">return</span> tail;&#125;</span><br><span class="line">    <span class="comment">/* Const_iterator to the first element. */</span></span><br><span class="line">    <span class="function">const_iterator <span class="title">cbegin</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> head;&#125;</span><br><span class="line">    <span class="comment">/* Const_iterator to one past the last element. */</span></span><br><span class="line">    <span class="function">const_iterator <span class="title">cend</span><span class="params">()</span>   <span class="type">const</span> </span>&#123;<span class="keyword">return</span> tail;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Reverse iterator to the last element. */</span></span><br><span class="line">    <span class="function">reverse_iterator <span class="title">rbegin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> tail - <span class="number">1</span>; &#125;</span><br><span class="line">    <span class="comment">/* Reverse iterator to one before the first element. */</span></span><br><span class="line">    <span class="function">reverse_iterator <span class="title">rend</span><span class="params">()</span>   </span>&#123; <span class="keyword">return</span> head - <span class="number">1</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Const_reverse_iterator to the last element. */</span></span><br><span class="line">    <span class="function">const_reverse_iterator <span class="title">rbegin</span><span class="params">()</span>  <span class="type">const</span> </span>&#123;<span class="keyword">return</span> tail - <span class="number">1</span>;&#125;</span><br><span class="line">    <span class="comment">/* Const_reverse_iterator to one before the first element. */</span></span><br><span class="line">    <span class="function">const_reverse_iterator <span class="title">rend</span><span class="params">()</span>    <span class="type">const</span> </span>&#123;<span class="keyword">return</span> head - <span class="number">1</span>;&#125;</span><br><span class="line">    <span class="comment">/* Const_reverse_iterator to the last element. */</span></span><br><span class="line">    <span class="function">const_reverse_iterator <span class="title">crbegin</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> tail - <span class="number">1</span>;&#125;</span><br><span class="line">    <span class="comment">/* Const_reverse_iterator to one before the first element. */</span></span><br><span class="line">    <span class="function">const_reverse_iterator <span class="title">crend</span><span class="params">()</span>   <span class="type">const</span> </span>&#123;<span class="keyword">return</span> head - <span class="number">1</span>;&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> STL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022学年上半学期总结</title>
      <link href="/2022/12/09/summary/"/>
      <url>/2022/12/09/summary/</url>
      
        <content type="html"><![CDATA[<p>这学期几乎啥也没干，没啥好总结的。主要讲个人相关，会避免一些敏感话题。</p><h2 id="9月"><a href="#9月" class="headerlink" title="9月"></a>9月</h2><p>&emsp;最大的成就大概就是建了个blog，圆了OIer时代的旧梦。然而开学仅两周就遭到了疫情的迎头痛击，转线上课，而且还因为课程冲突导致”教师劫”没能回去看老师，哭。</p><p>&emsp;说实话，我个人是非常不喜欢线上上课的，因为我自律能力无，网课几乎就是摸鱼。不过线上课也是一个机遇，而且这段时间恰好是开学，学业负担 = 0。充足的时间使我有能力去补课一些OI算法(毕竟我在A班算法基础属于垫底水平orz)，也能偶尔做做物理竞赛题目(怀念啊~)，<del>还能有大把时间摸鱼电动，加上寝室车万浓度3/4直接爽上天</del>。当然，这段时间还顺便学了点设计傅里叶变换以及音频处理无关知识，作为副业说不定能赚点(笑)。</p><h2 id="10月"><a href="#10月" class="headerlink" title="10月"></a>10月</h2><p>&emsp;趁着国庆赶紧润回去了一趟，顺便初中同学聚会。然而回来后就开启了地狱模式，小作业大作业轮番轰炸，数分作业数量多到逆天(巅峰时一节课能布置26道题，一周3节课)。然后其他奇怪的课程的作业也接踵而至，不过到这里我还是勉强能应付的过来的，至少作业没有晚交缺交漏交，赢!。</p><h2 id="11月"><a href="#11月" class="headerlink" title="11月"></a>11月</h2><p>&emsp;大寄特寄的一个月，首先时学子讲坛和学术写作，好不容易水完了，然而后面两周就开始期中考试了，再然后int2048大作业还有python解释器的ddl也开始逼进，中间除了期中考试结束那一周，几乎没有休息的时间。</p><p>&emsp;这大概是我这学期最累的一段时间了，平均睡眠时间已经快要低于7.5个小时了，这是高中从没有的情况，这段时间我真的是天天晚上EMO发电。不过好在我心态比较好 <del>(非常佛系)</del> ，而且之前接触过大作业相关的一些东西(9月恰好学了点FFT，然后用在了int2048)，苟到了月末，还抽空回去拿了冬装。</p><p>&emsp;总之，这是最累的一个月，这也是最充实的一个月，也是最快乐的一个月。</p><p><img src="https://s2.loli.net/2023/01/28/X1lnctef5WiRTpz.jpg" alt=""><br><img src="https://s2.loli.net/2023/01/28/KS8lOqFUw3XVfxL.jpg" alt="刚肝完学子讲坛、学术写作和检查点的我belike"><br><img src="https://s2.loli.net/2023/01/28/Go51y4sPWbJVqIR.jpg" alt="肝完python解释器后我杀疯的状态，你见过4 a.m.的OJ吗"><br><img src="https://s2.loli.net/2023/01/28/OjxiVsH6MvZyb9n.jpg" alt="可爱的"></p><h2 id="12月"><a href="#12月" class="headerlink" title="12月"></a>12月</h2><p>&emsp;虽然才过了几天，但啥事情都有（。印象很深的是12/1号那天下了场雪(上海难得11月下雪)，然后在雪中踢球，可能是这学期玩的最开心的一次。</p><p><img src="https://s2.loli.net/2023/01/28/qfAOp3aRTZCK6HD.jpg" alt="拍的不好,照片里一片雪都看不见"></p><p>&emsp;接下来就是很魔幻的第二周，首先是因为混管阳性，东17封楼了。然后在短暂的经历了一天不能堂食的生活后，我校再次回到了线上课的时代，好在打饭还是允许的，楼也没封。目前(2022.12.9)<strong>情况未知</strong>，貌似是鼓励返乡线上学习的(效仿之前清北的先例?)，本来四级要求的做的核酸也不需要了，体测什么也取消了，总之非常的神奇非常的魔幻，我也不太敢评价。</p><p><img src="https://s2.loli.net/2023/01/28/1zCl2wjtZmPFdVM.jpg" alt="群里的通知"></p><p>&emsp;本人最终于12月18日回家了，然而回家前就已经感觉不太好了，回家不到一周果然阳了。阳了感觉非常不好，高烧了三天，将近一周的课都没听，大作业也一点没动，再加上期末考临近，压力巨大。不过好在后续恢复非常快，而且没有很剧烈的咳嗽等后遗症影响，状态恢复的非常好，并没有太多的影响期末考试。</p><p>&emsp;月末，好多课程作业的ddl接踵而至，确实有点忙，幸好阳之前已经基本完成数分论文和伟大思想论文(顺便打个广告:<a href="https://github.com/DarkSharpness/DarkSharpness/blob/main/Tex/MA/MA.pdf">数分</a>,<a href="https://github.com/DarkSharpness/DarkSharpness/blob/main/Tex/Quantum/quantum.pdf">伟大</a>)。感谢几位好友的帮助，我能在年前基本完成这些作业。</p><h2 id="1月"><a href="#1月" class="headerlink" title="1月"></a>1月</h2><p>&emsp;考试月，事情不多，主要是在复习。对我来说，我只care数分、线代、英语和程设。在这四门中，首先考的是数学分析，这张卷子说实话感觉不太难，但是问题在于我这段时间基本没咋做数分题目，导致做的太慢了，结果2个小时最后两题(含一道附加题)都没看到，考完真的急死了，毕竟理论最高分也就只有90了，更何况前面还没有检查。结果不出所料的裂开了，而且数分卡在了94分这个尴尬的分数，不过确实下半学期数分上的精力花的少，罪有应得。第二个考的好像是英语，英语说实话我也没指望能考多高，前段时间因为新冠导致好长一段时间没听英语听力了，听力也不出意外的出了些意外；阅读选择倒是不难，毕竟我可是大城市做题家(除了应试啥都不会的废物罢了)；作文中规中矩，反正还是和以前一样，即兴发挥，啥句子都不准备，完全靠感觉，然后凑一些老师喜欢听的观点升华一下，大概就能拿高分。最后在10号考了剩下两门，程序设计完全没复习，反正摆就完事了，C++不会的特性太多了，大概扫了一遍书就去考了。这里不得不吐槽下线性代数，考试卷子实在太简单了，而作为一个因为新冠从12月中旬就没听过线代课、作业全靠糊、上课狂发呆的普通学生，我居然都能提前一个小时做完而且没检查出错就能拿100，实在是楽坏了。然后上海下大雪了两天，有点怀念前面12月初那次雪天踢球了qwq。</p><p><img src="https://s2.loli.net/2023/01/28/sKcqAfyiVUI1uNB.jpg" alt=""></p><p>&emsp;考完以后基本放飞自我，直接开摆，每天睡眠高达10小时，作息非常健康。除了有几天去走亲访友，基本上每天我都呆在房间里看电脑，当然除了玩minecraft(这是主线!)，我还在写一些 C++ 模板以及研究modern C++ 特性。作为一个 CSP-S 压线一等奖的蒟蒻，我觉得算法已经来不及补课，计划等春节后再去补习。当然考完试，我也终于有时间把以前没好好听过的和新专辑都刷几遍的，比如 IOSYS 那几张 jrock 专辑(墙裂推荐，附 <a href="https://music.163.com/playlist?id=8063965041&amp;userid=3215760601">网易云歌单</a>) 以及 Demetori 的新专辑 《寂光寂滅 ～ The Truth of the Cessation of Dukkha》，还有可爱的ayo、merami的新歌。说实话，感觉现在车万同人音乐已经基本快要走向其终点了，C101 会场摊位数占比再次破新低，回到了2010年以前东方还未到最火的时候的状况了。感觉很难过，不过好像我也做不了什么，很欣慰还有几个老社团依然在坚持。</p><p><img src="https://s2.loli.net/2023/01/28/vM5PFD8aEqmjVnS.png" alt="我在minecraft里的前卫小屋(雾)"></p><p><img src="https://s2.loli.net/2023/01/22/nl4iJLGsUtzafKx.png" alt=""><br><img src="https://s2.loli.net/2023/01/22/bo9uWGMsqkgvirE.png" alt=""><br><img src="https://s2.loli.net/2023/01/22/HSQ8ZzOx7LeN9dB.png" alt=""><br><img src="https://s2.loli.net/2023/01/28/a9Pcuo3DweG7EZv.png" alt=""><br><img src="https://s2.loli.net/2023/01/28/9XzaFMyonV5rctB.png" alt="东方Gartic服务器(QQ:329193219)的春节烟火会"></p><!-- 图片 --><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>&emsp;这学期，我觉得我收获了许多。首先是学子讲坛，这极大的扩展了我的视野，这样的形式让我接触到了好多我不可能接触到的知识。然后是数学方面，我学习了部分入门级别的数学分析的知识，还有简单的线性代数知识，其中特别感谢 <a href="http://basics.sjtu.edu.cn/~chen/teaching/">Yijia Chen</a> 一学期的教导，其讲解线性代数十分细致，而且其也很好的诠释了线性代数中许多抽象公式背后的几何直观。这样的讲解方法，我非常喜欢，而且其slides详细到即使我不听课只看讲义，我也能很快理解其所想要表达的东西。还有就是程序设计，我学到了许多 C++ 的语法基础，这填补了我的知识体系漏洞，而那些大小作业不仅巩固了我破烂的算法基础，还提升了我的工程能力。感谢可爱的翁老师以及耐心的助教们！在课外，我学了一点点音频处理基础以及 Modern C++ 的特性，为了写这个破blog还学了不少 CSS 和 JS 的知识(然而目前主要还是抄板子或者查百度)。</p><p>&emsp;最后的最后，祝您新年快乐，感谢您耐心看到这里！</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
          <category> 总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一些关于常数的玄学优化</title>
      <link href="/2022/12/01/optimization/"/>
      <url>/2022/12/01/optimization/</url>
      
        <content type="html"><![CDATA[<p>注意，本文提到的优化大多是在基于程序复杂度正确的情况下对于一些常数的优化，本质是只是一种奇淫技巧，请勿滥用。所有测试数据全都是基于笔者的破电脑，且受随机因素影响，仅供参考。</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="时间复杂度-Everything？"><a href="#时间复杂度-Everything？" class="headerlink" title="时间复杂度 = Everything？"></a>时间复杂度 = Everything？</h3><p>&emsp;一个程序的快慢取决于什么？你可能会说是时间复杂度。的确如此，在大的数据量的情况下，渐进复杂度更优的算法肯定会跑的比更劣的快。(注: 在本文中的复杂度默认是 大O 时间复杂度，用数学语言表述即假设一个程序的实际运行为$T(n)$，$\exists N,c\in \mathbb{R}, \forall n \in \mathbb{N},n \geq N ，s.t. \  T(n) \leq c * O(n) $ )。我们常常会忽略其中的常数 $ c $ ，这在渐进意义下是没太大的影响的。但是，在应用场景下，往往输入的数据规模并不会太大，在这样的情况下，算法的常数便会变得不可忽略。</p><p>&emsp;举个不太恰当的例子，我们假设有一个很快的处理算法，其执行时间是 $T_1(n) = 1000 nlog_2n $ ，也有一个朴素的暴力做法，其执行时间是 $ T_2 = 0.5 n ^ 2$。此时，当 $ n \gt 29718 $ 的时候，第一个方法才会优于 第二个方法。单从时间复杂度上来看，第一个操作是 $ O(nlogn) $ 的，理应优于第二个 $O(n^2)$的操作。但是，受制于常数过大，只有当数据量足够大的时候，其才显得更加高效。而现实中，需求的数据量可能并不会达到这么大，这也会使得第一个算法变得无用。</p><p>&emsp;一言以蔽之，就是算法本身的时间复杂度固然重要，但其常数也不可忽略，而具体如何取舍取决于数据量的大小。</p><h3 id="常数优化的意义"><a href="#常数优化的意义" class="headerlink" title="常数优化的意义"></a>常数优化的意义</h3><p>&emsp;常数优化在OI中意义并不大，在大多情况下OI追求的是算法的正确性，而不会刻意去卡常数。但在实际运用中，一些细节处的常数可能会导致巨大的时间差异。例如作业<a href="https://github.com/ACMClassCourse-2022/ICPC-Management-System-2022">ICPC管理系统中</a>，若不进行适当优化，则很容易使得程序运行常数增加 $m$ (最大为26，故可视作常数) 倍，这会使得 AC-&gt;TLE</p><p><img src="https://s2.loli.net/2023/01/28/dtUnQEphYKXGJbF.png" alt="笔者瞎优化过后code稳定在2750ms上下"></p><p><img src="https://s2.loli.net/2023/01/28/O6qZJ9wEpzedki3.png" alt="对比以下比较慢的实现。"></p><p>如果是真实的项目(例如手机APP)，20倍的常数差异可能就意味着客户等 0.1s(几乎无卡顿)和等 2s (是个人都能看出的卡顿)的区别，<del>为了您的客户、钱包还有打榜的快感</del> ，常数优化显得十分有必要。</p><h2 id="认识常数优化"><a href="#认识常数优化" class="headerlink" title="认识常数优化"></a>认识常数优化</h2><p>笔者是菜狗，不会汇编，对更深层的优化不太了解，所以只能分享以下一些简单的入门级优化。</p><p>再次声明，本文内容不保证100%正确性，只是笔者一家之言，具体表现还会受到随机波动以及测评环境不同带来的影响。</p><h3 id="测评环境"><a href="#测评环境" class="headerlink" title="测评环境"></a>测评环境</h3><p>CPU: 12th Gen Intel(R) Core(TM) i7-12700H<br>基准速度:    2.30 GHz<br>插槽:    1<br>内核:    14<br>逻辑处理器:    20<br>虚拟化:    已启用<br>L1 缓存:    1.2 MB<br>L2 缓存:    11.5 MB<br>L3 缓存:    24.0 MB</p><p>操作系统: Microsoft Windows 版本22H2<br>(OS内部版本22621.819)</p><p>GCC version 12.2.0 (x86_64-posix-seh-rev0, Built by MinGW-W64 project)</p><h3 id="认识常数"><a href="#认识常数" class="headerlink" title="认识常数"></a>认识常数</h3><p>&emsp;常数的确是一个非常玄学的东西，在正常的算法书上一般不会去分析，它也很难量化到具体的数值，因为影响它的因素确实太多了。在这里，<strong><em>我们定义常数</em></strong> $ c = \frac{T(n)}{O(n)} $，其中 $O(n)$ 无常数的多项式，默认 <strong>对数以2为底数</strong> (下将简记为$ logn $)。</p><p>&emsp;笔者参考了一下2009国家集训队论文中骆可强所著的<a href="https://github.com/lzyrapx/Competitive-Programming-Docs/blob/master/%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9F%E5%8E%86%E5%B9%B4%E8%AE%BA%E6%96%87%E9%9B%86/%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9F2009%E8%AE%BA%E6%96%87%E9%9B%86/4.%E9%AA%86%E5%8F%AF%E5%BC%BA%E3%80%8A%E8%AE%BA%E7%A8%8B%E5%BA%8F%E5%BA%95%E5%B1%82%E4%BC%98%E5%8C%96%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%B9%E6%B3%95%E4%B8%8E%E6%8A%80%E5%B7%A7%E3%80%8B/%E8%AE%BA%E7%A8%8B%E5%BA%8F%E5%BA%95%E5%B1%82%E4%BC%98%E5%8C%96%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%B9%E6%B3%95%E4%B8%8E%E6%8A%80%E5%B7%A7.pdf">《论程序底层优化的一些方法与技巧》</a>，认为常数大致与以下几个方面有关:</p><ul><li>机器本身程序语句在底层运行的消耗</li><li>算法本身设计的消耗(即含有多少次加减乘除之类)</li><li>问题的数据规模(即前文的 $n$ )</li></ul><p>&emsp;值得注意的是，由于笔者对于常数的独特定义，其可能会与数据规模 $n$ 有关，但是其仍然需要满足 $\lim_{n \to \infty}c = constant $ 这一基本性质。</p><h2 id="如何减少常数-基本运算篇"><a href="#如何减少常数-基本运算篇" class="headerlink" title="如何减少常数(基本运算篇)"></a>如何减少常数(基本运算篇)</h2><p><strong><em>重要的事情说在前面:</em></strong><br><strong><em>重要的事情说在前面:</em></strong><br><strong><em>重要的事情说在前面:</em></strong><br>&emsp;以下测试均基于C++ rand() 产生的随机数，所有操作若未特定说明默认为int类型。(如果是更长的类型long long且在64位操作系统上运作，则大致可认为效率与int相当，实测差距几乎不会超过1.5倍。)</p><p>&emsp;由于机器本身程序语句在底层运行的消耗是不太可控，我们将主要从算法本身设计的消耗进行分析。像加减乘除位运算以及赋值等基础操作，你显然无法进行直接优化，但你可以通过了解一些基本的原理来减少程序主体的常数。</p><h3 id="整数的位运算和逻辑判断"><a href="#整数的位运算和逻辑判断" class="headerlink" title="整数的位运算和逻辑判断"></a>整数的位运算和逻辑判断</h3><p>&emsp;计算机底层是通过位运算和赋值来进行操作的，因此最快的操作是位运算和赋值语句以及逻辑判断。位运算包含了: 异或 ^ ， 或 | ， 与 &amp; ，取补 ~ ，左移 &lt;&lt; ，右移 &gt;&gt; 。 逻辑判断则是一切含 == &lt; &gt; ! 的判断语句。</p><p>&emsp;以上具体可以体现在当你要快速求出2的n次幂的时候可以简单的使用 <code>1 &lt;&lt; n</code>，而不是用快速幂或者库里面的pow函数。同时，对于取出特定的二进制的值，特别是在一些涉及状态压缩 dp (即把状态用二进制数来存储表示)的题目里面，需要频繁用到位运算。(事实上，这应该是一些基础知识，而不是玄学)。当然对于对2的取模或者除法也因此可以优化。</p><p>以下列举了一些作者 OI 里常用到的位运算</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i,n;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 常用的位操作 */</span></span><br><span class="line">~i  <span class="comment">// 取补 可以用来代替判断一个数是不是 -1 (仅仅好看,并无啥优化...)</span></span><br><span class="line">i &amp; (<span class="number">1</span> &lt;&lt; n) <span class="comment">// 取出i的第n位(第0为2 ^ 0 即最低位),若这一位为 1 则返回 1 &lt;&lt; n , 否则返回 0</span></span><br><span class="line">(i &gt;&gt; n) &amp; <span class="number">1</span> <span class="comment">// 上一个的变种，不过仅用来判断第n位是不是 1 ,是则返回 1 否则返回 0 </span></span><br><span class="line">(~i) &amp; (<span class="number">1</span> &lt;&lt; n) <span class="comment">// 取出i的第n位,但是这一位是0则返回 1 &lt;&lt; n ,否则返回 0</span></span><br><span class="line">((~i) &gt;&gt; n) &amp; <span class="number">1</span> <span class="comment">// 上一个的变种,第 n 位是 0 返回 1 ,否则返回 1</span></span><br><span class="line">!((i &gt;&gt; n) &amp; <span class="number">1</span>) <span class="comment">// 效果完全同上</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 特殊的优化 */</span></span><br><span class="line">i &amp; <span class="number">1</span>   <span class="comment">// 相当于 i % 2</span></span><br><span class="line">i &gt;&gt; <span class="number">1</span>  <span class="comment">// 相当于 i / 2</span></span><br><span class="line">i &lt;&lt; <span class="number">1</span>  <span class="comment">// 相当于 i * 2</span></span><br><span class="line">i &amp; ((<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>) <span class="comment">// 相当于 i % pow(2,n)</span></span><br><span class="line">i &gt;&gt; n             <span class="comment">// 相当于 i / pow(2,n)</span></span><br><span class="line">i &lt;&lt; n             <span class="comment">// 相当于 i * pow(2,n)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 其他的 OIer 常用表述 */</span></span><br><span class="line">i &lt;&lt; <span class="number">1</span> | <span class="number">1</span> <span class="comment">// 相当于 i * 2 + 1,较为常用</span></span><br><span class="line">i &lt;&lt; <span class="number">1</span> ^ <span class="number">1</span> <span class="comment">// 同上,但笔者见到这么写的不多</span></span><br><span class="line">i ^= <span class="number">1</span>  <span class="comment">// 奇偶性调换, 2k + 1 &lt;=&gt; 2k , 常用于用滚动数组0-1切换 , 链式前向星双向边的切换 </span></span><br><span class="line">i ^= n  <span class="comment">// 在 i,i ^ n 两个数之间快速切换 , 一个比较美观的写法(利用a ^ b ^ b = a)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>附:若要更深入了解运用位运算，读者可自行查询 <a href="https://en.cppreference.com/w/cpp/utility/bitset">STL bitset</a> 相关内容 <del>，这玩意可是卡常利器</del>。</p><h3 id="整数的加减乘除模"><a href="#整数的加减乘除模" class="headerlink" title="整数的加减乘除模"></a>整数的加减乘除模</h3><p>&emsp;整数的加减乘除模是除了位运算和逻辑判断之外的计算机的基础操作，其效率并比不过单纯的位运算，但也没有想象中那么拉跨。</p><p>&emsp;在加减乘除模这五个最基础的操作中，加法和减法的时间开销几乎相差无几，可以认为相同。而乘法作为现代CPU的基本运算操作之一，其速度也较快，可以认为和加减法相差无几。笔者实测波动较大，估计时间消耗为加减法的1.0 ~ 1.3倍(仅供参考，实际中甚至出现过随机数乘法快于加法的逆天情况)，这也告诉了我们，我们<strong>完全没有必要</strong>刻意的优化一个乘法过程。而相比之下，除法和取模就是相对较慢的过程，笔者实测两者效率大致相同，平均比加法要慢上个 2 ~ 4 倍，并没有网上传言的 10 多倍那么恐怖(当然，这可能因机器而异)。</p><p>&emsp;针对除法取模慢的特性，我们可以通过减少其操作次数来极大地减小常数。除了之前讲到的位运算等操作，产检的做法还有推迟取模。例如一个程序过程中如果要对一个数取模，在保证不会爆存储类型(int或long long)的范围的情况下，可以在运算过程中尽可能减少取模次数，而在最后对答案统一取模来减小常数。事实上，这一操作是值得的，你甚至可以为此把int换long long来防止爆范围来换取更少的取模次数。</p><h3 id="消除逻辑分支"><a href="#消除逻辑分支" class="headerlink" title="消除逻辑分支"></a>消除逻辑分支</h3><p>&emsp;在现代计算机中，逻辑分支其实是个比较慢的过程，其包括if/else if/else的分支，for/while的分支，以及三目运算符 ? : 的分支(注:其不是逻辑判断，逻辑判断是一个很快的过程；goto本文不涉及)。其背后是因为CPU是像流水线一样的在工作，一条指令还没结束的时候，后面的许多指令也以及开始执行。但当CPU遇到分支的时候，它无法知道后面会要执行哪个分支的语句，因而会暂停流水线，直到分支走向确定。尽管现代CPU早已拥有了强大的分支预测的的操作，对于有规律的分支会进行较为准确的预测，但在完全随机下其还是一个相对缓慢的一个过程。但是，我们完全没有必要为了逻辑分支而用加法替代，现在逻辑分支依旧是一个非常高效的过程。</p><p>&emsp;以下给出一些笔者常用的方法。</p><ol><li>短数据打表</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回类型为std::string的函数</span></span><br><span class="line"><span class="keyword">if</span>(x) <span class="keyword">return</span> std::<span class="built_in">string</span>(<span class="string">&quot;YY&quot;</span>); </span><br><span class="line"><span class="keyword">else</span>  <span class="keyword">return</span> std::<span class="built_in">string</span>(<span class="string">&quot;NN&quot;</span>) ;<span class="comment">// 慢</span></span><br><span class="line"><span class="type">const</span> std::string strMap[<span class="number">2</span>] = &#123;<span class="string">&quot;NN&quot;</span>,<span class="string">&quot;YY&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">return</span> strMap[x];</span><br></pre></td></tr></table></figure><p>&emsp;值得一提的是，这个优化在strMap用char *来存的时候如果开O2会失效，因为-O2优化会省去if过程中的std::string构造函数的过程，但对于数组中的元素初始化str，其构造函数无法略去。这也启发我们: 在优化时开的数组要用和赋值时一样的类型，以尽可能避免类型转换带来的开销。</p><p>同&emsp;时，这个优化在开-O2的情况下对短数据类型例如int和long long是负优化，但在非-O2的情况下却是正向优化，笔者暂时还未分析出原因(怀疑和数据8-byte对齐相关)，如果您知道为什么，欢迎来告诉本蒟蒻orz，不胜感激。</p><p>&emsp;总结: 若无任何优化可以大胆使用该优化，在-O2的条件下可以适当的对非基本数据类型，例如std::string等通过打表了消除分支。在有效优化的情况下效率大约能达到两倍</p><ol><li>在程序主题逻辑实现上减少预测分支数量</li></ol><p>&emsp;假如有一个if和for循环嵌套，如果if的判断独立于for循环，请把if判断提前，for循环写在if之中，这样可以减少循环次数 - 1次的判断。</p><p>&emsp;同时，对于大量情况的 if/else if/else 语句，如果有可能请换为 switch/case 操作，switch/case 本质是跳转表，相比多个 else if 更为高效。笔者一般对于超过4个情况的 if 语句就会转化为 switch/case ，这么写不仅会更高效而且直观性也会更好。需要注意的是case:后会进行到底，若要用于替代 if 语句请记得break;</p><p>&emsp;若还想追求极致的效率，可以自行搜索__builtin_expect 函数、[[likely]]和[[unlikely]]（C++20），这里先不展开了。</p><h2 id="如何减少常数-C-特性篇"><a href="#如何减少常数-C-特性篇" class="headerlink" title="如何减少常数(C++特性篇)"></a>如何减少常数(C++特性篇)</h2><p>&emsp;除了程序底层运算层面的优化，了解C++语言，我们也能极大的减小程序的常数，这包括了C++内置的一些函数以及语言自带的一些features，也涉及编译器的一些底层原理。</p><h3 id="输入与输出优化"><a href="#输入与输出优化" class="headerlink" title="输入与输出优化"></a>输入与输出优化</h3><p>&emsp;这个是为较多人所知的一点，即C++最常见输入和输出工具 std::cin 和 std::cout 其实非常缓慢。这是因为 cin cout 在标准库中要求与 C 的输入输出工具 printf，scanf等同步，而这会带来一些额外的开销。最简单的办法就是关闭流同步，只需要 <code>std::ios::sync_with_stdio(false);</code>一句即可，可以让cin cout快2 ~ 3倍(纯经验，仅供参考!)。这样的副作用是不能cin/cout和scanf/printf/getchar/putchar/puts混用，要么用C++的输入输出，要么用C的。</p><p>&emsp;以上优化可以把cin/cout提升到远超过scanf/printf的效率了，而且在本地测试的时候，实际上已经比普通的快速读入(手写read())要快了不少了(大约1.2倍)。然而，在各大测评机中，貌似还是手写的快读来的快。这里提供个作者写的板子。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;integer&gt;</span><br><span class="line"><span class="function">integer &amp;<span class="title">read</span><span class="params">(integer &amp;tmp)</span> </span>&#123;</span><br><span class="line">    tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="type">bool</span> fl = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch = <span class="built_in">getchar</span>())) &#123;</span><br><span class="line">        <span class="keyword">if</span>(ch == <span class="string">&#x27;0&#x27;</span>) fl = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">        tmp = tmp * <span class="number">10</span> + (ch ^ <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(fl) tmp = -tmp;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n = <span class="built_in">read</span>(n); <span class="comment">// ok</span></span><br><span class="line"><span class="type">int</span> m;  <span class="built_in">read</span>(m); <span class="comment">// ok</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>&emsp;</p><h3 id="常量修饰-const-和-constexpr-C-14"><a href="#常量修饰-const-和-constexpr-C-14" class="headerlink" title="常量修饰(const 和 constexpr(C++14))"></a>常量修饰(const 和 constexpr(C++14))</h3><p>&emsp;C++的const和constexpr是一个非常有趣的东西，被const和constexpr的值是不可修改的，因此编译器会对其进行较大的优化。这是因为对于固定整数的运算可以简化为更基础的运算，这点在取模和除法上有极好的体现。</p><p>&emsp;具体来说，经过编译器优化(即使没开-O2)，对固定constexpr/const常数的取模和除法会被优化为一系列位运算，加减和乘法操作，这样可以使得取模和除法的时间大大减小。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1000</span>;      <span class="comment">// 常数请务必加上const</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> mod = <span class="number">1000</span>;  <span class="comment">// C++ 14以后</span></span><br><span class="line"><span class="type">int</span> mod = <span class="number">1000</span>;            <span class="comment">// 不好，这样不容易被优化</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>&emsp;更加深入的，如果你要对几个常数取模或除法，请不要将其用数组存，并且函数中用参数决定是对哪个常数操作，因为这样的话编译时无法确定需要进行哪个操作，这样无法进行常量展开优化。以如下快速幂为例。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> mod[<span class="number">2</span>] = &#123;<span class="number">114514</span>,<span class="number">1919810</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不要这么写函数，会很慢</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">quick_pow</span><span class="params">(<span class="type">int</span> base,<span class="type">int</span> pow,<span class="type">bool</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(pow) &#123;</span><br><span class="line">        <span class="keyword">if</span>(pow &amp; <span class="number">1</span>) ans = (ans * base) % mod[type];</span><br><span class="line">        base = (base * base) % mod[type];</span><br><span class="line">        pow &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">quick_pow</span>(<span class="number">666</span>,<span class="number">23333333</span>,<span class="number">0</span>)</span><br><span class="line"><span class="built_in">quick_pow</span>(<span class="number">666</span>,<span class="number">23333333</span>,<span class="number">1</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>&emsp;笔者给出的解决方案有两种:</p><ol><li>使用模板展开(即 <code>template &lt;int type&gt;</code>)</li><li>手动展开函数(即写多个版本)</li></ol><p>这样操作以后在非-O2环境下优化不明显，但是一旦开了-O2优化，效率能达到未展开时候的2倍。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> mod[<span class="number">2</span>] = &#123;<span class="number">114514</span>,<span class="number">1919810</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这么写编译器会手动展开</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> type&gt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">quicker_pow</span><span class="params">(<span class="type">int</span> base,<span class="type">int</span> pow)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(pow) &#123;</span><br><span class="line">        <span class="keyword">if</span>(pow &amp; <span class="number">1</span>) ans = (ans * base) % mod[type];</span><br><span class="line">        base = (base * base) % mod[type];</span><br><span class="line">        pow &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 手动展开即可，这里省略。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_pow0</span><span class="params">(<span class="type">int</span> base,<span class="type">int</span> pow)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_pow1</span><span class="params">(<span class="type">int</span> base,<span class="type">int</span> pow)</span></span>;</span><br><span class="line"></span><br><span class="line">quicker_pow &lt;<span class="number">0</span>&gt; (<span class="number">666</span>,<span class="number">23333333</span>);</span><br><span class="line">quicker_pow &lt;<span class="number">1</span>&gt; (<span class="number">666</span>,<span class="number">23333333</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="STL容器基础优化"><a href="#STL容器基础优化" class="headerlink" title="STL容器基础优化"></a>STL容器基础优化</h3><p>&emsp;很多人都觉得STL容器很慢，但这是他们的错觉。在开了-O2的情况下，正确使用STL容器是可以跑的很快的，<del>你甚至可以骗到很多的分</del>。(如果你还不会STL，可以看看这篇<a href="https://darksharpness.github.io/2022/10/23/%E6%B5%85%E8%B0%88C++STL/STL/">浅谈STL</a>)</p><p>&emsp;首先，容器是用于存储、维护数据的结构，其内部往往含有很多元素。如果我们像基础的数据类型那样随便开变量赋值，那么运行时开销将会巨大，这是因为容器赋值的过程中需要将元素全都赋值一遍，这个过程时间复杂度正比于容器内元素个数，很容易使得常数翻很多倍，应当避免。<strong>正确的做法是在能够引用传递参数的地方都应该使用引用传参。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vector &lt;string&gt; vec;</span><br><span class="line"><span class="keyword">for</span>(string str : vec) &#123;<span class="comment">// 不好，这样会带来不必要的拷贝</span></span><br><span class="line">    cout &lt;&lt; str;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">const</span> string &amp;str : vec) &#123; <span class="comment">// 正解，可以减少拷贝带来的开销 </span></span><br><span class="line">    cout &lt;&lt; str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>&emsp;同时，若明确的知道一个容器内的元素无用了，我们在赋值时应该使用std::move把这个元素变为右值，进而避免拷贝(C++ 移动赋值函数本质只需要交换指针，所以很快)。或者，我们可以用STL共有的函数swap()来交换两个容器内的元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vector &lt;string&gt; vec1,vec2;</span><br><span class="line"></span><br><span class="line">vec1 = vec2; <span class="comment">// 复制，复杂度线性</span></span><br><span class="line">vec1 = std::<span class="built_in">move</span>(vec2) <span class="comment">// 移动，之后vec2不可再访问</span></span><br><span class="line">vec1.<span class="built_in">swap</span>(vec2) <span class="comment">// 交换，和移动一样是 O(1) 操作</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>&emsp;<strong>下面将具体分析几个常用的容器。</strong></p><p>&emsp;对于std::vector，其瓶颈在于对对象的析构和初始化，以及扩容时的拷贝开销。前者只能通过自己写vector来实现，并不推荐。而后者在很多时候是可以预测的，例如我们用vector来模拟栈在尾部进行push_back和pop_back操作时，当我们知道vector最大可能的容积的时候，应该使用reserve函数提前预留空间。这么做会使得小数据时性能有所损失，但在数据量跑到极限的情况下可以免除拷贝数组的开销，能使趋向极限情况时候常数减半。同时，如果需要用vector作为一个临时的局部数组，也应该使用resize()先指定大小或者在初始化的时候直接指定，不要一个一个的push_back()。</p><p>&emsp;对于std::stack，其本质是一个容器适配器，它知识对内部容器的包装，而内部容器只需提供size(),push_back(),pop_back()等接口即可。其默认是用std::deque作为适配器，这样可以保证每次添加元素都是严格的O(1)。但是，众所周知的是deque的常数巨大无比，因此这样很容易导致效率低下。笔者的建议是使用类似 <code>std::stack&lt;int,std::vector&lt;int&gt;&gt;</code>来使用一个基于vector的stack。</p><p>&emsp;对于std::priority_queue，其是一个堆，在不开-O2优化时候较慢，但是开了-O2后和手写效率差距在2倍以内，属于勉强可以接受的程度。其默认是小根堆，如果要用大根堆可以把数字取负后存储。对于要维护恰两个信息的堆也可以使用 std::pair 来维护。</p><p>&emsp;对于std::map，其本质是一颗红黑树，查询元素基于 &lt; 运算符(判断相等即 <code>a &lt; b &amp;&amp; b &lt; a</code>)，最坏查询复杂度为log(n)。如果你的map仅仅在一开始需要初始化，之后就不再修改元素，你可以使用结构体排序代替。具体见如下代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N = <span class="number">1e6</span>;</span><br><span class="line">std::map &lt;std::string,<span class="type">int</span>&gt; mp;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">&#125;t[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最无脑的初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string str;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; n ; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; str &gt;&gt; x;</span><br><span class="line">        mp[str] = x; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优化后的初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string str;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; n ; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; str &gt;&gt; x;</span><br><span class="line">        t[i].name = str;</span><br><span class="line">        t[i].value = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(t,t + n,[](<span class="type">const</span> node &amp;X,<span class="type">const</span> node &amp;Y)-&gt;<span class="type">bool</span>&#123;<span class="keyword">return</span> X.name &lt; Y.name;&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二分找</span></span><br><span class="line"><span class="function"><span class="type">int</span> &amp;<span class="title">find</span><span class="params">(std::string name)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>,r = n;</span><br><span class="line">    <span class="keyword">while</span>(l != r) &#123;</span><br><span class="line">        <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> cmp = name.<span class="built_in">compare</span>(t[mid].name);</span><br><span class="line">        <span class="keyword">if</span>(cmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            r = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(cmp &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">return</span> t[mid].value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t[l].value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mp[str] <span class="comment">// 原先获取str对应的元素的方法</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">find</span>(str) <span class="comment">// 新的获取str对应元素的方法</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>&emsp;对于std::unordered_map，其本质是一个散列表，但是其常数巨大而且容易出现hash碰撞，因此为了防止被hack请书写hash函数。(from CodeForce)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">custom_hash</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">uint64_t</span> <span class="title">splitmix64</span><span class="params">(<span class="type">uint64_t</span> x)</span> </span>&#123;</span><br><span class="line">        x += <span class="number">0x9e3779b97f4a7c15</span>;</span><br><span class="line">        x = (x ^ (x &gt;&gt; <span class="number">30</span>)) * <span class="number">0xbf58476d1ce4e5b9</span>;</span><br><span class="line">        x = (x ^ (x &gt;&gt; <span class="number">27</span>)) * <span class="number">0x94d049bb133111eb</span>;</span><br><span class="line">        <span class="keyword">return</span> x ^ (x &gt;&gt; <span class="number">31</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">uint64_t</span> x)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">uint64_t</span> FIXED_RANDOM = chrono::steady_clock::<span class="built_in">now</span>().<span class="built_in">time_since_epoch</span>().<span class="built_in">count</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">splitmix64</span>(x + FIXED_RANDOM);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>, custom_hash&gt; safe_map;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>&emsp;除此之外，在 1e5 到 1e6 的数量级下，你可以把unrodered_map认为是一个常数大约为map 1/8 到 1/4的一个map，其相距map优势并不是很大。当然，你依然可以做出针对性优化。你可以使用reserve()函数来为其预留足够的桶的大小，一定程度上减小时间。(一般来说桶越大，效果越好)</p><p>&emsp;最后简单总结下，其实根据作者经验，在开O2的情况下，STL容器的效率已经是相当的高了，可以说完全不需要担心和手写的容器之间的效率差距。但是，对于极端毒瘤卡常题目，还是老老实实手写吧。</p><h2 id="一些更加高级的技巧与思想"><a href="#一些更加高级的技巧与思想" class="headerlink" title="一些更加高级的技巧与思想"></a>一些更加高级的技巧与思想</h2><p>&emsp;如果是以上的优化还是处于比较直观、容易理解范围内，那么下面涉及的优化可能就需要一定的CPU相关的知识了。</p><h3 id="cache机制的利用"><a href="#cache机制的利用" class="headerlink" title="cache机制的利用"></a>cache机制的利用</h3><h3 id="内嵌汇编-最终杀器"><a href="#内嵌汇编-最终杀器" class="headerlink" title="内嵌汇编(最终杀器)"></a>内嵌汇编(最终杀器)</h3><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://github.com/lzyrapx/Competitive-Programming-Docs/blob/master/%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9F%E5%8E%86%E5%B9%B4%E8%AE%BA%E6%96%87%E9%9B%86/%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9F2009%E8%AE%BA%E6%96%87%E9%9B%86/4.%E9%AA%86%E5%8F%AF%E5%BC%BA%E3%80%8A%E8%AE%BA%E7%A8%8B%E5%BA%8F%E5%BA%95%E5%B1%82%E4%BC%98%E5%8C%96%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%B9%E6%B3%95%E4%B8%8E%E6%8A%80%E5%B7%A7%E3%80%8B/%E8%AE%BA%E7%A8%8B%E5%BA%8F%E5%BA%95%E5%B1%82%E4%BC%98%E5%8C%96%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%B9%E6%B3%95%E4%B8%8E%E6%8A%80%E5%B7%A7.pdf">骆可强《论程序底层优化的一些方法与技巧》</a></li><li>骗分导论(OI) by 李博杰</li></ol><h2 id="未完待续……-咕咕咕，肝不动了"><a href="#未完待续……-咕咕咕，肝不动了" class="headerlink" title="未完待续……(咕咕咕，肝不动了)"></a>未完待续……(咕咕咕，肝不动了)</h2>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 基础知识 </category>
          
          <category> 优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
            <tag> 优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高精度模板(基于双模数NTT)</title>
      <link href="/2022/11/19/Bignumber/"/>
      <url>/2022/11/19/Bignumber/</url>
      
        <content type="html"><![CDATA[<p>由于作业要求，我需要写一个压位的高精度的模板，并且需要通过FFT / NTT对于乘法进行优化。</p><p>说实话，我是不太喜欢<del>(不会)</del>写这种又暴又难调的的模板的，这对我来说还是非常具有挑战的。</p><p>如果你还不会 FFT/NTT，不妨看看 <a href="https://oi-wiki.org/math/poly/ntt/">这个(from OIwiki)</a></p><p>本文将侧重于基于双模 NTT 的乘法是如何实现，对于其他的细节也会提到。</p><h2 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h2><p>由于我担心FFT压位会爆double精度(事实证明压到 $10^4$ 做 $10^{200000}$ 的乘法也不会炸精度，而且效率上暴打双模数NTT)，我选择了双模数 NTT + 压6位(每个单元上限 $10^6 - 1$)。</p><p>具体如下:<br>首先，设置了一个class NTT_base类来保护内部的静态数据(constexpr static)。</p><p>然后大整数类名为 class int2048 . 它继承了 std::vector &lt;ull&gt; 和 NTT_base 的所有数据。(我们约定using ull = unsigned long long).</p><h3 id="双模数-NTT-的分析"><a href="#双模数-NTT-的分析" class="headerlink" title="双模数 NTT 的分析"></a>双模数 NTT 的分析</h3><p>由于单模 NTT 能够允许的范围为 $ n * (base - 1)^2 &lt; mod $ ，$n$ 为压位后乘法结果的长度 (且必须向上取整到 $2 ^ k$ )。其中，模数 $mod$ 必须要小于 unsigned int 的范围，是因为中间计算的过程中会出现 $ (a \times b) $ % $ mod $的表达式，而$ a \times b $ 最多不能超unsigned long long 。因此，当 $ n = 10^5 $，$ base $ 只能选择为 100 ，这样几乎没有压位的效果 )。</p><p>回到 NTT 算法本身，其用于替代 FFT 是为了替代 FFT 中可能出现的 浮点精度丢失 以及 浮点计算慢 等问题。我们通过 NTT 得到某一位的值实际上是: 这个位置通过多项式乘法得到的一个值对mod取模。又因为得到的值在不压位的情况下一般是小于 mod 的，所以正确性得以保证。</p><p>抽象一下，就是假设仅仅通过多项式乘法，我们得到某一项乘出来的系数为 $z$，假设模数为 $M$ ，我们通过 NTT 得到的是同余方程 $z \equiv x \ (mod M)\ (x &lt; M)$的解 $x$ ，又因为 $z &lt; M$，所以我们得到的 $x$ 就是所求的 $z$。</p><p>如果采用两个模数，则通过如下同余方程组 :</p><script type="math/tex; mode=display">\begin{cases}z  \equiv x\ (mod M_1)\\z  \equiv y\ (mod M_2)\\\end{cases}</script><p>选取两个不同的质数 $M_1,M_2$ 作为 NTT 模数 ，只要 $gcd(M_1,M_2) = 1$，由中国剩余定理，我们可以通过两次 NTT 得到 x 和 y 来还原任意一个 $\ z &lt; M_1 \times M_2 $ 。</p><p>这样一来，我们可以使得可选的 z 的上限拓展到了 $M_1 \times M_2 - 1$，实测可以达到<br>所以根据双模 NTT 能够允许的范围为 $ n * (base - 1)^2 &lt; M_1 \times M_2 - 1 $ 即使 $base$ 选为 $10^6$ , $n$ 的上限也能达到 $ 2^{22} $，对大部分问题还是绰绰有余的。</p><h3 id="NTT-base的实现"><a href="#NTT-base的实现" class="headerlink" title="NTT_base的实现"></a>NTT_base的实现</h3><p>NTT_base声明了所有NTT相关的函数以及数据，都是静态储存 (相当于全局函数/变量，而且编译期确定)。</p><p>同时，为了防止用户自己定义一个NTT变量，我将其构造函数放在了 protected 里面，这样就可以避免用户直接使用 NTT_base 的变量，而只能通过继承来安全的访问NTT_base 的数据。其本质只是对于内部数据/函数的保护，防止被误用，确保安全性。</p><p>值得注意的是，对于编译期常数的除法和取余，编译器会展开优化为一系列更快的位运算。因此，我们需要实现两份 NTT 以及 fastPow(复制黏贴，仅仅模数不同)，这样相比传参数来决定 NTT 是采用 $M_1$ 还是 $M_2$，要快将近一倍(如下图,题目来自交大的<a href="https://acm.sjtu.edu.cn/OnlineJudge/problem?problem_id=1754">ACMOJ 1754</a> )。</p><p><img src="https://s2.loli.net/2023/01/28/ny568jCJkdmHpOu.png" alt="确实快了不少,当然还是打不过FFT"></p><p>最后是一个小优化:注意到了 NTT 中每次单位根的大小都是固定的(取决于 NTT 长度 $len$ 中 $len = 2^k$ 中的 $k$)，我们可以预处理这些值，一共就 2(INTT/NTT) <em> 2(两个模数) </em> 22(最大的k) 个数，故打表处理。逆元同理。</p><p>还有就是当数据量较小的时候，应该避免使用 NTT 而是使用暴力乘法或者分治递归实现，这个笔者暂时还没考虑好应该设置为多少。(如果您有测试结果与实现，欢迎在评论区留言awa)</p><p>不考虑 FFT 和 NTT 本身的时间差距，压相同位的情况下，双模 NTT 的理论常数应该是 FFT 的两倍</p><p>代码如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief NTT related data.</span></span><br><span class="line"><span class="comment"> * You can&#x27;t apply for an NTT_base object. </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NTT_base</span> &#123;</span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">NTT_base</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">uint64_t</span> <span class="title">fastPow0</span><span class="params">(<span class="type">uint64_t</span> base,<span class="type">uint64_t</span> pow)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">uint64_t</span> <span class="title">fastPow1</span><span class="params">(<span class="type">uint64_t</span> base,<span class="type">uint64_t</span> pow)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">NTT0</span><span class="params">(<span class="type">uint64_t</span> *A,<span class="type">uint32_t</span> len,<span class="type">bool</span> type)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">NTT1</span><span class="params">(<span class="type">uint64_t</span> *A,<span class="type">uint32_t</span> len,<span class="type">bool</span> type)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title">reverse</span><span class="params">(<span class="type">uint64_t</span> *A,<span class="type">uint32_t</span> *rev,<span class="type">uint32_t</span> len)</span></span>;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">inline</span> std::vector &lt;<span class="type">uint32_t</span>&gt; <span class="built_in">getRev</span>(<span class="type">uint32_t</span> len);</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">uint64_t</span> <span class="title">getMult</span><span class="params">(<span class="type">uint64_t</span> A0,<span class="type">uint64_t</span> A1,<span class="type">uint64_t</span> inv)</span></span>;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">static</span> <span class="type">uint64_t</span> mod[<span class="number">2</span>]  = &#123;<span class="number">2281701377</span>,<span class="number">3489660929</span>&#125;; <span class="comment">// mod number</span></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">static</span> <span class="type">uint64_t</span> lenb    = <span class="number">6</span>;   <span class="comment">// base len in decimal</span></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">static</span> <span class="type">uint64_t</span> base    = <span class="number">1e6</span>; <span class="comment">// base of int2048 = 10 ^ lenb</span></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">static</span> <span class="type">uint64_t</span> initLen = <span class="number">2</span>;    <span class="comment">// initial length reserved</span></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">static</span> <span class="type">uint64_t</span> MaxLen  = <span class="number">1</span> &lt;&lt; <span class="number">21</span>; <span class="comment">// Maximum possible NTT length</span></span><br><span class="line">    <span class="comment">// constexpr static uint64_t rate    = 3;    // compressing rate</span></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">static</span> <span class="type">uint64_t</span> NTTLen  = <span class="number">1e6</span>;  <span class="comment">// pow(NTTLen,rate) = base</span></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">static</span> <span class="type">uint64_t</span> BFLen   = <span class="number">1e9</span>;  <span class="comment">// Brute Force length</span></span><br><span class="line">    <span class="comment">// constexpr static uint64_t root[2][2] = &#123;     // root and inv root</span></span><br><span class="line">    <span class="comment">// 3,(mod[0] + 1) / 3,3,(mod[1] + 1) / 3</span></span><br><span class="line">    <span class="comment">// &#125;;  // common root</span></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">static</span> <span class="type">uint64_t</span> unit[lenb] = &#123; <span class="comment">// units below base</span></span><br><span class="line">        <span class="number">1</span>,</span><br><span class="line">        <span class="number">10</span>,</span><br><span class="line">        <span class="number">100</span>,</span><br><span class="line">        <span class="number">1000</span>,</span><br><span class="line">        <span class="number">10000</span>,</span><br><span class="line">        <span class="number">100000</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">static</span> <span class="type">uint64_t</span> root[<span class="number">2</span>][<span class="number">2</span>][<span class="number">22</span>]= &#123;</span><br><span class="line">        <span class="number">2281701376</span>,<span class="number">344250126</span>,<span class="number">483803410</span>,<span class="number">617790083</span>,<span class="number">2023592065</span>,</span><br><span class="line">        <span class="number">216937880</span>,<span class="number">123697435</span>,<span class="number">1639385633</span>,<span class="number">1301610063</span>,<span class="number">865646229</span>,</span><br><span class="line">        <span class="number">1780348903</span>,<span class="number">799681555</span>,<span class="number">977546242</span>,<span class="number">1286750706</span>,<span class="number">1294996786</span>,</span><br><span class="line">        <span class="number">2270548020</span>,<span class="number">451618310</span>,<span class="number">637539285</span>,<span class="number">231852688</span>,<span class="number">1783582410</span>,</span><br><span class="line">        <span class="number">1346120317</span>,<span class="number">1057547068</span>,</span><br><span class="line"></span><br><span class="line">        <span class="number">2281701376</span>,<span class="number">1937451251</span>,<span class="number">582229479</span>,<span class="number">1778233327</span>,<span class="number">996068929</span>,</span><br><span class="line">        <span class="number">533126167</span>,<span class="number">1540362740</span>,<span class="number">1845123106</span>,<span class="number">1922965124</span>,<span class="number">1184734049</span>,</span><br><span class="line">        <span class="number">369448383</span>,<span class="number">1732276489</span>,<span class="number">1444283332</span>,<span class="number">92283190</span>,<span class="number">2059450554</span>,</span><br><span class="line">        <span class="number">114788634</span>,<span class="number">1156211696</span>,<span class="number">2033086166</span>,<span class="number">1274602630</span>,<span class="number">1845241368</span>,</span><br><span class="line">        <span class="number">656109765</span>,<span class="number">1987373021</span>,</span><br><span class="line"></span><br><span class="line">        <span class="number">3489660928</span>,<span class="number">1841841630</span>,<span class="number">1054308003</span>,<span class="number">1513900834</span>,<span class="number">1424003439</span>,</span><br><span class="line">        <span class="number">3290428437</span>,<span class="number">2792923286</span>,<span class="number">424291397</span>,<span class="number">1938306374</span>,<span class="number">731827882</span>,</span><br><span class="line">        <span class="number">340708175</span>,<span class="number">1005229295</span>,<span class="number">3231347667</span>,<span class="number">962117947</span>,<span class="number">1030533309</span>,</span><br><span class="line">        <span class="number">725028937</span>,<span class="number">3369885469</span>,<span class="number">72934420</span>,<span class="number">758575992</span>,<span class="number">3373763992</span>,</span><br><span class="line">        <span class="number">1882435536</span>,<span class="number">1143890192</span>,</span><br><span class="line"></span><br><span class="line">        <span class="number">3489660928</span>,<span class="number">1647819299</span>,<span class="number">1761617041</span>,<span class="number">724177331</span>,<span class="number">38202934</span>,</span><br><span class="line">        <span class="number">2302762011</span>,<span class="number">917171561</span>,<span class="number">3348395406</span>,<span class="number">763600137</span>,<span class="number">382076615</span>,</span><br><span class="line">        <span class="number">417640332</span>,<span class="number">3318291862</span>,<span class="number">2451874772</span>,<span class="number">3398023446</span>,<span class="number">1583677827</span>,</span><br><span class="line">        <span class="number">997063351</span>,<span class="number">2673837393</span>,<span class="number">2327172879</span>,<span class="number">845347823</span>,<span class="number">1749721614</span>,</span><br><span class="line">        <span class="number">2180195085</span>,<span class="number">87513231</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief Least length for NTT.</span></span><br><span class="line"><span class="comment">     * Note that 2 * threshold * base should be less than 2 ^ 64. </span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">static</span> <span class="type">uint64_t</span> NTT_threshold = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="暂时先摸了"><a href="#暂时先摸了" class="headerlink" title="暂时先摸了"></a>暂时先摸了</h2>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 模拟 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈C++STL</title>
      <link href="/2022/10/23/STL/"/>
      <url>/2022/10/23/STL/</url>
      
        <content type="html"><![CDATA[<p><img src="https://oi-wiki.org/lang/csl/images/container1.png" alt="OIWIKI_STL"></p><p>图片来自 <a href="https://oi-wiki.org/lang/csl/container/">OIwiki</a>，有兴趣可以看看，讲的比我好多了Orz.<br>最近有亿点点忙,所以停更了一段时间。这次试着来讲讲 STL (大约是入门level)，你需要知道一些基本数据结构(队列，栈等等)作为前置知识。</p><h2 id="初步认识STL"><a href="#初步认识STL" class="headerlink" title="初步认识STL"></a>初步认识STL</h2><p>What is STL ?</p><p>STL 代表的是 Standard Template Library ， 是 C++ 的标准的模板库.</p><p><img src="https://s2.loli.net/2023/01/28/UxEwyFIe72suQpi.png" alt="来自Wikipedia"></p><p>由上述Wikipedia定义可见，STL中包含了大量的可用容器、算法、函数和迭代器。下面将会具体讨论。</p><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><h3 id="什么是容器-个人理解"><a href="#什么是容器-个人理解" class="headerlink" title="什么是容器?(个人理解)"></a>什么是容器?(个人理解)</h3><p>容器，顾名思义就是一种装载东西的器皿。在C++中就是一种模板类，用来按照一定的方法贮存、取出元素。</p><p>正确使用容器，可以非常有效地存储、管理数据。下面将大致介绍一些常见的容器。</p><h3 id="STL容器的共有的函数"><a href="#STL容器的共有的函数" class="headerlink" title="STL容器的共有的函数"></a>STL容器的共有的函数</h3><p>以下是大部分STL容器都提供的函数</p><p>size()  返回容器内元素的个数<br>empty() 返回这个容器是否为空<br>clear()  清空容器中存储的元素<br>swap()  和括号内的另一个容器交换内部元素<br>=  将一个容器的元素赋值到另外一个容器的元素<br>== 判断两个容器保存的元素是否相等<br>!= 判断两个容器保存的元素是否不相等<br>begin() 返回初始迭代器(指向的是第一个元素,详见后文)<br>end()   返回终点迭代器(指向的是最后一个元素后一个的元素,不可访问)<br>rbegin() 反向初始迭代器(即指向最后一个元素)<br>rend()   反向终点迭代器(即指向第一个元素前一个的元素,不可访问)</p><h3 id="std-string"><a href="#std-string" class="headerlink" title="std::string"></a>std::string</h3><p>具体内容参考 <a href="https://darksharpness.github.io/2022/09/13/String/string/#std-string">字符串基础</a>。</p><h3 id="std-vector"><a href="#std-vector" class="headerlink" title="std::vector"></a>std::vector</h3><p>加入头文件 #include &lt;vector&gt; 之后即可使用。</p><p>注意，其在命名空间std内，使用前需要加std::。你也可以直接在头文件中加 using namespace std; 或者 using std::vector.</p><p>简单来说，vector 类似于数组，内部数据连续地储存，但是其长度并不确定。其可以动态地改变长度，而且可以比较高效地在尾部添加/删除元素(这方面类似栈(stack))。</p><h4 id="vector-的常用功能"><a href="#vector-的常用功能" class="headerlink" title="vector 的常用功能"></a>vector 的常用功能</h4><p>我们可以用 vector &lt;value_type&gt; 来声明一个vector变量，其中value_type是你要存储的变量的类型，可以是基本数据类型，也可以是一个结构体或者类。</p><p>初始情况下，容器 vector为空。我们可以用 <strong>push_back()</strong> 函数来向一个 vector 尾部添加元素。这会使得 vector 的体积增加1。类似的，我们也可以通过 <strong>pop_back()</strong> 来清除最后一个元素，使得 vector 体积减少1。</p><p>而我们可以通过 <strong>size()</strong> 来获取这个vector中元素的个数，并且类似数组，我们可以用 [] (0-base) 进行下标访问。</p><p>如下演示</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line">vector &lt;<span class="type">int</span>&gt; vec; <span class="comment">// 定义</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="number">114</span>);</span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="number">514</span>);<span class="comment">// 尾部插入元素</span></span><br><span class="line">    vec.<span class="built_in">pop_back</span>();<span class="comment">// 去除最后一个元素</span></span><br><span class="line">    <span class="type">unsigned</span> siz = vec.<span class="built_in">size</span>();<span class="comment">// 获取 vec 元素个数</span></span><br><span class="line">    <span class="type">int</span> first_element = vec[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// vec[i] 获取 vec 第i + 1 个元素的值</span></span><br><span class="line">    <span class="comment">// (因为0-base) </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除此之外，vector 在初始化的过程中可以使用参数列表。</p><p>vector 初始化也可以使用数组、迭代器(见后文)通过指定首尾位置来确定，或者指定元素个数和值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 参数列表初始化</span></span><br><span class="line">vector &lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">4</span>&#125;;</span><br><span class="line">vector &lt;<span class="type">int</span>&gt; w &#123;<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用数组来初始化</span></span><br><span class="line"><span class="comment">// 两个参数分别为首地址和尾地址</span></span><br><span class="line"><span class="comment">// 初始化记录的是[首,尾)的元素</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> a[] = &#123;<span class="number">19</span>,<span class="number">19</span>,<span class="number">810</span>&#125;;</span><br><span class="line">vector &lt;<span class="type">int</span>&gt; <span class="built_in">u</span>(a,a+<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定大小的初始化</span></span><br><span class="line"><span class="comment">// 此时 vector 里面的元素都为默认值</span></span><br><span class="line"><span class="comment">// 例如 int 就是 0</span></span><br><span class="line">vector &lt;<span class="type">int</span>&gt; <span class="built_in">x</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定大小与初始值的初始化</span></span><br><span class="line"><span class="comment">// 下例中 y 里面有10 个 1</span></span><br><span class="line">vector &lt;<span class="type">int</span>&gt; <span class="built_in">y</span>(<span class="number">10</span>,<span class="number">1</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在访问 vector 内部的元素的过程中，除了像数组一样可以用下标进行访问，我们还可以用at()函数来访问指定位置，并且有越界检查(越界会抛出异常)。特别的，我们也可以用 <strong>front()</strong> 和 <strong>back()</strong> 来访问第一个/最后一个元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">vector &lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">vec[<span class="number">0</span>] = <span class="number">1</span>;          <span class="comment">// 最基础的下标访问,类似数组</span></span><br><span class="line">                     <span class="comment">// 注意数组越界问题</span></span><br><span class="line"><span class="type">int</span> tmp = vec.<span class="built_in">at</span>(<span class="number">2</span>); <span class="comment">// 一般情况下相当于 []</span></span><br><span class="line">vec.<span class="built_in">at</span>(<span class="number">0</span>) = <span class="number">1</span>;       <span class="comment">// at()也可作为左值被修改</span></span><br><span class="line">vec.<span class="built_in">front</span>() = <span class="number">4</span>;   </span><br><span class="line">vec.<span class="built_in">back</span>()  = <span class="number">5</span>;     <span class="comment">// front()/back() 同理 </span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="vector-的应用场景"><a href="#vector-的应用场景" class="headerlink" title="vector 的应用场景"></a>vector 的应用场景</h4><p>首先，vector 具有一个 stack 所需的所有的接口，所以它几乎可以在任何时候替代 stack。</p><p>其次，在面对不能确定长度的数组时，vector 就是一个强有力的工具。<strong>在均摊情况下</strong>，vector 向尾部插入一个元素的时间复杂度为 $O(1)$ ，访问指定位置的元素的时间复杂度是 严格 $O(1)$ ，因此我们可以简单用它来处理一些容易爆内存的问题，不用考虑内存分配的细节等等。</p><p>e.g : 用邻接表存图。对于一个 n 个节点的图你需要开一个空间为 $O(n ^ 2)$ 的二维数组,当 $n &gt; 10^4$ 时很容易爆内存MLE。这时候，我们可以用 vector 存图。对于每个节点，我们维护一个 vector，存储每个结点连向的其他结点的编号，这样我们就只需要大致与边数 $m$ 相同数量级 $O(m)$ 的内存空间。</p><p>e.g : 不定长度的数组。在程序运行的过程中，在很多情况下往往需要动态的开数组。此时，用 vector 就可以很方便的在局部开不固定长度的数组，不用担心内存分配问题。</p><h3 id="std-queue"><a href="#std-queue" class="headerlink" title="std::queue"></a>std::queue</h3><p>加入头文件 #include &lt;queue&gt; 后即可使用</p><p>注意，其在命名空间std内，使用前需要加std::。你也可以直接在头文件中加 using namespace std; 或者 using std::queue.</p><p>简单来说，queue就是一个队列，满足基本性质FIFO。具体是每次可以向队列尾部插入一个元素，并从头部访问/取出最早插入的元素，类似于排队。</p><p><img src="https://s2.loli.net/2023/01/28/IjYKN8Clny1ogum.png" alt="瞎画的"></p><p>如上图(画的是有点丑…),当前队伍为 {3,1,4}。你只能访问最前面的3，你也可以在尾部继续插入元素。如果我们取出头部元素3，那么下一个头部元素就是1。</p><h4 id="queue-的常用功能"><a href="#queue-的常用功能" class="headerlink" title="queue 的常用功能"></a>queue 的常用功能</h4><p>我们可以用 queue &lt;value_type&gt; 来声明一个 queue 变量，类似前面讲的vector(事实上，几乎所有stl容器皆是如此)。</p><p>queue的内置函数较少，故在此一次性列出，时间复杂度均为 $O(1)$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span> <span class="comment">// 头文件</span></span></span><br><span class="line"><span class="keyword">using</span> std::queue;</span><br><span class="line">queue &lt;<span class="type">int</span>&gt; q;   <span class="comment">// queue不能参数列表初始化</span></span><br><span class="line"></span><br><span class="line">q.<span class="built_in">front</span>() <span class="comment">// 返回queue的第一个元素</span></span><br><span class="line">q.<span class="built_in">back</span>()  <span class="comment">// 返回queue的最后一个元素</span></span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">1</span>) <span class="comment">// 往队尾插入元素</span></span><br><span class="line">q.<span class="built_in">pop</span>()   <span class="comment">// 弹出队首元素</span></span><br><span class="line">q.<span class="built_in">size</span>()  <span class="comment">// 返回队伍中元素个数</span></span><br><span class="line">q.<span class="built_in">empty</span>() <span class="comment">// 判断队伍是不是空</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="queue-的应用场景"><a href="#queue-的应用场景" class="headerlink" title="queue 的应用场景"></a>queue 的应用场景</h4><p>e.g 经典场景:bfs的实现。为了保证是一层层的访问遍历，需要用一个queue记录之后要访问的结点(或节点编号)，由于队列FIFO的性质，只有在遍历完了某一次的节点后才会再遍历下一层。</p><h3 id="std-map"><a href="#std-map" class="headerlink" title="std::map"></a>std::map</h3><p>加入头文件 #include &lt;map&gt; 后即可使用</p><p>注意，其在命名空间std内，使用前需要加std::。你也可以直接在头文件中加 using namespace std; 或者 using std::queue.</p><p>简单来说是一种映射的数据结构，其可以由一种类型作为键值(key)，每个键对应一个值(value)。</p><h4 id="map-的常用功能"><a href="#map-的常用功能" class="headerlink" title="map 的常用功能"></a>map 的常用功能</h4><p>我们可以用 map &lt;key_type,value_type&gt; 来声明一个变量。值得一提的是，对于map中的key_type，你必须提供 &lt; (小于号) 的比较方式，因为 map 内部是维护的是一颗<a href="https://baike.baidu.com/item/%E7%BA%A2%E9%BB%91%E6%A0%91/2413209">红黑树</a>，元素是从小到大的排列。(所以指针一般来说不能作为key_type，因为指针比较默认是基于指针本身的值(即地址的大小))</p><p>当然，你也可以自定义一个比较类 comp_class 来进行自定义的比较(该comp_class需重载()运算符，括号内可以接受两个key_type类来自定义比较)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::map;</span><br><span class="line"></span><br><span class="line">map &lt;<span class="type">int</span>,<span class="type">double</span>&gt; mp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">comp</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span> <span class="params">()</span><span class="params">(<span class="type">int</span> X,<span class="type">int</span> Y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> X &gt; Y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;<span class="comment">// 自定义比较类</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用了自定义比较方法的map</span></span><br><span class="line">map &lt;<span class="type">int</span>,<span class="type">double</span>,comp&gt; mp_custom;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>map 最基本的操作是 [] 运算符，[] 内是一个key_type类型的值，返回的是一个value_type的值。若括号里这个 key 不存在于 map 里，则返回的值是未初始化的value_type(例如 int 未初始就是0)</p><h2 id="咕咕咕"><a href="#咕咕咕" class="headerlink" title="咕咕咕"></a>咕咕咕</h2>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> STL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> C++ </tag>
            
            <tag> 基础知识 </tag>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>差分机の分析</title>
      <link href="/2022/09/28/difference/"/>
      <url>/2022/09/28/difference/</url>
      
        <content type="html"><![CDATA[<p>写在前面的:<br>本文含有大量公式，不一定能成功渲染，请见谅。<br>Top Image来自<a href="https://www.computerhistory.org/babbage/_media/bckgnd/babbage-header.jpg">这里</a><br><del>有空再补图</del></p><h2 id="差分机是啥-极简"><a href="#差分机是啥-极简" class="headerlink" title="差分机是啥?(极简)"></a>差分机是啥?(极简)</h2><p>差分机简易版本大致如下:<br>给定一些寄存器,可以看作类似数组a[N] (下标从1开始),这里假设N = 8，有八个寄存器a[1],a[2],a[3],a[4],a[5],a[6],a[7],a[8]。<br>对于第i个寄存器,每次操作使得a[i]加上上次操作后a[i-1]的值。特别的，我们认为a[0] = 0 ，所以第一个寄存器a[1]的值永远不变。</p><p>下列表格中，第一列编号表示操作次数，操作0次即为初始状态。我们取a[1]=1 ,a[5] = 3,a[6] = 2 , a[7] = 1加以演示</p><div class="table-container"><table><thead><tr><th></th><th>a[1]</th><th>a[2]</th><th>a[3]</th><th>a[4]</th><th>a[5]</th><th>a[6]</th><th>a[7]</th><th>a[8]</th></tr></thead><tbody><tr><td>0.</td><td>1</td><td>0</td><td>0</td><td>0</td><td>3</td><td>2</td><td>1</td><td>0</td></tr><tr><td>1.</td><td>1</td><td>1</td><td>0</td><td>0</td><td>3</td><td>5</td><td>3</td><td>1</td></tr><tr><td>2.</td><td>1</td><td>2</td><td>1</td><td>0</td><td>3</td><td>8</td><td>8</td><td>4</td></tr></tbody></table></div><p>附:一个简单的差分机网站 from SJTU <a href="https://acm.sjtu.edu.cn/simulator/difference_engine1.html">(点我传送)</a></p><h2 id="差分机有啥用"><a href="#差分机有啥用" class="headerlink" title="差分机有啥用?"></a>差分机有啥用?</h2><p>差分机原理十分简单，而它最大的作用就是用来快速多项式求出值。</p><p>考虑一个简单的函数 $ f(x) = x^2 $。</p><p><em>定义差分函数 :</em><br>$ f_0(x) = f(x) $ 且 $ f_n(x) = f_{n-1}(x+1) - f_{n-1}(x)$</p><p>我们对其二次差分 $f_1(x) = f(x+1) - f(x) = 2x+1$，而 $f_2(x) = f_1(x+1) - f_1(x) = 2$。可以发现，其二次差分的结果变为了常数，如果再进行更多次的差分，其得到的$ f_n(x)$必定为0。</p><p>那这和我们的差分机有啥关系呢？</p><p>我们把$f_0(0),f_1(0),f_2(0)$的值作为a[8],a[7],a[6]的初始值，然后进行运算，然后我们会发现，第n次操作后，a[8],a[7],a[6]的值便变成了$f_0(n),f_1(n),f_2(n)$的值。</p><div class="table-container"><table><thead><tr><th></th><th>a[5]</th><th>a[6]</th><th>a[7]</th><th>a[8]</th></tr></thead><tbody><tr><td>0.</td><td>0</td><td>2</td><td>1</td><td>0</td></tr><tr><td>1.</td><td>0</td><td>2</td><td>3</td><td>1</td></tr><tr><td>2.</td><td>0</td><td>2</td><td>5</td><td>4</td></tr><tr><td>3.</td><td>0</td><td>2</td><td>7</td><td>9</td></tr><tr><td>4.</td><td>0</td><td>2</td><td>9</td><td>16</td></tr><tr><td>5.</td><td>0</td><td>2</td><td>11</td><td>25</td></tr></tbody></table></div><p>事实上，任意的多项式都可以进行类似的差分操作。对一个最高n次的多项式，我们每次差分会让其最高次减一，因此在经过n次差分操作后，其n次差分函数只有0次,即为一个常数，所以其更高次的差分函数均为0函数。</p><p>因此，我们只需知道函数/数列 $f(n)$ 的所有次差分函数在0处的值，即可求出 $f(n)$ 的值。</p><h2 id="一些计算相关的问题"><a href="#一些计算相关的问题" class="headerlink" title="一些计算相关的问题"></a>一些计算相关的问题</h2><h3 id="一些小技巧与正确性证明"><a href="#一些小技巧与正确性证明" class="headerlink" title="一些小技巧与正确性证明"></a>一些小技巧与正确性证明</h3><p>定义 $ a_k = f_k(0) $</p><h4 id="性质0"><a href="#性质0" class="headerlink" title="性质0"></a>性质0</h4><p>$ f_k(n) =  \sum_{i = 0}^{n}(a_{i+k}*{n\choose i}) $</p><p>proof: 显然，对于不同的 $k$，$ f_k(n) $ 的形式应当一致，仅仅是求和中初始下标不同。所以我们只需对 $ k = 0 $的情况进行数学归纳即可。( 此时由定义，$f_0(n) = f(n)$ )<br>对于 $ n = 0 $，显然，$ f(n) = a_0$ 成立<br>假设对 $ n = m $ 成立，<br>此时，对于 $ n = m + 1 $，由定义有 $ f(m+1) = f(m) + f_1(m) $。<br>代入 $ f_k(n) =  \sum_{i = 0}^{n}(a_{i+k}*{n\choose i}) $ ，</p><script type="math/tex; mode=display">\begin{aligned}f(m + 1) & = \sum_{i = 0}^{m}(a_{i}*{m\choose i}) + \sum_{i = 0}^{m}(a_{i+1}*{m\choose i}) \\&= \sum_{i = 0}^{m+1} (a_{i} \ast ({m\choose i}+{m\choose i-1}))\end{aligned}</script><p>—————其中 $ {n\choose -1} = {n\choose n+1} = 0$。—————<br>因为 $ {n+1\choose i} = {n\choose i} + {n\choose i-1} $<br>因此，$ f(m + 1) = \sum_{i = 0}^{m+1} (a_i*{m+1\choose i}) $ ，即假设对 n = m + 1也成立。<br>由数学归纳法，对 $\forall n \in Z^{+}{\cup}\{0\}$，假设都成立<br>因此，性质0成立，</p><h4 id="性质1"><a href="#性质1" class="headerlink" title="性质1"></a>性质1</h4><p>$ a_k = \sum_{i = 0}^k ( f(i) \ast ( -1)^{k-i} \ast {k\choose i} ) $</p><p>proof: 类似的，假如将0替换为n，我们只需简单地把求和中的 $f(i)$ 替换为 $f(i+n)$ 即可<br>假设对 $k = m$ 已经成立，则对 $k = m + 1$<br>则</p><script type="math/tex; mode=display">\begin{aligned}f_{m+1}(0) & = f_m(1) - f_m(0) \\& = \sum_{i = 0}^k (f(i+1)*(-1)^{k-i} \ast {k\choose i} ) -\sum_{i = 0}^k (f(i)*(-1)^{k-i} *{k\choose i})\\& = \sum_{i = 0}^{k+1} (f(i) \ast (-1)^{k+1-i}*({k\choose i-1}+{k\choose i}))\end{aligned}</script><p>同理0，我们可以将后两个组合数合并。<br>因此，假设对 $ k = m + 1 $ 也成立。<br>由数学归纳法，对 $\forall n \in Z^{+}{\cup}\{0\}$，假设都成立<br>因此，性质1成立。</p><h3 id="性质0-1の运用"><a href="#性质0-1の运用" class="headerlink" title="性质0,1の运用"></a>性质0,1の运用</h3><p>将性质0结合计算器/计算机，可以很快地由原函数 $ f(n) $ 求出差分机中对应寄存器的初始值。即使你可能并不知道 $ f(n) $ 的解析式，你仍然可以接这个差分机来大致预测其之后的走向。</p><p>而有时计算题里面如果给定了每个寄存器的值，你也可以通过性质1快速求出一定精度下的 $ f(n) $ 的解析式。</p><p><del>说白了就是为了应付题目，挣分数的事，不寒掺。</del></p><h2 id="差分机二号"><a href="#差分机二号" class="headerlink" title="差分机二号"></a>差分机二号</h2><p>附注:<a href="https://www.computerhistory.org/babbage/" title="差分机二号">更准确的原理请点击跳转</a></p><p>目前的差分器看似已经十分高效了的，但其原型是用纯机械实现的。<br>我们考虑一次差分机操作，即将寄存器的值加到下一个寄存器，可以用C++代码表示:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> re[<span class="number">9</span>]; <span class="comment">//re[i]为第i个寄存器的值</span></span><br><span class="line"><span class="comment">//一次差分机操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">iteration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">8</span>; i &gt;= <span class="number">2</span>  ; --i) &#123;</span><br><span class="line">        re[i] = re[i] + re[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而，机械结构的加法并不是这么简单。其具体实现是靠齿轮的啮合，齿轮转过的齿数为齿轮的值。</p><p>设相邻的 齿轮a 和 齿轮b 的齿数分别为 x 和 y，因为ab啮合，所以a 和 b 转过的总齿数相同。</p><p>通过把 齿轮a 转动到0，即可实现齿轮b的值变为 x+y ，进而实现加法。</p><p>注意到在这个过程中，齿轮a的值丢失，所以睿智的巴贝奇先生又在两个寄存器间添加了中间齿轮，在齿轮转动的过程中和 齿轮b 保持同样的旋转，这样在 齿轮b 变为 x+y 后，该中间齿轮也会转过 x 齿。在完成加法后，我们只需让中间齿轮和已经被清0的齿轮a啮合，把中间齿轮转回 0 ，即可实现一次加法操作。</p><p>可以看出，在每次的加法操作中，需要同时占用相邻的两个齿轮(寄存器)，因此一次差分机操作其实需要7步操作，每步操作使相邻的两个寄存器进行加法，这样效率比较低。</p><p>因此，我们可以考虑并行计算，注意到加法只会占用相邻的两个寄存器，我们可以在第一步让寄存器 2n-1 加到 2n 同时操作，第二步让寄存器 2n 加到 2n+1 同时操作，这样就可以只用两步就完成了加法。</p><p>相比第一种做法，并行计算提升了寄存器的平均占用率(原先操作每步骤占用率为 2/8，而后面的操作占用率第一步为8/8 第二步为6/8)，加法操作的总数不变，但一步可以同时进行更多次加法，这样的效率提升是十分显著的，尤其对于机械结构。</p><p>具体实现可以看如下的表格:<br>我们先预处理成如下的阶梯阵</p><div class="table-container"><table><thead><tr><th></th><th>a[1]</th><th>a[2]</th><th>a[3]</th><th>a[4]</th><th>a[5]</th><th>a[6]</th><th>a[7]</th><th>a[8]</th></tr></thead><tbody><tr><td>0.</td><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>2</td><td>0</td></tr><tr><td>1.</td><td></td><td></td><td>1</td><td>1</td><td>1</td><td>1</td><td>2</td><td>2</td></tr><tr><td>2.</td><td></td><td></td><td></td><td></td><td>2</td><td>2</td><td>3</td><td>4</td></tr><tr><td>3.</td><td></td><td></td><td></td><td></td><td></td><td></td><td>4</td><td>7</td></tr></tbody></table></div><p>第一步后:</p><div class="table-container"><table><thead><tr><th></th><th>a[1]</th><th>a[2]</th><th>a[3]</th><th>a[4]</th><th>a[5]</th><th>a[6]</th><th>a[7]</th><th>a[8]</th></tr></thead><tbody><tr><td>0.</td><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>2</td><td>0</td></tr><tr><td>1.</td><td></td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>2</td><td>2</td></tr><tr><td>2.</td><td></td><td></td><td></td><td>2</td><td>2</td><td>2</td><td>3</td><td>4</td></tr><tr><td>3.</td><td></td><td></td><td></td><td></td><td></td><td>4</td><td>5</td><td>7</td></tr><tr><td>4.</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td>12</td></tr></tbody></table></div><p>第二步后:</p><div class="table-container"><table><thead><tr><th></th><th>a[1]</th><th>a[2]</th><th>a[3]</th><th>a[4]</th><th>a[5]</th><th>a[6]</th><th>a[7]</th><th>a[8]</th></tr></thead><tbody><tr><td>0.</td><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>2</td><td>0</td></tr><tr><td>1.</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>2</td><td>2</td></tr><tr><td>2.</td><td></td><td></td><td>1</td><td>2</td><td>2</td><td>2</td><td>3</td><td>4</td></tr><tr><td>3.</td><td></td><td></td><td></td><td></td><td>4</td><td>4</td><td>5</td><td>7</td></tr><tr><td>4.</td><td></td><td></td><td></td><td></td><td></td><td></td><td>9</td><td>12</td></tr></tbody></table></div><p>可以看出，该计算方式的确可以加速机械结构的运算过程。</p><h2 id="End"><a href="#End" class="headerlink" title="End"></a>End</h2><p>差分机简易版入门级介绍到此结束。可以看出，差分机的确是一个非常巧妙的机器，其诞生于19世纪早期，不仅巧妙借助齿轮实现了加法的计算，而且还利用了差分函数的性质来快速求出多项式函数的值。甚至对于某些非多项式函数，借助公式我们也能大致模拟其之后的走向。其在加法过程中还运用到了并行计算的思想，而这在计算机的雏形以及思想尚不存在的时代无疑是十分超前的。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
          <category> 作业 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 作业 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第39届全国中学生物理竞赛复赛の初体验</title>
      <link href="/2022/09/17/%E5%85%A8%E5%9B%BD%E4%B8%AD%E5%AD%A6%E7%94%9F%E7%89%A9%E7%90%86%E7%AB%9E%E8%B5%9B%E5%A4%8D%E8%B5%9B/"/>
      <url>/2022/09/17/%E5%85%A8%E5%9B%BD%E4%B8%AD%E5%AD%A6%E7%94%9F%E7%89%A9%E7%90%86%E7%AB%9E%E8%B5%9B%E5%A4%8D%E8%B5%9B/</url>
      
        <content type="html"><![CDATA[<h3 id="39届物竞の个人测评"><a href="#39届物竞の个人测评" class="headerlink" title="39届物竞の个人测评"></a>39届物竞の个人测评</h3><p>鄙人虽已是物竞退役选手，但仍然密切关注物竞。今年题目据说是 武汉大 出的，个人感觉计算量还是比较大的，而且题目长度整体较长，让人望而生畏。题目的思维难度方面我个人觉得反而是不如前几年的题目的，更多的是在于计算难度(比如求导讨论结果之类的，而且几乎没有数值代入计算的题目)，这对于本来计算就不太行的我更是雪上加霜。<br>具体测评与解析过几天再更新，具体题目和答案见<a href="https://mp.weixin.qq.com/s/vhnF2HYoxwg9UILMTLgHxQ">物理竞赛</a> 公众号的文章。</p><p>附 : 本人花3h多一点做的题目,欢迎与我讨论awa<br><strong>(字比较丑，可能给您留下心理阴影!)</strong></p><p><img src="https://raw.githubusercontent.com/DarkSharpness/Photos/main/Images/1.jpg" alt=""><br><img src="https://raw.githubusercontent.com/DarkSharpness/Photos/main/Images/2.jpg" alt=""><br><img src="https://raw.githubusercontent.com/DarkSharpness/Photos/main/Images/3.jpg" alt=""><br><img src="https://raw.githubusercontent.com/DarkSharpness/Photos/main/Images/4.jpg" alt=""><br><img src="https://raw.githubusercontent.com/DarkSharpness/Photos/main/Images/5.jpg" alt=""><br><img src="https://raw.githubusercontent.com/DarkSharpness/Photos/main/Images/6.jpg" alt=""><br><img src="https://raw.githubusercontent.com/DarkSharpness/Photos/main/Images/7.jpg" alt=""><br><img src="https://raw.githubusercontent.com/DarkSharpness/Photos/main/Images/8.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 物理 </category>
          
          <category> 竞赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 物理竞赛 </tag>
            
            <tag> 物理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串基本知识与约定</title>
      <link href="/2022/09/13/string/"/>
      <url>/2022/09/13/string/</url>
      
        <content type="html"><![CDATA[<h2 id="字符串基础"><a href="#字符串基础" class="headerlink" title="字符串基础"></a>字符串基础</h2><p>在阅读本文前请先了解字符，数组这些概念！</p><h3 id="一些定义与约定"><a href="#一些定义与约定" class="headerlink" title="一些定义与约定"></a>一些定义与约定</h3><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>字符串(string)是将一些字符按顺序排列而成的一个序列，字符总数称为字符串的长度，在C++中可以用双引号表示字符串。对于一个长度为n的字符串str，我们可以用下标索引str[i]在O(1)的时间内访问其第i+1个字符。对一个长度为n的字符串，我们可以下标索引访问str[i] 的 i 的范围为 0 ~ n-1。</p><ul><li>字符串str =  “abc” ，其中str[0] = ‘a’，str[2]=’c’，长度为3</li></ul><h4 id="子串"><a href="#子串" class="headerlink" title="子串"></a>子串</h4><p>对于一个长度为n的字符串str，我们由其中第 i , i+1 , … , j-1，j个字符构成的字符串称为str的子串。</p><p><strong><em>我们约定</em></strong> ：str[i ~ j] 和 str[i … j]为 由str[i]，str[i+1]，… ，str[j-1]，str[j]的构成子串。</p><ul><li>字符串str =  “abcdef” 其中str[1…3] = “bcd”，str[4 ~ 5] = “ef”</li></ul><h4 id="前后缀"><a href="#前后缀" class="headerlink" title="前后缀"></a><strong>前后缀</strong></h4><p>对于一个长度为n的字符串str，其子串str[0 … i]为前缀（子串），str[j … n-1]为后缀（子串）。</p><p>一般来说，前/后缀不能等于原字符串。</p><p><strong><em>我们约定</em></strong>：<br>Pre(str，i) = str[0 … i]<br>Suff(str , i) = str[n-1-i … n-1]</p><h4 id="字典序"><a href="#字典序" class="headerlink" title="字典序"></a>字典序</h4><p>类似字典中的排序，我们从小到大地枚举每一个字符，逐位比较(注意是按照ASCII的规则)，缺失的位置认为ASCII值为0（注意’0’的ASCII的值不是0而且空格’ ‘的ASCII值为32）。在第一个不同的位上，对应字符的ASCII值大的字符串字典序更大。</p><ul><li>“aa” &lt; “ab”</li><li>“cc” &lt; “cca”</li><li>“00” &lt; “0A” &lt; “0a”</li></ul><h3 id="储存方式"><a href="#储存方式" class="headerlink" title="储存方式"></a>储存方式</h3><p>一般来说，字符串有以下两种储存形式:char 数组（偶尔char *） 和  std::string(需要头文件string)。前者需要我们预先保留足够的空间（长度不小于字符总数），访问、输入输出较快。而后者会根据输入字符串长度自动申请内存，我们不用考虑其存储问题，且提供了许多的接口（即std::string提供的库函数），方便好用，但输入输出较慢，且所占空间稍多于前者。</p><h4 id="char数组"><a href="#char数组" class="headerlink" title="char数组"></a>char数组</h4><p>我们一般用 char str[N] 的形式申请，其中输入字符总量不能超过n。因为是数组，所以索引需要从0开始。输入输出如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">114514</span>;<span class="comment">//足够大即可</span></span><br><span class="line"><span class="type">char</span> str[N];</span><br><span class="line"><span class="type">char</span> str1[<span class="number">6</span>]=<span class="string">&quot;Hello&quot;</span>;<span class="comment">//注意!数组大小需要比字符总数多1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str); <span class="comment">//输入</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,str);<span class="comment">//输出</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了得到输入的字符串的长度，我们可以使用strlen(str)，需要 cstring 库。<strong>注意！</strong>该操作的时间复杂度为O(n)，所以我们一般用一个变量来记录strlen，避免多次调用strlen(str)带来的大量时间开销。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">114514</span>;<span class="comment">//足够大即可</span></span><br><span class="line"><span class="type">char</span> str[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str); <span class="comment">//输入</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,str);<span class="comment">//输出</span></span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(str);<span class="comment">//O(n)求出str长度</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="std-string"><a href="#std-string" class="headerlink" title="std::string"></a>std::string</h4><p>在输入输出数据量不大的时候，std::string是一个不错的选择，还提供了很多强大的功能，下面将在代码中列举一些常见的操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span><span class="comment">//输入输出要用到</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">string str;<span class="comment">//声明变量</span></span><br><span class="line">string str2;</span><br><span class="line"><span class="type">char</span> cstr[] = <span class="string">&quot;Hello&quot;</span>;<span class="comment">//char数组也可以这样开</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; str;         <span class="comment">//输入</span></span><br><span class="line">    cin &gt;&gt; str2;        <span class="comment">//输入</span></span><br><span class="line">    cout &lt;&lt; str &lt;&lt; endl;<span class="comment">//输出+换行</span></span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line">    str[x]              <span class="comment">//第x+1个字符</span></span><br><span class="line">    str.<span class="built_in">append</span>(str2);   <span class="comment">//在str后面加上一个str2</span></span><br><span class="line">    str.<span class="built_in">front</span>();        <span class="comment">//访问第一个字符</span></span><br><span class="line">    str.<span class="built_in">back</span>();         <span class="comment">//访问最后一个字符</span></span><br><span class="line">    str.<span class="built_in">clear</span>();        <span class="comment">//清空字符串</span></span><br><span class="line">    str.<span class="built_in">compare</span>(cstr);  <span class="comment">//和char数组的字符串比较字典序</span></span><br><span class="line">    str.<span class="built_in">size</span>();         <span class="comment">//返回字符串长度</span></span><br><span class="line">    str.<span class="built_in">length</span>();       <span class="comment">//返回字符串长度</span></span><br><span class="line">    str.<span class="built_in">substr</span>(x,y);    <span class="comment">//返回从str[x]开始,长度为y的子串</span></span><br><span class="line">    str = str + str2;   <span class="comment">//str2 加在str后面</span></span><br><span class="line">    str += str2;        <span class="comment">//str  加在str后面</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上是std::string中比较常用的一些函数，感兴趣的同学可以查看C++官方文档中关于std::string的<a href="https://cplusplus.com/reference/string/string/">文档</a>来了解更多相关的接口以及具体实现等细节，这里就不多说了。</p><h2 id="字符串进阶-个人建议"><a href="#字符串进阶-个人建议" class="headerlink" title="字符串进阶(个人建议)"></a>字符串进阶(个人建议)</h2><p>聪明的你已经学会了字符串的基础应用，下面我们将学习字符串的一些进阶小知识。由于以下建议局限于答主个人，不保证其高效性，不一定对OI有用，仅供参考。</p><h3 id="字符串的储存原理及运用"><a href="#字符串的储存原理及运用" class="headerlink" title="字符串的储存原理及运用"></a>字符串的储存原理及运用</h3><p>字符串的储存实际是在原有的字符上增加一个’\0’字符，其ASCII值为0，标志着字符串的终结。此外，一般文件的结尾会有EOF(End of File)，其ASCII值为-1。</p><p>知道其储存方式后，我们便可稍加运用，用char数组代替std::string避免低效的输入输出。</p><h4 id="用getchar-来读入字符串-数字"><a href="#用getchar-来读入字符串-数字" class="headerlink" title="用getchar()来读入字符串/数字"></a>用getchar()来读入字符串/数字</h4><p>getchar()是 iostream下面的一个函数。其可以读入单个字符，返回int类型的ASCII值，适用于需要将字符映射到整数的情况(例如不同的字母对应不同的值)。如果需要存储的char 数组中，需要将末尾字符后一个位置的字符的ASCII值改为0即可。读入过程需要注意些细节：当读入的不在给定字符范围内，一般是空格或者换行，则认为当前字符串读入完毕。同时，每行读入到换行 ‘\n’ 同样要停止。</p><p>具体运用 ：</p><ol><li>快速输入输出(快于scanf/printf,cin/cout;模板如下)</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//后面的函数内static变量相当于全局变量,可以稍稍提高效率</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//快速读入</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span>  tmp ;<span class="comment">//记录最终值</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span>  flag;<span class="comment">//符号</span></span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> ch  ;<span class="comment">//记录每次读入数字</span></span><br><span class="line">    flag = <span class="number">1</span>;  </span><br><span class="line">    tmp  = <span class="number">0</span>;  </span><br><span class="line">    ch   = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>) &#123;<span class="comment">//范围外就跳过</span></span><br><span class="line">        <span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>) flag = <span class="number">-1</span>; <span class="comment">//负数就反号</span></span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ch &gt;= <span class="string">&#x27;0&#x27;</span>&amp;&amp;ch &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;<span class="comment">//范围内就一直读入</span></span><br><span class="line">        tmp = tmp * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tmp*flag;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//快速输出</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!x) &#123;             <span class="comment">//0单独处理</span></span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> ch[<span class="number">10</span>];  <span class="comment">//缓冲区,记录每一位数字</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span>  cnt   ;  <span class="comment">//最高位置计数器</span></span><br><span class="line">    cnt = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; <span class="number">0</span>) <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>),x=-x;</span><br><span class="line">    <span class="keyword">while</span>(x) &#123;</span><br><span class="line">        ch[++cnt] = x % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(cnt) <span class="built_in">putchar</span>(ch[cnt--]);</span><br><span class="line">    <span class="built_in">putchar</span>(ch[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    x=<span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">write</span>(x);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="用char实现多个字符串读入"><a href="#用char实现多个字符串读入" class="headerlink" title="用char实现多个字符串读入"></a>用char实现多个字符串读入</h4><p>很多时候，我们面临着这样一个情景：字符总量巨大，我们明确知道它的上限，有很多组字符串要读入。然而，我们不想用IO(In/Out,指代输入输出)很慢的std::string,甚至有时候字符串组数也未知，用std::vector <code>&lt;std::string&gt;</code>则必然会占用大量空间。此时，我们应当考虑使用char*数组代替。<br><img src="https://s2.loli.net/2023/01/28/UrMbRutfoid4OBq.png" alt="Luogu5357"></p><p>具体实现可以用一个int类数组记录第i个字符串的起始位置记作int loc[N]，然后用逐个读入字符串，下一个字符串的起始位置为上一个字符串最后一个字符(除了’\0’)的位置+2。</p><p>(当然，你也可以直接关闭流同步)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">2e5</span> +<span class="number">2</span>;<span class="comment">//字符串总数</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e5</span> +<span class="number">2</span>;<span class="comment">//字符总量</span></span><br><span class="line"><span class="type">int</span> loc[M];</span><br><span class="line"><span class="type">char</span> ch[N + M];<span class="comment">//考虑每个串多一个字符&#x27;\0&#x27;</span></span><br><span class="line"><span class="type">int</span> tot; <span class="comment">// 字符串总数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 读入一个字符串</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">readstr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,ch + loc[++tot]);</span><br><span class="line">    loc[tot + <span class="number">1</span>] = loc[tot] + <span class="built_in">strlen</span>(ch + loc[tot]) + <span class="number">1</span>; <span class="comment">// 设定下一个开始的位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);<span class="comment">//读入总数</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,ch);<span class="comment">//第一个字符串读入</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) </span><br><span class="line">        <span class="built_in">readstr</span>();</span><br><span class="line">    <span class="comment">// 第i个字符串起始位置为:</span></span><br><span class="line">    <span class="comment">// ch + loc[i]</span></span><br><span class="line">    <span class="comment">// 结束位置为(该位置为&#x27;\0&#x27;)</span></span><br><span class="line">    <span class="comment">// ch + loc[i + 1] - 1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="想到了再补充吧"><a href="#想到了再补充吧" class="headerlink" title="想到了再补充吧"></a>想到了再补充吧</h2>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KMP算法</title>
      <link href="/2022/09/09/kmp/"/>
      <url>/2022/09/09/kmp/</url>
      
        <content type="html"><![CDATA[<h2 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h2><p>前置知识与记号约定：<a href="/2022/09/13/String/index/">字符串基本知识与约定</a></p><h3 id="题目-Luogu-3375"><a href="#题目-Luogu-3375" class="headerlink" title="题目(Luogu 3375)"></a>题目(<a href="https://www.luogu.com.cn/problem/P3375">Luogu 3375)</a></h3><p><img src="https://s2.loli.net/2023/01/28/iUjK4Ef7sGDzZCl.png" alt="Luogu3375"></p><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p>给定两个字符串s1,s2。记$s1[i$ ~ $j]$为s1的第i到j个字符构成的子串(例如:$s1$=”abcab”  $s1[0$ ~ $2]$ = “abc”)<br>设s1长度为$n$，s2长度为$m$，满足$n&gt;=m$</p><p><del>我们简单分析下数据来猜测复杂度，</del>数据总量 $n,m$ 达到了$1e6$的级别，说明该算法必须是O($nlogn$)且常数较小 或者 O($n)  的复杂度。</p><p>考虑最朴素的暴力做法:枚举s1中每一个位置 i 作为起始位置，然后将对应s1子串$s1[i $ ~ $i+m-1] $与 s2 逐字符比较。<br>此时 i 枚举的范围为$[0,n-m]$，单次比较时间复杂度为O($m$)，所以整体时间复杂度为O($n*m$)，这样明显不能通过数据。</p><h2 id="Hash算法巧解简化版本"><a href="#Hash算法巧解简化版本" class="headerlink" title="*Hash算法巧解简化版本"></a>*Hash算法巧解简化版本</h2><p>为了便于理解，我们先简化题目，先不考虑”border”。</p><p>简化版本 : 求出和 s2 相等的 s1 的子串 的起始位置。<br>极简主义 : 求出 s1 中 s2 出现的位置。</p><p>既然暴力无法解决，我们应当考虑一些优化。通过字符串Hash优化，我们可以把单次比较的时间复杂度降低到O(1) (虽然有概率错误)</p><p>字符串Hash是把字符串看作一个 B 进制的数字，再对一个数取模，将一个较大的值域范围 映射 到一个小的值域范围里面。</p><h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p>设字符串str长度为n，记$f(str)$ = $\sum_{t=0}^{n-1} str[t] * B^{n-1-t} $ ，表示str的B进制数大小 。</p><p>这样，我们成功将字符串通过B进制与一个数对应，且该数仅对应唯一一个字符串str。同理，对于str的子串$str[i  $ ~ $j]$，其本身对应的B进制数的大小为$\sum_{t=i}^{j} str[t] * B^{n-t}$。这样，对于两个长度相等的字符串，判断其相等可以转化为判断其 $f$ 函数是否相等。</p><p>可以看出，对于str的长度为i的前缀子串$str[0$ ~ $i]$，$f(str[0 $ ~ $i])$可以由递推求出，而$f(str[i $ ~ $j])$ = $f(str[0 $ ~ $j])$ - $f(str[0 $ ~ ${i-1}])*B^{j-i+1}$ 求出，我们只需要O(1)的预处理就可以快速得到子串$str[i$ ~ $j]$的 $f$ 函数。但其值往往过大超出了long long范围不易表示和计算，因此我们通过取模，我们可以把较大的值域映射到一个更小的值域内，再比较判断相等。将f对M取余，得到$Hash(str) = f(str) mod M$。</p><p>然而值域缩小带来的是可能出现两个不同的字符串Hash函数相同，即Hash碰撞。在均匀分布的情况下(一般取B和M互质)，Hash碰撞的概率为$1/M$。为了减少Hash碰撞的概率，我们可以多次取余来验证字符串是否相等，进而减少Hash碰撞概率。</p><p>下面是演示代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;<span class="comment">//视题目而定</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> Hash[N];<span class="comment">//Hash[i]为str[0~i-1]的Hash值</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> base[N];<span class="comment">//base[i]为B的i次幂对M取mod</span></span><br><span class="line"><span class="comment">//预处理出str的Hash值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">prework</span><span class="params">(<span class="type">const</span> string&amp; str,</span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="type">long</span> <span class="type">long</span> B,</span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="type">long</span> <span class="type">long</span> M)</span> </span>&#123;</span><br><span class="line">    Hash[<span class="number">0</span>] = (str[<span class="number">0</span>]-<span class="string">&#x27;A&#x27;</span>) % M; <span class="comment">//本题中只有大写字母,所以这么处理</span></span><br><span class="line">    base[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//一般来说 str[0] &lt;= B &lt; M 不用 %M </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i = <span class="number">1</span> ; i &lt; str.<span class="built_in">length</span>(); ++i) &#123;</span><br><span class="line">        base[i] = (base[i<span class="number">-1</span>] * B) % M;</span><br><span class="line">        Hash[i] = (Hash[i<span class="number">-1</span>] * B + str[i<span class="number">-1</span>]) % M; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//求出str[l~r]的Hash值</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">getHash</span><span class="params">(<span class="type">const</span> string&amp; str,</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">int</span> l,<span class="type">int</span> r,</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> M)</span></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">long</span> <span class="type">long</span> tmp;<span class="comment">//该变量只会被声明一次</span></span><br><span class="line">                         <span class="comment">//类似全局变量 </span></span><br><span class="line">    tmp = Hash[r]-Hash[l<span class="number">-1</span>]*base[r-l+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> tmp &gt;= <span class="number">0</span> ?</span><br><span class="line">           tmp % M : (tmp % M) + M;</span><br><span class="line">    <span class="comment">//相当于if结构，?前表达式成立则返回冒号左，否则返回右</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        补充知识: C++ 负数取mod结果 为负</span></span><br><span class="line"><span class="comment">        例如 5 % 3 = 2</span></span><br><span class="line"><span class="comment">            -5 % 3 = -2;</span></span><br><span class="line"><span class="comment">        所以为防止出问题，如此处理</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="亿些细节"><a href="#亿些细节" class="headerlink" title="亿些细节"></a>亿些细节</h3><p>一般来说,B取略大于字符值域范围质数。本题中字符为大写字母，值域为26。本题中不妨取 $B = 29$。一般情况下字符(无限制)值域为128，此时可以取 $B = 131$。</p><p>而常见的mod数会选取int范围内的较大质数，常见的有 $1e9+7,1e9+9,998244353$。特别地，我们可以利用unsigned long long的自然溢出来避免低效的取mod运算(其慢于自然溢出)，只需把上面代码中的Hash和base改为unsigned long long类型，并且不再对M取mod即可。</p><p><del>为了避免常见大质数被毒瘤出题人卡Hash或者运气不好哈希碰撞</del>，这里推荐使用多次Hash组合加以判断，或者使用其他的大质数(例如1090000361,1060000037)。</p><h3 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h3><p>Hash算法的确可以优异地求解本题的简化版本，只有 O($n+m$) 的时间复杂度。</p><p>然而，我们回到题目本身，其还要求求解s2每个前缀的最长”border”。根据题意，”border”是指对于一个长度为l的字符串$str$，其前缀子串$str[0$ ~ $j] $ $(0 &lt;= j &lt; l-1)$，该子串满足$str[0$ ~ $j]$ = $str[i-j$ ~ $i]$而题目要求的是求出每个前缀子串最长的 “border” 的长度。此时，字符串Hash就无能为力了。</p><h2 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h2><p>为了解决这一问题，K(kan)M(mao)P(pian)算法诞生了。其由Knuth，Morris，Pratt三人发明，可以有效地解决上述问题。</p><h3 id="核心思想——维护nxt数组"><a href="#核心思想——维护nxt数组" class="headerlink" title="核心思想——维护nxt数组"></a>核心思想——维护nxt数组</h3><p>KMP的精髓在于其next数组。对于s2，我们记录一个next数组$nxt[i]$ $(-1 &lt;=nxt[i]&lt;= i-1 )$，$nxt[i]$ 表示最大的满足$s2[0$ ~ $nxt[i]]$ = $s2[i-nxt[i]$ ~ $i]$，即上面所说的前缀子串$s2[0$ ~ $i-1] $的最长的”border”的长度。<strong><em>例如</em></strong> : 字符串”ABCABCDA”，其$nxt[4] = 1$(因为”ABCAB”中前缀”AB”=后缀”AB”，且没有更长的满足的了)，同理$nxt[7] = 0$，$nxt[6] = -1$(因为”ABCABCD”不存在前缀子串等于后缀子串，所以$nxt$值为$-1$)。</p><h4 id="我们应该如何维护nxt-i-呢？"><a href="#我们应该如何维护nxt-i-呢？" class="headerlink" title="我们应该如何维护nxt[i]呢？"></a><strong>我们应该如何维护nxt[i]呢？</strong></h4><p>如果暴力维护的话，对于s2每一个子串 $s2[0$ ~ $i ] $ $ (0&lt;=i&lt;=m-1)$，需要枚举前缀子串的位置 $ j$ $(0 &lt;=j&lt;= i-1)$，比较 s2 的每个子串$s2[0$ ~ $j]$和$s2[i-j$ ~ $i]$是否相等。即使运用了字符串Hash能在O($1$)的时间内进行比较，处理出整个$nxt$数组还是O($m^2$)的时间复杂度。</p><p>我们<del>仔细观察(百度百科)</del>，发现nxt[i]其实可以递推求解：首先我们可以发现，若$s2[0$ ~ $j]$ = $s2[i-j$ ~ $i]$，那么必然有$s2[0$ ~ $j-1]$ = $s2[i-1-j+1$ ~ $i-1]$。可以看出，从$i-1$ 到$ i$，若$nxt[i] &gt;0$，则 $str[0$ ~ $i]$ 的最长”border”子串必然是由 $s2[0$ ~ $i-1]$ 的一个”border”加上str[i]得到。<strong><em>例如</em></strong>：字符串str = “CABCCABCA”，其$nxt[7] = 2$，而对于$i = 8$ , 枚举$str[0$ ~ $7]$的每个”border”：”CABC” “C”，发现不存在前缀子串”CABC”+”A”，但是存在 “C”+”A”=”CA”，所以$nxt[8] = 1$。因此，我们只需验证$s2[0$ ~ $i-1]$的每个前缀子串”border” 后一位是否等于$s2[i]$，即可求出$nxt[i]$。</p><p><strong>我们如何枚举$s2[0$ ~ $i]$的所有”border”呢？</strong></p><p>先说结论：$s2[0$ ~ $i]$所有”border”的长度由长到短依次是 : $nxt[i] , nxt[nxt[i]] , nxt[nxt[nxt[i]]] …… ,-1$。</p><p>首先$s2[0$ ~ $nxt[i]]$定义为i的最长border很好理解，<strong><em>下证 :</em></strong> 若$nxt[i]!=-1$，则不存在$nxt[nxt[i]] &lt; j &lt; nxt[i] $  使得 $s2[0$ ~ $j]$ 为 $s2[0$ ~ $i]$ 的一个”border”。</p><p><strong><em>证明</em></strong>：由题意，此时，$ s2[0$ ~ $nxt[i]]$ = $s2[i-nxt[i]$ ~ $i] $ ，且 $s2[0$ ~ $j]$ = $s2[i-j$ ~ $i]$，所以$s2[0$ ~ $j]$ =  $s2[i-j$ ~ $i]$ = $s2[i-j-(i-nxt[i])$ ~ $i-(i-nxt[i])]$ = $s2[nxt[i]-j$ ~ $nxt[i]]$。此时由定义，$nxt[nxt[i]] = j$ ，与$ j &gt; nxt[nxt[i]]$ 矛盾。</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> nxt[N];</span><br><span class="line"><span class="type">char</span> s1[N];</span><br><span class="line"><span class="type">char</span> s2[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">//O(m)预处理nxt数组</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">prework</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">-1</span>;</span><br><span class="line">    nxt[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(s2);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; len; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span>(j!=<span class="number">-1</span> &amp;&amp; s2[i] != s2[j+<span class="number">1</span>]) j = nxt[j];</span><br><span class="line">        <span class="comment">//这一步对应的是由长到短枚举s2[0~i-1]的border</span></span><br><span class="line">        <span class="comment">//第i次循环开始前,j=nxt[i-1]均成立</span></span><br><span class="line">        <span class="comment">//若匹配不成功,则j = nxt[j]尝试匹配一个最长的border</span></span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span>(s2[i] == s2[j+<span class="number">1</span>]) ++j;</span><br><span class="line">        <span class="comment">//如果匹配成功而跳出循环,此时s2[0~i]最长border就是j+1</span></span><br><span class="line">        <span class="comment">//反之,说明这样的border不存在,因此j=-1不加</span></span><br><span class="line">  </span><br><span class="line">        nxt[i] = j;<span class="comment">//此时nxt = j</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度证明"><a href="#复杂度证明" class="headerlink" title="复杂度证明"></a>复杂度证明</h3><p>看了代码,你可能觉得for循环中嵌套了一个while,这不是要 $O(m^2)$ 吗?<br><del>你先别急</del>。我们考虑while中操作的对象$j$，其初始值为-1，在每次while循环中至少减少1（显然$nxt[j] &lt; j$），最多减少到-1。而在一次for循环中，$j$最多增加1$($++$j$)。因此，在整个过程中，$j$在while循环中减小操作的次数不会多于++$j$操作的次数，而++$j$至多$m-1$次，所以执行while循环中的总次数小于$2*(m-1)$，因此这个预处理prework的时间复杂度为O($m$)级别。</p><h3 id="求解出现位置"><a href="#求解出现位置" class="headerlink" title="求解出现位置"></a>求解出现位置</h3><p>该操作类似求解nxt的过程，只需将prework中的if和while的判断改为 $s1[i] != s2[j+1]$即可。同时，若此时$j$达到了$s2$的长度$m$，那么此时$i$为$s2$在$s1$中出现的一个子串的末尾位置，可以通过计算输出其头部位置，并且令 $j = nxt[j]$ 继续循环匹配寻找下一个位置。</p><p>类似地，我们可以证明该操作时间复杂度为O($n$)，所以该算法整体的时间复杂度为O($n+m$)，十分高效。</p><h2 id="附：AC代码"><a href="#附：AC代码" class="headerlink" title="附：AC代码"></a>附：AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> nxt[N];</span><br><span class="line"><span class="type">char</span> s1[N];</span><br><span class="line"><span class="type">char</span> s2[N];</span><br><span class="line"><span class="type">int</span> len1,len2;</span><br><span class="line"></span><br><span class="line"><span class="comment">//O(m)预处理nxt数组</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">prework</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">-1</span>;</span><br><span class="line">    nxt[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; len2; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span>(j!=<span class="number">-1</span> &amp;&amp; s2[i] != s2[j+<span class="number">1</span>]) j = nxt[j];</span><br><span class="line">        <span class="comment">//这一步对应的是由长到短枚举s2[0~i-1]的border</span></span><br><span class="line">        <span class="comment">//第i次循环开始前,j=nxt[i-1]均成立</span></span><br><span class="line">        <span class="comment">//若匹配不成功,则j = nxt[j]尝试匹配一个最长的border</span></span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span>(s2[i] == s2[j+<span class="number">1</span>]) ++j;</span><br><span class="line">        <span class="comment">//如果匹配成功而跳出循环,此时s2[0~i]最长border就是j+1</span></span><br><span class="line">        <span class="comment">//反之,说明这样的border不存在,因此j=-1不加</span></span><br><span class="line">  </span><br><span class="line">        nxt[i] = j;<span class="comment">//此时nxt = j</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//O(n)处理出位置</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len1; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span>(j!=<span class="number">-1</span> &amp;&amp; s1[i] != s2[j+<span class="number">1</span>]) j = nxt[j];</span><br><span class="line">        <span class="comment">//这一步对应的是由长到短枚举s1[0~i-1]的border</span></span><br><span class="line">        <span class="comment">//第i次循环开始前,j=nxt[i-1]均成立</span></span><br><span class="line">        <span class="comment">//若匹配不成功,则j = nxt[j]尝试匹配一个最长的border</span></span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span>(s1[i] == s2[j+<span class="number">1</span>]) ++j;</span><br><span class="line">        <span class="comment">//如果匹配成功而跳出循环,此时s1[0~i]最长border就是j+1</span></span><br><span class="line">        <span class="comment">//反之,说明这样的border不存在,因此j=-1不加</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(j == len2<span class="number">-1</span>) &#123;<span class="comment">//说明已经匹配成功了一个子串</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i-len2+<span class="number">2</span>);</span><br><span class="line">            j = nxt[j]; <span class="comment">//跳到nxt继续下一次的匹配</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printnxt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len2 ;++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,nxt[i]+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s1);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s2);</span><br><span class="line">    <span class="comment">//注意,strlen是O(n)时间</span></span><br><span class="line">    <span class="comment">//所以循环中必须要用 i &lt; len1 而非 i &lt; strlen(s1)</span></span><br><span class="line">    len1 = <span class="built_in">strlen</span>(s1);</span><br><span class="line">    len2 = <span class="built_in">strlen</span>(s2);</span><br><span class="line">    <span class="built_in">prework</span>();</span><br><span class="line">    <span class="built_in">work</span>();</span><br><span class="line">    <span class="built_in">printnxt</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 字符串 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> KMP </tag>
            
            <tag> 字符串Hash </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【--置顶--】我的第一个Blog</title>
      <link href="/1919/08/10/firstBLOG/"/>
      <url>/1919/08/10/firstBLOG/</url>
      
        <content type="html"><![CDATA[<h3 id="如果你能看到这篇文章，那么我的博客已经顺利建立。"><a href="#如果你能看到这篇文章，那么我的博客已经顺利建立。" class="headerlink" title="如果你能看到这篇文章，那么我的博客已经顺利建立。"></a>如果你能看到这篇文章，那么我的博客已经顺利建立。</h3><p>&emsp;本博客基于<a href="https://hexo.io/zh-cn/index.html">Hexo</a>，运用了 <a href="https://butterfly.js.org/">butterfly主题</a> 进行美化。由于作者本人对前端不太了解，在博客中可能出现各种奇怪的bug，也有许多页面可能尚未实装 <del>(例如评论系统)</del> ，如遇到问题欢迎向我汇报，鄙人将不胜感激。</p><h3 id="注意-由于图床是SMMS，国内加载可能比较缓慢，请耐心等待orz。-推荐使用加速器-VPN"><a href="#注意-由于图床是SMMS，国内加载可能比较缓慢，请耐心等待orz。-推荐使用加速器-VPN" class="headerlink" title="注意:由于图床是SMMS，国内加载可能比较缓慢，请耐心等待orz。(推荐使用加速器/VPN)"></a><strong>注意:由于图床是SMMS，国内加载可能比较缓慢，请耐心等待orz。(推荐使用加速器/VPN)</strong></h3><p>&emsp;该博客以后主要将用于记录我学过的一些知识，也欢迎各位来与我交流切磋，共同进步。</p><p>&emsp;我尽量做到能<del>周更</del>月更(？反正也没人看)，尽量把每个问题都讲的透彻，方便大家能更好的理解，也有助于我自己更深入了解每个问题。我会尽力做到图文并茂，结合一定的代码。</p><p>&emsp;<del>由于”Dark”Sharpness的加成，本blog将强制使用深色主题，请不要尝试通过 F12 修改data-theme 为 light，那会看起来非常丑陋 (其实是我懒得做light/dark两种不同的css)</del>。现在已经支持浅色模式了，切换按钮在右下角，默认是跟随系统偏好 <del>,但是”Dark”Sharpness还是推荐你用dark</del>。</p><p>&emsp;以后更新日志写在”关于”页面。</p><p><strong>关于这个blog，其中非作者原创的二次元图片来自Pixiv/Seiga/Twitter，<a href="https://github.com/DarkSharpness/Photos/">图床</a>  标明了图片出处。如果实在找不到可以通过 <a href="https://saucenao.com/">https://saucenao.com/</a>  找到图片出处。具体请以原作者要求为准。其他非原创图片会标明引用链接。如侵权将立即删除。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
