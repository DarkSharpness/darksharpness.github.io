<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Effective Modern C++ | DarkSharpness's Dungeon</title><meta name="author" content="DarkSharpness"><meta name="copyright" content="DarkSharpness"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="被人拉着去讲 Modern C++ 了, 故作此文.">
<meta property="og:type" content="article">
<meta property="og:title" content="Effective Modern C++">
<meta property="og:url" content="http://darksharpness.github.io/cppModern/index.html">
<meta property="og:site_name" content="DarkSharpness&#39;s Dungeon">
<meta property="og:description" content="被人拉着去讲 Modern C++ 了, 故作此文.">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s3.bmp.ovh/imgs/2025/04/07/52e46b1c151e1b77.jpg">
<meta property="article:published_time" content="2025-04-07T01:42:39.000Z">
<meta property="article:modified_time" content="2025-04-14T18:38:14.498Z">
<meta property="article:author" content="DarkSharpness">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="基础知识">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s3.bmp.ovh/imgs/2025/04/07/52e46b1c151e1b77.jpg"><link rel="shortcut icon" href="https://s2.loli.net/2023/01/28/SnEi2v9sdczUuyG.png"><link rel="canonical" href="http://darksharpness.github.io/cppModern/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')
          
          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":1000,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isAnchor: true,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Effective Modern C++',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><link rel="stylesheet" href="/css/user.css"><link rel="stylesheet" href="/css/font.css"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="DarkSharpness's Dungeon" type="application/atom+xml">
</head><body><div id="web_bg" style="background: black;"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2023/01/28/SnEi2v9sdczUuyG.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">36</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">24</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">25</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 文章</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-ellipsis-h"></i><span> 杂物</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/photo/"><i class="fa-fw fas fa-image"></i><span> 图床</span></a></li><li><a class="site-page child" href="/diary/"><i class="fa-fw fas fa-book"></i><span> 日记</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://s3.bmp.ovh/imgs/2025/04/07/52e46b1c151e1b77.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2023/01/28/SnEi2v9sdczUuyG.png" alt="Logo"><span class="site-name">DarkSharpness's Dungeon</span></a><a class="nav-page-title" href="/"><span class="site-name">Effective Modern C++</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 文章</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-ellipsis-h"></i><span> 杂物</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/photo/"><i class="fa-fw fas fa-image"></i><span> 图床</span></a></li><li><a class="site-page child" href="/diary/"><i class="fa-fw fas fa-book"></i><span> 日记</span></a></li></ul></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Effective Modern C++</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-04-07T01:42:39.000Z" title="发表于 2025-04-07 09:42:39">2025-04-07</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-04-14T18:38:14.498Z" title="更新于 2025-04-15 02:38:14">2025-04-15</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/C/">C++</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/C/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">基础知识</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">14k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>53分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>难绷的被下一届的同学拉去给下下届讲 Modern C++ (不过笔者咕咕了). 想了半天, 最后还是决定讲讲 modern effective C++, 也算是笔者的启蒙读本了… 那也是 23 年春节的回忆, 转眼就过去两年了, 这两年笔者又学了些什么呢…</p>
<p>anyway, 不说废话了, 管理每小节开头给出所有用到的 <code>cppreference</code> 或者其他相关链接.</p>
<p>一些笔者平时看的链接: <a target="_blank" rel="noopener" href="https://en.cppreference.com/">cppreference</a>, <a target="_blank" rel="noopener" href="https://www.rust-lang.org/">rust-lang</a>, <a target="_blank" rel="noopener" href="https://wanghenshui.github.io/cppweeklynews/">cppweekly 群友版</a></p>
<p>笔者写 C++ 的核心要义就这些:</p>
<ol>
<li>best effort 尽力优化性能, 但是不要试图认为自己比编译器聪明. 养成习惯就是随手的事情了.</li>
<li>做好抽象和封装, 把一些内部的逻辑/可能是不安全的操作封装起来, 对外只暴露必要的接口 API, 不要留任何可能带来问题的后门, 这些都是给自己埋雷…</li>
<li>尽量做好解耦, 每个模块只干自己的事情. 最好的办法就是模块内的变量/函数不要对外公开, 多分函数/作用域尽量减少变量名泄露的到处都是, 多用 lambda 函数且只捕获需要的.</li>
<li>做好防御式编程, 可以开一个只在 debug 模式验证的宏, 做好边界检查.</li>
<li><del>永远用最新的 C++ 标准</del></li>
</ol>
<h2 id="从值类型到类型推导"><a href="#从值类型到类型推导" class="headerlink" title="从值类型到类型推导"></a>从值类型到类型推导</h2><p>参考内容 <a target="_blank" rel="noopener" href="https://cntransgroup.github.io/EffectiveModernCppChinese/1.DeducingTypes/item1.html">Effective Modern C++</a> Item 1, 23, 24. 虽然本文基本都是笔者口胡.</p>
<h3 id="左值和右值"><a href="#左值和右值" class="headerlink" title="左值和右值"></a>左值和右值</h3><p><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/value_category">Value Category</a></p>
<blockquote>
<p>Remark: 请牢记: C++ 移动在语义希望达成的是, 所有权的转移. 推荐读者在实践中, 要么是 fallback 到 copy, 要么就是移走资源.</p>
</blockquote>
<p>学完程序设计课之后, 大部分人都知道了 C++11 出了左值和右值这个东西, 但大概率是没有分太清楚的. 这里会简单介绍一下.</p>
<p>首先, 笔者假定读者能区分一个表达式的返回类型是不是值类型, 比如字面量 (除了字符串), 整数加减法 <code>a + b</code>, 或者返回类型是不含引用 <code>&amp;</code> 的函数, 又或者是 <code>static_cast</code> 为值类型, 这些表达式返回的一定是值类型.</p>
<p>区分不同的值类型, 一个最简单的规则是, <strong>有名字的东西</strong>一定是左值引用 <code>lvalue</code>, <code>std::move</code> 几乎必须作用于一个有名字的变量, 返回的是右值引用 <code>xvalue</code>, 而其他的返回值的表达式, 返回的是纯右值 <code>prvalue</code>, 函数结果则完全视其返回类型. 我们一般把后两者统称 <code>rvalue</code>, 前两者统称 <code>glvalue</code>. 这三个东西有什么区别呢? 如果你学过 rust, 你就知道有一个概念叫做生命周期, 而这里可以用生命周期来不严谨的解释一下: 对于 <code>lvalue</code> 和 <code>xvalue</code>, 他们都不涉及生命周期的相关的事情, 但对于 <code>prvalue</code>, 在整个表达式被执行结束之后, 它返回的值类型需要被析构.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> &amp;<span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> &amp;&amp;y)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">int</span>(x); <span class="comment">// as prvalue</span></span><br><span class="line">    x;      <span class="comment">// as lvalue</span></span><br><span class="line">    <span class="built_in">func</span>(); <span class="comment">// as lvalue</span></span><br><span class="line">    <span class="built_in">test</span>(); <span class="comment">// as prvalue</span></span><br><span class="line">    x + x;  <span class="comment">// as prvalue (but custom operator may not follow this)</span></span><br><span class="line">    <span class="built_in">static_cast</span>&lt;<span class="type">long</span>&gt;(x);   <span class="comment">// as value</span></span><br><span class="line">    std::<span class="built_in">move</span>(x);           <span class="comment">// as xvalue</span></span><br><span class="line">    <span class="built_in">static_cast</span>&lt;<span class="type">int</span> &amp;&amp;&gt;(x); <span class="comment">// same as above</span></span><br><span class="line">    <span class="built_in">static_cast</span>&lt;<span class="type">int</span> &amp;&amp;&gt;(y); <span class="comment">// as xvalue</span></span><br><span class="line">    y;                      <span class="comment">// as left reference (because named as `y`)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">str</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(std::string)</span></span>;</span><br><span class="line"><span class="function">std::string &amp;&amp;<span class="title">strange_func</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">strange_func2</span><span class="params">(std::string &amp;&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lifespan</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        std::string x;</span><br><span class="line">    &#125; <span class="comment">// x will call ~string(); after it dies.</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">func</span>(<span class="built_in">str</span>());</span><br><span class="line">    <span class="comment">// the code above is very similar to the code below</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> tmp = <span class="built_in">str</span>();</span><br><span class="line">        <span class="built_in">func</span>(<span class="built_in">static_cast</span>&lt;std::string &amp;&amp;&gt;(tmp));</span><br><span class="line">    &#125; <span class="comment">// after evaluation of func, the temporary value returned will be destructed</span></span><br><span class="line">    <span class="built_in">strange_func2</span>(t); <span class="comment">// similar to above, the temporary will be binded and then destroyed</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">func</span>(<span class="built_in">strange_func</span>()); <span class="comment">// this will construct an std::string, then destroy after func</span></span><br><span class="line">    <span class="built_in">strange_func2</span>(<span class="built_in">strange_func</span>()); <span class="comment">// this will not call any ~string(); no lifespan is ended</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>特别注意的是, 右值引用的变量, 它看起来是一个 <code>rvalue</code> 之类的东西, 但根据我们的 “有名字” 原则, 它返回的其实是一个 <code>lvalue</code>. 事实上, 所谓的右值引用, 和左值引用, 他们起到的只是影响重载决议的作用. 两者都是引用, 实现上几乎 100% 是由指针实现 (事实上, 笔者一直把引用当作一种保证非空的指针的语法糖). 换句话说, 只有在编译期选择对应的函数的时候, 这两个东西才会起到区分的作用. 只是一般来说, 大家会认为接收到右值引用的时候, 传入的对象即将被析构, 所以可以 “移走” 它的资源, 故称作 <code>move</code>.</p>
<p>所以, 读者想必可以理解为什么 <code>std::move</code> 几乎一定作用在一个有名字的变量上, 它的作用就是告诉编译器, 请选择右值引用相关的重载. 实际上, 他就等于 <code>static_cast&lt;T &amp;&amp;&gt;</code> 强行转化, 算是标准库提供的语法糖. <strong>一般来说</strong>, 通过右值进行的移动构造, 因为允许从传入的对象中接管资源 (e.g. <code>std::vector</code> 的内部数据的指针, <code>std::shared_ptr</code> 的指针), 往往会比 copy 更加高效. (当然, 这也只是君子协议, 如果用户没有实现移动构造, 或者故意在移动构造里面 <code>while(1)</code> 卡住, 那也是没有办法的事, 毕竟编译器只负责帮你选择应该调用的函数.)</p>
<p><strong>特别需要注意的是</strong>, <code>std::move</code> 无法改变 <code>const</code> 属性, 如果你希望通过 <code>move</code> 收益, 请确保入参没有 <code>const</code>.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A sample implementation of std::move</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">typename</span> std::remove_reference&lt;_Tp&gt;::<span class="function">type&amp;&amp;</span></span><br><span class="line"><span class="function"><span class="title">move</span><span class="params">(_Tp&amp;&amp; <span class="type">__t</span>)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> std::remove_reference&lt;_Tp&gt;::type&amp;&amp;&gt;(<span class="type">__t</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// good, always need to move since named parameter is `lvalue`</span></span><br><span class="line">    <span class="built_in">MyClass</span>(std::string a, std::string &amp;b, std::string &amp;&amp;c):</span><br><span class="line">        <span class="built_in">m_a</span>(std::<span class="built_in">move</span>(a)), <span class="built_in">m_b</span>(std::<span class="built_in">move</span>(b)), <span class="built_in">m_c</span>(std::<span class="built_in">move</span>(c)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// bad, move a const will not work. `const &amp;&amp;` is completely useless! never use it!</span></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">const</span> std::string a, <span class="type">const</span>  std::string &amp;b, <span class="type">const</span> std::string &amp;&amp;c):</span><br><span class="line">        <span class="built_in">m_a</span>(std::<span class="built_in">move</span>(a)), <span class="built_in">m_b</span>(std::<span class="built_in">move</span>(b)), <span class="built_in">m_c</span>(std::<span class="built_in">move</span>(c)) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string m_a;</span><br><span class="line">    std::string m_b;</span><br><span class="line">    std::string m_c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在铺垫了这么多值类型之后, 可以来讲讲模板的类型推导了. 在这里, 笔者将忽略 <code>volatile</code> 这个病态的东西.</p>
<h3 id="推导的类型是一个引用"><a href="#推导的类型是一个引用" class="headerlink" title="推导的类型是一个引用"></a>推导的类型是一个引用</h3><p><a target="_blank" rel="noopener" href="https://cntransgroup.github.io/EffectiveModernCppChinese/1.DeducingTypes/item1.html">Item 1</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(T &amp;)</span></span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cfunc</span><span class="params">(<span class="type">const</span> T &amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> &amp;<span class="title">ref</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> &amp;y = x;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> z = x;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;w = y;</span><br><span class="line"></span><br><span class="line"><span class="built_in">func</span>(x); <span class="comment">// [T = int]</span></span><br><span class="line"><span class="built_in">func</span>(y); <span class="comment">// [T = int]</span></span><br><span class="line"><span class="built_in">func</span>(z); <span class="comment">// [T = const int]</span></span><br><span class="line"><span class="built_in">func</span>(w); <span class="comment">// [T = const int]</span></span><br><span class="line"><span class="built_in">func</span>(<span class="built_in">ref</span>()); <span class="comment">// [T = int]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// func(1); // prvalue not acceptable</span></span><br><span class="line"><span class="comment">// func(std::move(x)); // xvalue not acceptable</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cfunc</span>(x); <span class="comment">// [T = int]</span></span><br><span class="line"><span class="built_in">cfunc</span>(y); <span class="comment">// [T = int]</span></span><br><span class="line"><span class="built_in">cfunc</span>(z); <span class="comment">// [T = int]</span></span><br><span class="line"><span class="built_in">cfunc</span>(w); <span class="comment">// [T = int]</span></span><br><span class="line"><span class="built_in">cfunc</span>(<span class="built_in">ref</span>()); <span class="comment">// [T = int]</span></span><br><span class="line"><span class="built_in">cfunc</span>(<span class="number">1</span>);     <span class="comment">// [T = int], the integer will be destroyed after func returns, though do nothing.</span></span><br><span class="line"><span class="built_in">cfunc</span>(std::<span class="built_in">move</span>(x)); <span class="comment">// [T = int]</span></span><br></pre></td></tr></table></figure>
<p>这个 case 相对比较简单, <code>func</code> 要求传入的值一定是一个 <code>lvalue</code>, <code>T</code> 会保留传入参数是否是 <code>const</code>, 并且是不含引用的值类型. 而 <code>cfunc</code> 则比较特殊, 它可以接受任何类型的值, <code>T</code> 会被推导为不含 <code>const</code> 和引用的类型. 读者或许可以联想到上学期讲到的 <code>const &amp;</code> 可以绑定一切并延长 <code>prvalue</code> 的生命周期, 道理的确是类似的.</p>
<h3 id="推导的类型是一个指针"><a href="#推导的类型是一个指针" class="headerlink" title="推导的类型是一个指针"></a>推导的类型是一个指针</h3><p><a target="_blank" rel="noopener" href="https://cntransgroup.github.io/EffectiveModernCppChinese/1.DeducingTypes/item1.html">Item 1</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(T *)</span></span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cfunc</span><span class="params">(<span class="type">const</span> T *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;y = x;</span><br><span class="line"><span class="built_in">func</span>(&amp;x); <span class="comment">// [T = int]</span></span><br><span class="line"><span class="built_in">func</span>(&amp;y); <span class="comment">// [T = const int]</span></span><br><span class="line"><span class="built_in">cfunc</span>(&amp;x); <span class="comment">// [T = int]</span></span><br><span class="line"><span class="built_in">cfunc</span>(&amp;y); <span class="comment">// [T = int]</span></span><br></pre></td></tr></table></figure>
<p>规则几乎和引用完全一样. 唯一特殊的是, 入参必须是指针类型, 并且不存在 <code>const *</code> 可以延长生命周期之类的, 这是因为我们不存在左右指针这回事.</p>
<p>特别注意的是, 只有 <code>lvalue</code> 可以被 take address, <code>xvalue</code> 和 <code>prvalue</code> (即 <code>rvalue</code>) 是不行的. 举例:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> &amp;&amp;<span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">g</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// all the code below is illegal</span></span><br><span class="line">&amp;(<span class="built_in">f</span>());</span><br><span class="line">&amp;(<span class="built_in">g</span>());</span><br><span class="line">&amp;(<span class="built_in">f</span>() + <span class="built_in">g</span>());</span><br><span class="line">&amp;(<span class="built_in">static_cast</span>&lt;<span class="type">int</span> &amp;&amp;&gt;(x))</span><br></pre></td></tr></table></figure>
<h3 id="推导的类型是一个通用引用"><a href="#推导的类型是一个通用引用" class="headerlink" title="推导的类型是一个通用引用"></a>推导的类型是一个通用引用</h3><p><a target="_blank" rel="noopener" href="https://cntransgroup.github.io/EffectiveModernCppChinese/1.DeducingTypes/item1.html">Item 1</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(T &amp;&amp;param)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这是一个非常特殊的 case, 要理解这个 case, 我们首先要了解万能引用, 以及理解 <code>std::forward</code>, 以及引用折叠.</p>
<p>考虑以下的引用场景: 你为用户提供了一个包装函数, 你可能会把用户的入参传给内部调用的另一个函数. 同时, 你希望有更好的泛化性, 用的是模板. 自然, 用户有的时候传入的是左值, 有的时候是右值, 你希望把这个左还是右的信息原封不动的传给内部调用的那个函数. 这时候, 就需要用到 <code>std::forward</code>.</p>
<p>简单来说, <code>std::forward</code> 功能是, 如果传入的是 <code>lvalue reference</code>, 那么就返回一个 <code>lvalue</code>; 如果传入的是 <code>rvalue reference</code>, 那就返回一个 <code>xvalue</code>, 此时类似 <code>std::move</code>. (需要注意, 入参不做任何操作的话, 一定是被当作 <code>lvalue</code> 的, 因为它 “有名字”)</p>
<p>而入参同时接受左/右值, 这就需要用到 <strong>通用引用</strong>, 或者说 <strong>万能引用</strong>. 在上述代码中, 如果传入的是一个 <code>lvalue</code> 类型比如 <code>int &amp;</code>, 那么 <code>T</code> 会被推导为 <code>int &amp;</code>, 同时 <code>param</code> 的类型应当是 <code>int &amp; &amp;&amp;</code>. 这看起来很奇怪, 因为这里需要 <strong>引用折叠</strong> 的概念. 简单来说, 在推导的过程中, 这里 <code>param</code> 的类型会被折叠为 <code>int &amp;</code>. 而如果传入的是一个 <code>rvalue</code> 类型比如 <code>int &amp;&amp;</code> 或者 <code>int</code>, 那么 <code>T</code> 会被推导为 <code>int</code> 本身, <code>param</code> 就是 <code>int &amp;&amp;</code> 类型, 没有什么歧义.</p>
<p>那 <code>std::forward</code> 是怎么工作的呢, 我们需要在 <code>func</code> 内部调用 <code>std::forward&lt;T&gt;</code>. 当 <code>T</code> 是引用类型的时候, 他会返回一个 <code>lvalue</code>; 反之, 则类似 <code>std::move</code> 返回一个 <code>xvalue</code>. 这其实就对应了入参推导 <code>T</code> 的两种 case. 参考实现如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> _Tp&amp;&amp;</span></span><br><span class="line"><span class="function"><span class="title">forward</span><span class="params">(<span class="keyword">typename</span> std::remove_reference&lt;_Tp&gt;::type&amp; <span class="type">__t</span>)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;_Tp&amp;&amp;&gt;(<span class="type">__t</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> _Tp&amp;&amp;</span></span><br><span class="line"><span class="function"><span class="title">forward</span><span class="params">(<span class="keyword">typename</span> std::remove_reference&lt;_Tp&gt;::type&amp;&amp; <span class="type">__t</span>)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;_Tp&amp;&amp;&gt;(<span class="type">__t</span>); &#125;</span><br></pre></td></tr></table></figure>
<p>现在来看看 Modern Effective C++ Item 1 具体的例子:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; param)</span></span>;</span><br><span class="line"><span class="type">int</span> x = <span class="number">27</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> cx = x;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;rx = cx;</span><br><span class="line"><span class="built_in">f</span>(x);   <span class="comment">// [T = int &amp;, T&amp;&amp; = int &amp;]</span></span><br><span class="line"><span class="built_in">f</span>(cx);  <span class="comment">// [T = const int &amp;, T&amp;&amp; = const int &amp;]</span></span><br><span class="line"><span class="built_in">f</span>(rx);  <span class="comment">// [T = const int &amp;, T&amp;&amp; = const int &amp;]</span></span><br><span class="line"><span class="built_in">f</span>(<span class="number">27</span>);  <span class="comment">// [T = int, T&amp;&amp; = int &amp;&amp;]</span></span><br></pre></td></tr></table></figure>
<h3 id="推导的类型是一个值类型"><a href="#推导的类型是一个值类型" class="headerlink" title="推导的类型是一个值类型"></a>推导的类型是一个值类型</h3><p><a target="_blank" rel="noopener" href="https://cntransgroup.github.io/EffectiveModernCppChinese/1.DeducingTypes/item1.html">Item 1</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(T)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> &amp;y = x;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> z = x;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;w = y;</span><br><span class="line"><span class="built_in">func</span>(x); <span class="comment">// [T = int]</span></span><br><span class="line"><span class="built_in">func</span>(y); <span class="comment">// [T = int]</span></span><br><span class="line"><span class="built_in">func</span>(z); <span class="comment">// [T = int]</span></span><br><span class="line"><span class="built_in">func</span>(w); <span class="comment">// [T = int]</span></span><br></pre></td></tr></table></figure>
<p>这个非常特别, 这意味着无论入参是什么, 如果是推导的话一定会拷贝一份新的对象, 并且 <code>T</code> 类型推导出来不会含有引用和 <code>const</code>. (当然, 用户也可以强行指定模板的类型 <code>T</code> 为含有引用的类型).</p>
<p>需要注意, 这里推导出来不会含有 <code>const</code> 指的是值类型本身, 如果传入的类型是 <code>const int *</code> 之类的 <code>const</code> 指针, 指向内容的 <code>const</code> 性自然是不能变的.</p>
<h3 id="边角料"><a href="#边角料" class="headerlink" title="边角料"></a>边角料</h3><p><a target="_blank" rel="noopener" href="https://cntransgroup.github.io/EffectiveModernCppChinese/1.DeducingTypes/item1.html">Item 1</a></p>
<p>比较恶心的是数组实参和函数实参.</p>
<p>在推导值类型或者指针类型的时候, 数组会退化为指针, 函数同理. 在推导引用相关类型的时候, 数组会被推导为特殊的数组引用, 函数同理.</p>
<h3 id="auto-推导"><a href="#auto-推导" class="headerlink" title="auto 推导"></a>auto 推导</h3><p><a target="_blank" rel="noopener" href="https://cntransgroup.github.io/EffectiveModernCppChinese/1.DeducingTypes/item1.html">Item 1</a></p>
<p><code>auto</code> 作为 C++11 的一大亮点, 自然是不会拉下的. <code>auto</code> 的类型推导规则几乎和函数一致, 例如 <code>auto</code> 对应的是推导值类型, <code>auto &amp;</code> 和 <code>const auto &amp;</code> 是推导一般的引用类型, 而 <code>auto &amp;&amp;</code> 则是万能引用推导. 特别地, 相信大家也在程序设计课上了解过, <code>const auto &amp;</code> 可以接受一个 <code>rvalue</code> 对象. 更加特别地, 如果 <code>const auto &amp;</code> 或者 <code>auto &amp;&amp;</code> 绑定的是一个 <code>prvalue</code>, 那么它可以延长这个 <code>prvalue</code> 的生命周期, 直到 <code>auto</code> 的这个变量离开作用域之后, 才析构. 对于 <code>xvalue</code>, 由于其并非返回一个临时的值, 编译器不会去管它的生命周期, 因此也不存在延长不延长一说.</p>
<p>比较恶心的是, <code>auto</code> 如果用初始化列表初始化, 会有一些奇怪的行为. 对于一个函数模板推导, 传入一个初始化列表一样的东西比如 <code>&#123;1, 2, 3&#125;</code> 是无法工作的. 但对于 <code>auto</code> 声明变量, 这个是允许的.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> x = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; <span class="comment">// deduced as std::initializer_list&lt;int&gt;</span></span><br><span class="line"><span class="keyword">auto</span> y = &#123;<span class="number">1</span>, <span class="number">2.0</span>&#125;;  <span class="comment">// failure in deduction</span></span><br><span class="line"><span class="keyword">auto</span> z &#123;<span class="number">1</span>&#125;;         <span class="comment">// deduced as int</span></span><br></pre></td></tr></table></figure>
<p>特别地, C++14 以后也允许了 <code>auto</code> 作为返回类型 (即不含尾置的返回类型), C++11 lambda 函数不写返回类型的话也是默认以 <code>auto</code> 返回, 此时会按照类似的规则进行推导. 如果是返回的是 <code>auto &amp;</code> 则同理. lambda 函数的参数中的 <code>auto</code> 和 C++20 以后函数参数中的 <code>auto</code> 也同理.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">func</span><span class="params">(<span class="type">int</span> &amp;x, <span class="type">int</span> &amp;y)</span> -&gt; <span class="keyword">auto</span> &amp; </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; y)</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line">[](<span class="type">const</span> <span class="keyword">auto</span> &amp;x) &#123; <span class="keyword">return</span> x; &#125; (<span class="number">1</span>); <span class="comment">// lambda, auto deduced as `int`, return `int`.</span></span><br></pre></td></tr></table></figure>
<h2 id="语言特性"><a href="#语言特性" class="headerlink" title="语言特性"></a>语言特性</h2><h3 id="inline-和-static"><a href="#inline-和-static" class="headerlink" title="inline 和 static"></a>inline 和 static</h3><p><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/inline">inline</a>, <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/storage_duration#Static_block_variables">static</a></p>
<p><code>inline</code> 和 <code>static</code> 都属于是语言中存在很久的关键词了, 早在 C 里面就已经存在. 然而, 很多人对这两个关键词存在一定的误区.</p>
<p><code>inline</code> 关键词 在 C++ 中和所谓的内联优化可以说没有一点关系. 这么说可能比较绝对, 但是为了便于读者区分, 建议读者也这么来理解. <code>inline</code> 的作用是告诉编译器, 这个符号允许被多次定义, 即在多个编译单元中出现.</p>
<p>这里首先要铺垫一下, 编译单元是什么. 在传统的算法竞赛题里面, 只有一个 <code>main.cpp</code>, 那么编译单元就只有这一个 <code>main.cpp</code>. 其他的文件都是被 <code>#include</code> 加进来的, 而众所周知, <code>#include</code> 其实就是文本替换, 把代码里面的文本复制了进来. 而一般大一点的 C++ 项目, 我们往往会看到一个 <code>CMakeLists.txt</code>, 其中经常会列出若干 <code>cpp</code> 文件, 例如 <code>src/1.cpp, src/2.cpp</code>. 这时候, 其中每个 <code>.cpp</code> 都是一个独立的编译单元, 在处理不同的单元的时候, 编译器可以并行编译, 这样在一个多核心的服务器上并行编译可以大大的减少编译的时间. 在多文件编译的时候, 往往编译器先会编译到 <code>.o</code> 文件, 然后把多个编译单元生成的多个 <code>.o</code> 文件链接为一个二进制可执行文件例如 <code>.exe</code>, <code>.out</code>. 在这个过程中, 每一个全局变量/函数都会生成一个符号, 其他的编译单元如果调用了一个声明的符号, 需要在链接期间找到符号对应的变量/函数的地址.</p>
<p>如果多个编译单元都看到了某个函数的声明和定义, 那么在编译到 <code>.o</code> 的过程中, 这些单元都会把这个函数的符号记下来, 读者可以认为是每个单元都维护了一个符号表 <code>map</code>, 而 <code>map</code> 里面 <code>key</code> 为这个函数名字的一项记录了这个函数的地址 (这是一个不严谨的说法, 请不要细究细节). 而在链接的阶段, 不同的编译单元的符号表需要合并, 但如果合并的时候发现某一个 <code>key</code> 有两个对应的记录, 那么就会报错. 事实上, C/C++ 要求最后所有编译单元的结果中, 每个符号 (包括全局变量/函数) 只有一处定义, 这也就是所谓的 <strong>One Definition Rule</strong> (ODR), 即一个函数只能有一个定义.</p>
<p>然而, 很多时候, 对于一些简单的函数, 比如 <code>int add_1(int x) &#123; return x + 1; &#125;</code>, 我们想把它放到头文件里面, 而不是某个 <code>.cpp</code> 里面. 一般情况下, 当多个编译单元包含了这个文件的时候, 这会违反 ODR. 这时候, 我们就需要用到 <code>inline</code> 关键词. <code>inline</code> 关键词的作用是, 在一个符号在多个编译单元里面出现时, 编译器随机保留其中的一份, 丢弃其他的. 因为多个编译单元中包括的是同一个头文件, 看到的也是同一个函数的实现 (比如上述例子中的 <code>add_1</code>), 因此保留哪一份不会影响正确性. 特别地, C++ 默认类内提供实现的成员函数都是 <code>inline</code> 的, <del>所以大家多用面向对象吧</del>.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MyStructTest</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">// default set as inline, safe to be included in a header.</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// if in .h/.hpp, need to manually add `inline` here, because definition is out of the class</span></span><br><span class="line"><span class="comment">// if in .cpp, we shouldn&#x27;t add inline here!</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">MyStructTest::func2</span><span class="params">()</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p><code>static</code> 修饰一个 <code>class</code> 成员函数/变量比较特殊, 这里讨论的是 <code>static</code> 修饰一个全局变量/函数. <code>static</code> 要求修饰的这个符号变成内部符号, 即最终这个符号不会对外暴露, 当前编译单元内所有用到这个符号的地方, 都会变成对内部符号的调用. 换句话说, 它不会在最终 <code>.o</code> 里面的符号表里面出现. 因此, 别的编译单元无论如何都无法直接调用这一个函数.</p>
<p>总结一下, <code>inline</code> 是允许多个定义, 编译器保留其中任意一份, 而 <code>static</code> 是让符号变成内部符号, 类似 private, 不再对外暴露. 对于在头文件中提供了定义的全局函数, 笔者建议使用 <code>inline</code>. 对于没有在 <code>.h</code> 中声明, 仅仅用于当前编译单元 (<code>.cpp</code>) 的一些内部辅助函数, 笔者建议使用 <code>static</code>. 当然, 同样的概念不仅仅适用于函数, 同样也适用于变量 (需要 C++17). 以下是一些样例代码.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> dark &#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">short_func</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// declare and define constexpr value in header</span></span><br><span class="line"><span class="comment">// highly recommended in C++, maybe best practice</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">constexpr</span> <span class="type">int</span> kZero = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="comment">// this static just means not a member variable,</span></span><br><span class="line">    <span class="comment">// but shared by the class `Test`</span></span><br><span class="line">    <span class="keyword">inline</span> <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> kon = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace dark</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;test.h&quot;</span></span></span><br><span class="line"><span class="keyword">namespace</span> dark &#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">internal_helper</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// do not add static or inline here</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">short_func</span>();</span><br><span class="line">    <span class="built_in">internal_helper</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace dark</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;test.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    dark::<span class="built_in">func</span>();</span><br><span class="line">    dark::<span class="built_in">short_func</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>感兴趣的读者可以再自行去了解一下匿名 <code>namespace</code> 的概念, 详情请参考 <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/namespace">cppreference</a>. 简单来说, 它让其中的所有符号都变成 <code>static</code> 的, 非常适合放在 <code>.cpp</code> 文件中.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">no_need_to_mark_static</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="using"><a href="#using" class="headerlink" title="using"></a>using</h3><p><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/keyword/using">using</a></p>
<p>一些笔者想到的常用功能:</p>
<ol>
<li><code>using enum</code>: C++20 引入的, 可以把 <code>enum</code> 的作用域引入当前作用域, 非常适用于 <code>switch</code> 内部.</li>
<li><code>using namespace xxx</code>: 不推荐, 除非是 <code>using std::literals::chrono_literals</code> 来引入 <code>s</code> 这类用户定义字面量.</li>
<li><code>using ns::xxx</code>: 引入 namespace <code>ns</code> 中的 <code>xxx</code>, 适用于一个封闭作用域内部 (比如函数).</li>
<li><code>using A = B</code>: 非常常见, 请全面禁用 <code>typedef</code>, 我们不应该兼容 <code>C++11</code> 之前的代码.</li>
</ol>
<h3 id="结构化绑定"><a href="#结构化绑定" class="headerlink" title="结构化绑定"></a>结构化绑定</h3><p><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/structured_binding">binding</a>, <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/adl">ADL</a></p>
<p>在 C++17 中, 引入了结构化绑定: 对于一个聚合类 (即没有基类, 没有用户声明的构造函数) 或者按照 <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/structured_binding">特殊规则</a> 重载了对应的函数的类, 我们可以类似 python 中 <code>tuple</code> 解包的形式写代码. 比如 <code>std::pair</code>, <code>std::tuple</code>, <code>std::array</code> 以及原生的数组都是支持的. 语法如下, 需要注意的是必须用 <code>auto</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">std::tuple&lt;<span class="type">int</span>, <span class="type">float</span>, std::string&gt; t;</span><br><span class="line"><span class="keyword">auto</span> &amp;[x, y, z] = t;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyStruct</span> &#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">&#125; tmp;</span><br><span class="line"><span class="keyword">auto</span> [a, b] = tmp; <span class="comment">// must use auto</span></span><br></pre></td></tr></table></figure>
<p>如果你对于自定义的非聚合类也想使用结构化绑定, 那么你需要提供一个 <code>get</code> 函数, 并且特化 <code>std::tuple_size</code> 和 <code>std::tuple_element</code> 两个模板. 例如:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">double</span> y;</span><br><span class="line">    <span class="type">int</span> other;</span><br><span class="line">    <span class="comment">// this violate the definition of aggregate class</span></span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> x, <span class="type">double</span> y) : <span class="built_in">x</span>(x), <span class="built_in">y</span>(y), <span class="built_in">other</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">std</span>::tuple_size&lt;A&gt; : std::integral_constant&lt;std::<span class="type">size_t</span>, <span class="number">2</span>&gt; &#123;</span><br><span class="line">    <span class="comment">// now, std::tuple_size&lt;A&gt;::value is 2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;std::<span class="type">size_t</span> I&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">get</span><span class="params">(A &amp;a)</span> -&gt; <span class="keyword">decltype</span>(<span class="keyword">auto</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(I == <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.x;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">constexpr</span> (I == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> a.y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;std::<span class="type">size_t</span> I&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">get</span><span class="params">(<span class="type">const</span> A &amp;a)</span> -&gt; <span class="keyword">decltype</span>(<span class="keyword">auto</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(I == <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.x;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">constexpr</span> (I == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> a.y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;std::<span class="type">size_t</span> I&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">std</span>::tuple_element&lt;I, A&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> type = <span class="keyword">decltype</span>(<span class="built_in">get</span>&lt;I&gt;(std::<span class="built_in">declval</span>&lt;A&gt;()));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">main</span><span class="params">()</span> -&gt; <span class="type">int</span> </span>&#123;</span><br><span class="line">    A a&#123;<span class="number">1</span>, <span class="number">1.0</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> &amp;[x, y] = a;</span><br><span class="line">    std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; y &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里你可能会好奇了: 编译器为什么知道调用的是哪个 <code>get</code> 函数? 为什么不是 <code>std::get</code>? 这里就涉及 C++ 中 Argument Dependent Lookup (ADL) 的知识了. 考虑到 ADL 对于一般读者还是过于抽象和晦涩, 这里笔者只给出一个 <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/adl">cppref 链接</a>, 笔者也是在 23 年暑假花了整整一个暑假才嚼明白, 并且在漫长的实践中才真正理解.</p>
<h3 id="if-switch"><a href="#if-switch" class="headerlink" title="if/switch"></a>if/switch</h3><p><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/if">if</a>, <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/switch">switch</a></p>
<p>在 C++17 中, 引入了 <code>if</code> 初始化语句. 简单来说, 你可以在判断一个条件的同时把结果放在 <code>if</code> 内部 (注意, 条件判断不一定返回的是 <code>bool</code>, 只要可以 <code>static_cast&lt;bool&gt;</code> 即可), 或者为 <code>if</code> 额外的添加初始化语句, 从而避免变量名泄露, 把变量的生命周期限制在 <code>if</code> 语句内部. 这对 <code>switch</code> 也是类似的.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">foo</span><span class="params">()</span> -&gt; std::shared_ptr&lt;<span class="type">int</span>&gt;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// before</span></span><br><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; ptr = <span class="built_in">foo</span>();</span><br><span class="line"><span class="keyword">if</span> (ptr) &#123;</span><br><span class="line">    <span class="comment">// do something A</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// do something B</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ptr != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="comment">// yet another way</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// after</span></span><br><span class="line"><span class="keyword">if</span> (std::shared_ptr&lt;<span class="type">int</span>&gt; ptr = <span class="built_in">foo</span>()) &#123;</span><br><span class="line">    <span class="comment">// do something A</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// do something B</span></span><br><span class="line">    <span class="comment">// note that ptr is still reachable in this branch.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ptr dies here.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="type">int</span> x = <span class="number">0</span>, y = <span class="number">2</span>; std::shared_ptr&lt;<span class="type">int</span>&gt; ptr = <span class="built_in">foo</span>()) &#123;</span><br><span class="line">    <span class="comment">// yet another way</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (std::shared_ptr&lt;<span class="type">int</span>&gt; x = <span class="built_in">foo</span>(); x &amp;&amp; *x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// this is also ok</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (std::shared_ptr&lt;<span class="type">int</span>&gt; y = <span class="built_in">foo</span>(); x &amp;&amp; y &amp;&amp; *x == *y) &#123;</span><br><span class="line">    <span class="comment">// also works for else if</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个设计最大的好处是, 可以干净的, 只为 <code>if</code> 所在的作用域声明变量, 避免变量名泄露, 严格控制变量的生命周期. 笔者认为这是现代语言必须的一个特点, 即闭包化, 每个模块尽量解耦, 严格限制模块之间潜在的耦合, 进而写出更高质量的代码.</p>
<h3 id="constexpr-consteval-constinit"><a href="#constexpr-consteval-constinit" class="headerlink" title="constexpr/consteval/constinit"></a>constexpr/consteval/constinit</h3><p>在 C++20 中, 推出了两个有趣的关键词: <code>consteval</code>和 <code>constinit</code>. 前者要求函数必须在编译期求值, 后者要求变量必须在编译期初始化.</p>
<h3 id="constexpr"><a href="#constexpr" class="headerlink" title="constexpr"></a>constexpr</h3><p><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/keyword/constexpr">constexpr</a></p>
<p><code>constexpr</code> 是 C++11 引入的, 当修饰变量的时候, 要求变量在编译期初始化, 当修饰函数的时候, 表示函数允许在编译期求值. 这些你应该都在课上已经了解了. 在逐渐发展的过程中, <code>constexpr</code> 也在变得更强. 在 C++20 中, <code>constexpr</code> 修饰的函数甚至允许动态分配内存, 仅仅要求在编译期确定大小以及释放 (虽然这是编译器对 <code>std::allocator</code> 开洞…).</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">find_the_kth_prime</span><span class="params">(<span class="type">int</span> k)</span> -&gt; <span class="type">int</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> vec      = std::vector&lt;<span class="type">int</span>&gt;&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> is_prime = [&amp;vec](<span class="type">int</span> x) -&gt; <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;p : vec)</span><br><span class="line">            <span class="keyword">if</span> (x % p == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">int</span> num = vec.<span class="built_in">back</span>() + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (vec.<span class="built_in">size</span>() &lt; <span class="built_in">static_cast</span>&lt;std::<span class="type">size_t</span>&gt;(k)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">is_prime</span>(num))</span><br><span class="line">            vec.<span class="built_in">push_back</span>(num);</span><br><span class="line">        num += <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// vec is dynamically allocated and freed in compile time</span></span><br><span class="line">    <span class="comment">// so it&#x27;s ok to use as a temporary variable</span></span><br><span class="line">    <span class="keyword">return</span> vec[k - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ok</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> val = <span class="built_in">find_the_kth_prime</span>(<span class="number">100</span>);</span><br></pre></td></tr></table></figure>
<p>事实上, 传统很多使用模板元编程的奇技淫巧基本都可以用 <code>constexpr</code> 来替换了, 这种写法可读性更高, 也更加直观.</p>
<h3 id="consteval"><a href="#consteval" class="headerlink" title="consteval"></a>consteval</h3><p><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/keyword/consteval">consteval</a></p>
<p><code>consteval</code> 的核心在于: 函数必须在编译期求值. 例如:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">consteval</span> <span class="keyword">auto</span> <span class="title">must_be_0</span><span class="params">(<span class="type">int</span> x)</span> -&gt; <span class="type">int</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述函数中, 如果你的入参不是 <code>0</code>, 那么编译器会报错 (因为 throw 无法在编译期执行), 代码无法通过编译. 这有两点:</p>
<ol>
<li>强制某些函数的计算在编译期完成. 虽然 C++ 编译器有着非常强大的优化能力, 但是对于极其复杂的函数, 并不保证能够优化出来, 即使被标上了 <code>constexpr</code>, 只要不是赋值给 <code>constexpr</code> 的变量, 编译器也不会强制在编译期求值 (虽然大多数情况下会). 这时候, <code>consteval</code> 就派上用场了.</li>
<li>给编译期间的错误提供了更多的可能. 例如上述代码, 如果你传入了一个非 0 的值, 编译器会报错. 我们因此可以实现类似功能: 只要当函数的输入类型/参数满足特定条件的时候, 才能通过编译 (参考 <code>std::format</code>).</li>
</ol>
<p>需要注意的是, <code>consteval</code> 和重载决议无关. 编译器在选择了正确的函数之后, 如果该函数不满足 <code>consteval</code> 的要求, 编译器会报错. 你可能会联想到 SFINAE, 但是遗憾的是, SFINAE 只会影响重载的选择, 而 <code>consteval</code> 是在重载选择之后才会起作用的, 因此两者并无关系.</p>
<h3 id="constinit"><a href="#constinit" class="headerlink" title="constinit"></a>constinit</h3><p><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/keyword/constinit">constinit</a></p>
<p>有的人可能认为 <code>constinit</code> 就是 <code>constexpr</code>, 但是这是错误的. <code>constinit</code> 是要求变量在编译期初始化, 变量本身可以是非 <code>const</code> 的, 而 <code>constexpr</code> 则暗含了 1. 变量是 <code>const</code> 的, 2. 变量在编译期初始化. 例如:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constinit</span> <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    x = <span class="number">1</span>; <span class="comment">// ok</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码是合法的, 因为 <code>x</code> 是 <code>constinit</code>, 而不是 <code>const</code>. 但是如果你把 <code>constinit</code> 换成 <code>constexpr</code>, 那么编译器会报错. 好奇的你可能想问: 那这个关键词有什么用呢? 事实上, 它是为了解决一个问题而生的: 静态变量的初始化顺序问题.</p>
<p>在 C++ 中, 静态变量(你可以理解为全局变量)的初始化顺序是不确定的, 如果你有两个静态变量, 他们之间有依赖关系, 那么你可能会遇到问题. 例如:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">f</span><span class="params">()</span> -&gt; <span class="type">int</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line"><span class="type">int</span> y = <span class="built_in">f</span>();</span><br><span class="line"><span class="type">int</span> x = y;</span><br></pre></td></tr></table></figure>
<p>这个初始化顺序是可能不确定的 (虽然实测几乎没出过错, 可能主要还是在跨编译单元的时候, 容易出问题), 有可能 <code>x</code> 先初始化, 也有可能 <code>y</code> 先初始化. 这时候, 你可以使用 <code>constinit</code> 来解决这个问题:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">consteval</span> <span class="keyword">auto</span> <span class="title">f</span><span class="params">()</span> -&gt; <span class="type">int</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line"><span class="keyword">constinit</span> <span class="type">int</span> y = <span class="built_in">f</span>();</span><br><span class="line"><span class="type">int</span> x = y;</span><br></pre></td></tr></table></figure>
<p>同时, <code>constinit</code> 也可以支持 <code>extern</code> 的变量, 这是 <code>constexpr</code> 做不到的.</p>
<h2 id="memory-safe"><a href="#memory-safe" class="headerlink" title="memory-safe"></a>memory-safe</h2><p>Modern C++ 一个突出的特点是, 内存安全. 其中, RAII 给我们的实现提供了巨大的便利. 而 <code>memory safe</code> 的实现, 其靠的就是 smart pointer. 在大多数的情况下, 我们都应该用智能指针替代裸指针.</p>
<ul>
<li><code>unique_ptr</code> 只能有一个拥有者的指针.</li>
<li><code>shared_ptr</code> 可以被多处拥有的指针, 需要注意防止循环引用.</li>
</ul>
<p>说实话, 这些智能指针其实最大的便利不是访问的安全性, 用户依然可以随便就写出访问空指针的代码, 它们最大的好处还是, 实现了内存资源的自动回收. 这其实本质就是 RAII 思想的运用, 构造处获取资源, 析构处回收资源, 而移动语义则一般表示资源的转交 (比如 <code>unique_ptr</code>, 在移动构造/赋值之后, 被移动的对象会被重置为空指针). 这些先进的理念也被后来很多更加先进的编程语言所采纳, 比如 <code>rust</code>.</p>
<h3 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h3><p><a target="_blank" rel="noopener" href="https://cntransgroup.github.io/EffectiveModernCppChinese/4.SmartPointers/item18.html">Item 18</a>, <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/memory/unique_ptr">unique_ptr</a>, <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/memory/unique_ptr/make_unique">make_unique, make_unique_for_overwrite</a></p>
<p>主要截取自 item 18. 对于独占 (尤其是不可复制) 的资源, 我们会用 <code>unique_ptr</code> 来管理内存.</p>
<p>一般来说, 如果使用 <code>unique_ptr</code> 我们会更加倾向于用一个工厂函数来构建这个 <code>unique_ptr</code> 对象, 例如标准库提供的 <code>std::make_unique</code>. 当然, 如果你想支持一些更加复杂的功能, 特别是自定义删除器的时候, 很多时候需要自己手写, 可以用到 C++14 的 auto 返回类型 + lambda 函数来实现一些优雅的功能. 下面例子节选自 item 18.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Ts&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">makeInvestment</span><span class="params">(Ts &amp;&amp;...params)</span> </span>&#123; <span class="comment">// need C++14 </span></span><br><span class="line">    <span class="keyword">auto</span> delInvmt = [](Investment *pInvestment) &#123;</span><br><span class="line">        <span class="comment">// pInvestment pointer will not be nullptr.</span></span><br><span class="line">        <span class="built_in">makeLogEntry</span>(pInvestment);</span><br><span class="line">        <span class="keyword">delete</span> pInvestment;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;Investment, <span class="title">decltype</span><span class="params">(delInvmt)</span>&gt; <span class="title">pInv</span><span class="params">(<span class="literal">nullptr</span>, delInvmt)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (...) &#123;</span><br><span class="line">        pInv.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">Stock</span>(std::forward&lt;Ts&gt;(params)...));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (...) &#123;</span><br><span class="line">        pInv.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">Bond</span>(std::forward&lt;Ts&gt;(params)...));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (...) &#123;</span><br><span class="line">        pInv.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">RealEstate</span>(std::forward&lt;Ts&gt;(params)...));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pInv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然, 如果你不是特别关心效率, 但是非常关心泛化性, 你也可以用 <code>std::function&lt;void(T *)&gt;</code> 来作为删除器, 支持任意的仿函数作为删除器, 缺点是会增加存储的空间. 同时, <code>unique_ptr</code> 也可以很方便的转化为 <code>shared_ptr</code>, 提供了不少的便利性.</p>
<p>特别地, <code>unique_ptr</code> 允许指针转化为派生类或者基类的 <code>unique_ptr</code>, 不过这很容易带来内存泄露的问题, 析构的时候可能会找到错误的析构函数. 在笔者的日常使用中, <code>unique_ptr</code> 经常会搭配抽象基类 (<code>virtual class</code>), 虚类的 <code>virtual</code> 析构函数可以让 <code>unique_ptr</code> 在 destroy 指针指向的对象的时候找到正确析构, 避免资源泄露.</p>
<p>最后, 以 item 18 的 notes 总结一下:</p>
<ol>
<li><code>std::unique_ptr</code> 是轻量级、快速的、只可移动 <code>(move-only)</code> 的管理专有所有权语义资源的智能指针</li>
<li>默认情况，资源销毁通过 <code>delete</code> 实现, 但是支持自定义删除器. 有状态的删除器和函数指针会增加 <code>std::unique_ptr</code> 对象的大小</li>
<li>将 <code>std::unique_ptr</code> 转化为 <code>std::shared_ptr</code> 非常简单</li>
<li><code>std::unique_ptr</code> 在大部分的使用情况, 性能和裸指针无异 (一句话, 我相信编译器优化).</li>
</ol>
<blockquote>
<p>Remark: 一般来说, 笔者不鼓励使用传入一个 <code>new</code> 出来的指针构造 <code>unique_ptr</code>, 除非有特殊的删除器, 否则笔者推荐全部用 <code>std::make_unique</code> 来构造.</p>
</blockquote>
<h3 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h3><p><a target="_blank" rel="noopener" href="https://cntransgroup.github.io/EffectiveModernCppChinese/4.SmartPointers/item19.html">Item 19</a>, <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/memory/shared_ptr">shared_ptr</a>, <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/memory/enable_shared_from_this">enable_shared_from_this</a>, <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/memory/shared_ptr/make_shared">make_shared, make_shared_for_overwrite</a></p>
<p>比起 <code>unique_ptr</code>, <code>shared_ptr</code> 会更加灵活, 其通过了引用计数来控制了对象的生命周期, 允许高效的拷贝, 当然缺点就是可能成环导致资源泄露. 笔者并不经常使用 <code>shared_ptr</code>, 这里就不过多介绍了. 为了避免循环引用, 需要把可能的循环中的一部分设置为 <code>weak_ptr</code>, 具体用法请参考 cppreference.</p>
<p><code>shared_ptr</code> 更加灵活的一点是, 它支持传入一个自定义的删除器作为构造参数的一部分, 而不需要像 <code>unique_ptr</code> 那样在模板里面显式指出来. 正因如此, 你可以放心的把派生类的 <code>shared_ptr</code> 转化为基类的 <code>shared_ptr</code>, 不用担心基类不是 <code>virtual</code> 可能会带来资源泄露, 这是因为 <code>shared_ptr</code> 在一开始已经把对应指针类型的删除函数给 “记下来了”. 这自然是有开销的, 但是也能带来不小的便利.</p>
<p>特别地, 使用 <code>shared_ptr</code> 的时候, 一个常见的问题是把一个指针, 由两个 <code>shared_ptr</code> 来接管 (包括 <code>unique_ptr</code> 也会有这种问题), 或者错误的由 <code>this</code> 指针来构造一个 <code>shared_ptr</code> (这并不会正确的构造一个指向同一个引用计数块的 <code>shared_ptr</code>). 因此, 笔者认为无论如何, 在没有自定义删除器的情况下, 请尽一切可能使用 <code>std::make_shared</code> 来构造一个 <code>shared_ptr</code>. 同时, 对于前面提到的从 <code>this</code> 构造 <code>shared_ptr</code> 的例子, 正确的做法是继承一个 <code>std::enable_shared_from_this&lt;T&gt;</code>, 然后调用基类的 <code>shared_from_this</code> 函数. 下面的例子改变自 <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/memory/enable_shared_from_this">cppreference</a>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Good</span> : <span class="keyword">public</span> std::enable_shared_from_this&lt;Good&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::shared_ptr&lt;Good&gt; <span class="title">getptr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">shared_from_this</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Best</span> : <span class="keyword">public</span> std::enable_shared_from_this&lt;Best&gt; &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Private</span> &#123;&#125;;</span><br><span class="line">    <span class="built_in">Best</span>(Private) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Everyone else has to use this factory function</span></span><br><span class="line">    <span class="comment">// Hence all Best objects will be contained in shared_ptr</span></span><br><span class="line">    <span class="function"><span class="type">static</span> std::shared_ptr&lt;Best&gt; <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">make_shared</span>&lt;Best&gt;(<span class="built_in">Private</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::shared_ptr&lt;Best&gt; <span class="title">getptr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">shared_from_this</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Bad</span> &#123;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;Bad&gt; <span class="title">getptr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">shared_ptr</span>&lt;Bad&gt;(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Bad</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Bad::~Bad() called\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如果以上这些说法都没法说服你用 <code>std::make_shared</code>, 那么笔者可以再告诉你一个有趣的小细节. <code>shared_ptr</code> 由两部分组成: 对象指针和控制块指针 (常见 <code>gcc</code> 和 <code>clang</code> 的实现, <code>sizeof(shared_ptr&lt;T&gt;)</code> 都是 <code>16</code> 即两个指针). 控制块比较特殊, 管理了对象的析构函数, 引用计数等一系列东西. 而如果你用 <code>std::make_shared</code>, 那么在一般的实现中 (比如 <code>gcc</code>), 它的控制块和对象会共用一大块存储, 而不需要申请两次空间. 试着运行一下以下的代码吧.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// no inline, required by [replacement.functions]/3</span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> sz)</span> </span>&#123;</span><br><span class="line">    std::<span class="built_in">printf</span>(<span class="string">&quot;1) new(size_t), size = %zu\n&quot;</span>, sz);</span><br><span class="line">    <span class="keyword">if</span> (sz == <span class="number">0</span>)</span><br><span class="line">        ++sz; <span class="comment">// avoid std::malloc(0) which may return nullptr on success</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="type">void</span> *ptr = std::<span class="built_in">malloc</span>(sz))</span><br><span class="line">        <span class="keyword">return</span> ptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> std::bad_alloc&#123;&#125;; <span class="comment">// required by [new.delete.single]/3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// no inline, required by [replacement.functions]/3</span></span><br><span class="line"><span class="type">void</span> *<span class="keyword">operator</span> <span class="keyword">new</span>[](std::<span class="type">size_t</span> sz) &#123;</span><br><span class="line">    std::<span class="built_in">printf</span>(<span class="string">&quot;2) new[](size_t), size = %zu\n&quot;</span>, sz);</span><br><span class="line">    <span class="keyword">if</span> (sz == <span class="number">0</span>)</span><br><span class="line">        ++sz; <span class="comment">// avoid std::malloc(0) which may return nullptr on success</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="type">void</span> *ptr = std::<span class="built_in">malloc</span>(sz))</span><br><span class="line">        <span class="keyword">return</span> ptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> std::bad_alloc&#123;&#125;; <span class="comment">// required by [new.delete.single]/3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span> *ptr)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    std::<span class="built_in">puts</span>(<span class="string">&quot;3) delete(void*)&quot;</span>);</span><br><span class="line">    std::<span class="built_in">free</span>(ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span> *ptr, std::<span class="type">size_t</span> size)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    std::<span class="built_in">printf</span>(<span class="string">&quot;4) delete(void*, size_t), size = %zu\n&quot;</span>, size);</span><br><span class="line">    std::<span class="built_in">free</span>(ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="type">void</span> *ptr) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">    std::<span class="built_in">puts</span>(<span class="string">&quot;5) delete[](void* ptr)&quot;</span>);</span><br><span class="line">    std::<span class="built_in">free</span>(ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="type">void</span> *ptr, std::<span class="type">size_t</span> size) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">    std::<span class="built_in">printf</span>(<span class="string">&quot;6) delete[](void*, size_t), size = %zu\n&quot;</span>, size);</span><br><span class="line">    std::<span class="built_in">free</span>(ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">object</span> &#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">10</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">main</span><span class="params">()</span> -&gt; <span class="type">int</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> tmp = std::<span class="built_in">make_shared</span>&lt;object&gt;();</span><br><span class="line">    std::<span class="built_in">puts</span>(<span class="string">&quot;7) make_shared&quot;</span>);</span><br><span class="line">    <span class="keyword">auto</span> tmp2 = std::<span class="built_in">shared_ptr</span>&lt;object&gt;(<span class="keyword">new</span> object&#123;&#125;);</span><br><span class="line">    std::<span class="built_in">puts</span>(<span class="string">&quot;8) shared_ptr&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结一下, <code>shared_ptr</code> 是一个非常强大而方便的管理指针数据的工具, 它维护了指针的析构器和引用计数, 它的引用计数甚至是线程安全的. 自然, 这会带来一些不必要的开销, 但是在很多时候, 灵活性带来的好处远胜于一些微不足道的开销带来的弊端.</p>
<p>一个非常非常非常常见的 use case 是 <code>pimpl</code>. 具体来说, 我们在对象中维护了一个 <code>std::shared_ptr&lt;Impl&gt;</code>, 但是 <code>Impl</code> 只有声明 (即 <code>struct Impl</code>), 而实现处放在了 <code>.cpp</code> 文件中而不是在 <code>.h</code>. 这是因为头文件在编译的时候, <code>#include</code> 的内容会被替换到文件里面, 而一个类的实现可能会包含很多其他的依赖 (比如标准库里面的 <code>vector, unordered_set</code>, 或者是第三方库的一些代码). 如果我们把类的实现 (注意, 是类的实现, 而不仅仅是类的成员的实现) 放在了 <code>.h</code> 里面, 那么一旦你的类的结构发生了任何改变 (比如添加了一个函数, 或者删除了一个成员), 编译的时候, 所有依赖这个 <code>.h</code> 的 <code>.cpp</code> 文件都需要重新编译. 在一个庞大的项目里面, 这会极大地拖垮编译速度, 可能会慢到无法接受, 1 ~ 2 个小时都是有可能的. 这时候, 把类的结构完全分离到 <code>.cpp</code> 中 (包括内部成员和所有成员函数), 只对外暴露一些必要的接口或者说 API, 不仅可以极大地提升编译速度, 还能强制把接口和实现分离, 提高了代码的可读性.</p>
<p>这个问题的解决方案有一个是前向声明一个不完整类型 <code>struct Impl;</code>, 而在传参的时候尽量用引用类型比如 <code>const &amp;</code> (虽然指针也行, 但是 Modern C++ 不提倡指针) (这里传值需要看到类型的完整定义). 同时, 对于一个类型的对象, 总需要有一个持有者吧. 这时候 <code>shared_ptr</code> 就可以作为这个持有者. 下面是著名开源项目 <a target="_blank" rel="noopener" href="https://github.com/mlc-ai/xgrammar">xgrammar</a> 里面的一些代码:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment"> *  Copyright (c) 2024 by Contributors</span></span><br><span class="line"><span class="comment"> * \file xgrammar/object.h</span></span><br><span class="line"><span class="comment"> * \brief Utilities for creating objects.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> XGRAMMAR_OBJECT_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XGRAMMAR_OBJECT_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span>   <span class="comment">// IWYU pragma: keep</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span>  <span class="comment">// IWYU pragma: keep</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> xgrammar &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment"> * \brief A tag type for empty constructor.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Since XGRAMMAR_DEFINE_PIMPL_METHODS already occupies the default constructor to</span></span><br><span class="line"><span class="comment"> * construct a null object, this tag is used to define an empty constructor for</span></span><br><span class="line"><span class="comment"> * the object.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">EmptyConstructorTag</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XGRAMMAR_DEFINE_PIMPL_METHODS(TypeName)                                \</span></span><br><span class="line"><span class="meta"> public:                                                                       \</span></span><br><span class="line"><span class="meta">  class Impl;                                                                  \</span></span><br><span class="line"><span class="meta">  <span class="comment">/* The default constructor constructs a null object. Note operating on a */</span>  \</span></span><br><span class="line"><span class="meta">  <span class="comment">/* null object will fail. */</span>                                                 \</span></span><br><span class="line"><span class="meta">  explicit TypeName() : pimpl_(nullptr) &#123;&#125;                                     \</span></span><br><span class="line"><span class="meta">  <span class="comment">/* Construct object with a shared pointer to impl. The object just stores */</span> \</span></span><br><span class="line"><span class="meta">  <span class="comment">/* a pointer. */</span>                                                             \</span></span><br><span class="line"><span class="meta">  explicit TypeName(std::shared_ptr<span class="string">&lt;Impl&gt;</span> pimpl) : pimpl_(std::move(pimpl)) &#123;&#125; \</span></span><br><span class="line"><span class="meta">  TypeName(const TypeName&amp; other) = default;                                   \</span></span><br><span class="line"><span class="meta">  TypeName(TypeName&amp;&amp; other) noexcept = default;                               \</span></span><br><span class="line"><span class="meta">  TypeName&amp; operator=(const TypeName&amp; other) = default;                        \</span></span><br><span class="line"><span class="meta">  TypeName&amp; operator=(TypeName&amp;&amp; other) noexcept = default;                    \</span></span><br><span class="line"><span class="meta">  <span class="comment">/* Access the impl pointer. Useful in implementation. */</span>                     \</span></span><br><span class="line"><span class="meta">  Impl* operator-&gt;() &#123; return pimpl_.get(); &#125;                                  \</span></span><br><span class="line"><span class="meta">  const Impl* operator-&gt;() const &#123; return pimpl_.get(); &#125;                      \</span></span><br><span class="line"><span class="meta">                                                                               \</span></span><br><span class="line"><span class="meta"> private:                                                                      \</span></span><br><span class="line"><span class="meta">  std::shared_ptr<span class="string">&lt;Impl&gt;</span> pimpl_</span></span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace xgrammar</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">// XGRAMMAR_OBJECT_H_</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment"> *  Copyright (c) 2024 by Contributors</span></span><br><span class="line"><span class="comment"> * \file xgrammar/grammar.h</span></span><br><span class="line"><span class="comment"> * \brief The header for the definition and construction of BNF grammar.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> XGRAMMAR_GRAMMAR_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XGRAMMAR_GRAMMAR_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xgrammar/object.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;optional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> xgrammar &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">StructuralTagItem</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Grammar</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function">std::string <span class="title">ToString</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="function"><span class="type">static</span> Grammar <span class="title">FromEBNF</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="type">const</span> std::string&amp; ebnf_string, <span class="type">const</span> std::string&amp; root_rule_name = <span class="string">&quot;root&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">  )</span></span>;</span><br><span class="line">  <span class="function"><span class="type">static</span> Grammar <span class="title">FromJSONSchema</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="type">const</span> std::string&amp; schema,</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="type">bool</span> any_whitespace = <span class="literal">true</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">      std::optional&lt;<span class="type">int</span>&gt; indent = std::<span class="literal">nullopt</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">      std::optional&lt;std::pair&lt;std::string, std::string&gt;&gt; separators = std::<span class="literal">nullopt</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="type">bool</span> strict_mode = <span class="literal">true</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="type">bool</span> print_converted_ebnf = <span class="literal">false</span></span></span></span><br><span class="line"><span class="params"><span class="function">  )</span></span>;</span><br><span class="line">  <span class="function"><span class="type">static</span> Grammar <span class="title">FromRegex</span><span class="params">(<span class="type">const</span> std::string&amp; regex, <span class="type">bool</span> print_converted_ebnf = <span class="literal">false</span>)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">static</span> Grammar <span class="title">FromStructuralTag</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="type">const</span> std::vector&lt;StructuralTagItem&gt;&amp; tags, <span class="type">const</span> std::vector&lt;std::string&gt;&amp; triggers</span></span></span><br><span class="line"><span class="params"><span class="function">  )</span></span>;</span><br><span class="line">  <span class="function"><span class="type">static</span> Grammar <span class="title">BuiltinJSONGrammar</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">static</span> Grammar <span class="title">Union</span><span class="params">(<span class="type">const</span> std::vector&lt;Grammar&gt;&amp; grammars)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">static</span> Grammar <span class="title">Concat</span><span class="params">(<span class="type">const</span> std::vector&lt;Grammar&gt;&amp; grammars)</span></span>;</span><br><span class="line">  <span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="type">const</span> Grammar&amp; grammar);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">XGRAMMAR_DEFINE_PIMPL_METHODS</span>(Grammar);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace xgrammar</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">// XGRAMMAR_GRAMMAR_H_</span></span></span><br></pre></td></tr></table></figure>
<h3 id="smart-pointer-的遗憾"><a href="#smart-pointer-的遗憾" class="headerlink" title="smart pointer 的遗憾"></a>smart pointer 的遗憾</h3><p>smart pointer 在笔者看来, 已经极大地解决了 <code>memory safe</code> 的问题. 但它并没有解决一个信任链的问题. 那就是, 这个指针到底会不会是一个空指针. 无论是 <code>shared_ptr</code> 还是 <code>unique_ptr</code>, 都有一个 “指向空” 的默认状态, 这就导致用户永远可能担心: 这个指针是不是空啊?</p>
<p>诚然, 这样似乎显得有些做作, 但这在一个超级大的多人协作的项目中, 是非常重要的. 你需要知道一个返回值的精确语义. 在大部分情况下, 多加一个 <code>if (ptr != nullptr)</code> 这样的判断并不会有太大的开销, 但是还是有很多性能非常重要的场景, 我们想要保证一个对象, 它维护了一个指向非空的指针, 同时维护了对象的所有权. 前者我们一般会用引用来直接代替 (引用的语义基本就是, 一个指向对象而非空的指针), 后者我们会用智能指针来管理. 那么两者兼顾呢? 似乎并没有一个工具能实现这一点. 事实上, C++ 中完成这个几乎注定是不可能的: 考虑一个这样的智能非空指针被移动之后的状态, 它不再持有所有权, 那么它的指针指向什么呢? 指向原来的对象将会带来垂悬引用, 这是极其危险的. 事实上, 除非编译器提供支持, 在编译期间做出静态检查, 否则我们永远无法跳出 “这个智能指针可能是空” 的难题, 要么通过高质量的代码和注释来清楚的告诉开发者 “这里一定不是空”, 要么就是强迫开发者使用前判断这个指针是否为空 (当然, 你也可以自己包一层智能指针, 所有涉及解引用的操作前插入检查, 如果为空则抛出异常, 相当于防御式编程). 这时候, rust 生命周期那套相关的东西, 以及强制的边界检查, 或许可能可以帮你避免 C++ 这边 “指针是不是空” 的心智负担, 而那些现代语言提供的语法糖 (比如结构化匹配 <code>match</code>), 也能有助于读者写出更有可读性、更易于维护的代码.</p>
<p>总之, 笔者强烈建议所有写 Modern C++ 的读者认真的去了解、体验一下 rust, 这一定会在你的编程生涯留下浓墨重彩的一笔.</p>
<h3 id="non-owning-views"><a href="#non-owning-views" class="headerlink" title="non-owning views"></a>non-owning views</h3><p><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/container/span">span</a>, <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/string/basic_string_view">string_view</a>, <a target="_blank" rel="noopener" href="https://www.rust-lang.org/">rust</a></p>
<p>其实就是 <code>std::span</code> 和 <code>std::string_view</code>. <code>std::span</code> 表示对于一个内存上连续区域的视图, 类似一个裸指针 + 区间长度, 而 <code>std::string_view</code> 则几乎就是 <code>std::span&lt;const char&gt;</code>. 需要注意 non-owning 不代表元素不能修改, 只是表明这个区间的元素不是由持有 <code>span</code> 或者 <code>string_view</code> 的人来析构, 保证在持有 <code>span</code> 和 <code>string_view</code> 时区间尚未被析构而已. 要彻底搞明白生命周期, 笔者还是建议读者亲自实践一下 <code>rust</code>.</p>
<p>笔者强烈建议尽可能用 <code>std::span</code> 替换所有的 <code>const std::vector&lt;T&gt; &amp;</code>, 用 <code>std::string_view</code> 替换一切的 <code>const std::string &amp;</code> (除非要求 null-terminated string). 这不仅是写法更加 modern 代码语义更精确, 它有时还能稍微提升一点代码性能, 并且比起裸指针, 提供了更好的封装.</p>
<blockquote>
<p>Remark: 我想要 <code>std::optional &lt;T&amp;&gt;</code>, 请参考后文 <a href="#optional--variant">optional 一章</a></p>
</blockquote>
<h2 id="type-safe"><a href="#type-safe" class="headerlink" title="type-safe"></a>type-safe</h2><p>Modern C++ 一个突出的特点是, 我们要保证类型安全, 避免危险的 <code>reinterpret_cast</code> 防止错误的内存访问. 而标准库也提供了不少容器来帮助我们实现这一点.</p>
<p>需要注意的是, 这些实现并不一定是最高效的, 相信读者自然能想出更加 memory efficient 的实现, 但是在大部分不是那么关心性能/memory 的场景, 尤其是短小的、几乎一定会被 “内联优化” 的函数里面, 以下这些标准库组件能给用户带来极大的便利.</p>
<h3 id="function"><a href="#function" class="headerlink" title="function"></a>function</h3><p><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/utility/functional/function">function</a>, <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/utility/functional/move_only_function/move_only_function">move_only_function</a></p>
<p><code>std::function</code> 传入一个函数签名作为模板参数, 其是裸函数指针的一个替代品, 但是更加灵活. 对于任何一个实现了 <code>operator()</code> 并且参数满足函数签名的一个对象, 我们称之为仿函数 (functor), 这是重载运算符给我们带来的便利. 如果这个对象满足可以被复制 (e.g. 函数指针, 常见的 lambda 函数等等), 那么 <code>std::function</code> 就可以对应的构造.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">std::function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; f; <span class="comment">// a function that takes in as an int as argument, return void</span></span><br><span class="line">f = [](<span class="type">int</span> x) &#123; <span class="keyword">return</span> x; &#125;; <span class="comment">// ok, discard return value</span></span><br><span class="line">f = [](<span class="type">float</span>) &#123;&#125;; <span class="comment">// ok, cast int to float when f is called</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">my_functor</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span>)</span> -&gt; <span class="type">void</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">f = my_functor&#123;&#125;; <span class="comment">// ok, functor can be invoked with an integer</span></span><br></pre></td></tr></table></figure>
<p>这自然不是免费的午餐, 代价是它类似函数指针, 会引入间接跳转的开销, 而且会拷贝/移动一份对象, 这中间可能涉及堆上内存的分配 (虽然 <code>gcc</code> 和 <code>clang</code> 都有做 small object optimization). 同时, 经典的 <code>std::function</code> 要求对象满足可以复制的条件, 这也并不是适用于所有对象 (比如持有类似 <code>std::unique_ptr</code> 类似的唯一资源的对象), 这是因为 <code>std::function</code> 为了保证本身可以复制所做出的牺牲.</p>
<p>幸运的是, 如果我们希望得到一个内部对象只可移动 (即转交所有权) 而不需要可复制的 <code>std::function</code>, 在 C++23 中有 <code>move_only_function</code> 可供选择.</p>
<p>事实上, <code>std::function</code> 内部需要持有一份对象, 这本身其实暗含了一种所有权, 也因此不可避免地需要构造/拷贝一份. 那么你可能会好奇了, 如果我们想有一种类似 <code>std::string_view</code> 或 <code>std::span</code> 那种视图一样不含所有权的结构, 应该怎么解决呢? 在 <code>C</code> 语言中, 常见的一种解决是传入一个内容指针 <code>context</code>, 以及一个回调的函数指针 <code>func</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">(<span class="type">void</span> *context, <span class="type">void</span>(*func)(<span class="type">void</span> *))</span> &#123;</span><br><span class="line">    func(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 C++ 中, 我们自然也可以自己实现一个类似的 <code>function_view</code>, 只需要在涉及右值的时候处理好生命周期即可 (我们不应该保存右值的视图, 因为 <code>rvalue</code> 可能是 <code>prvalue</code>, 在表达式结束后生命周期就结束被析构了). 这玩意网上的参考实现也很多, 这里就不多介绍了.</p>
<h3 id="optional-amp-variant"><a href="#optional-amp-variant" class="headerlink" title="optional &amp; variant"></a>optional &amp; variant</h3><p><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/utility/optional">optional</a>, <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/utility/variant">variant</a>, <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/utility/variant/get">get</a>, <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/utility/variant/get_if">get_if</a>, <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/utility/variant/visit">visit</a>, <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/utility/variant/holds_alternative">holds_alternative</a></p>
<blockquote>
<p>Remark: 需要 C++17</p>
</blockquote>
<ul>
<li><code>optional</code> 表示一个值可能是不存在, 也可能是存在的. 常见的场景是查找一个元素是否存在, 如果存在则返回这个元素, 否则返回一个特殊的状态, 表示不存在.</li>
<li><code>variant</code> 则表示存储的 <strong>可以且必须</strong> 是某几种值中的一个, 可以认为是加强版的 <code>optional</code>.</li>
</ul>
<p>可以看出, 这两个东西的存在就是为了取代 C 里面 <code>union</code> 的存在 (如果你还不知道, 可以自己先去了解一下). <code>union</code> 最大的问题, 是 RAII 资源管理相关的. 假如 <code>union</code> 里面的成员有析构函数, 那么在析构的时候, 应该调用哪个成员的析构函数呢? 处理不当, 非常容易造成资源泄露. 这时候, 我们就可以用到 <code>variant</code> 来管理了. 特别地, 如果只有 “有” 和 “没有” 两种状态, 那么我们可以用 <code>optional</code>, 它提供了更准确的语义.</p>
<p>当然, 虽然笔者一直提倡使用标准库, 但标准库也不是十全十美的. 比如 <code>optional</code> 里面, 标准禁止了其直接存引用类型例如 <code>std::optional&lt;int&gt;</code> (至少截至 C++23 如此). 仔细思考一下引用的语义是什么: 引用一个对象, 语义上等价于保证非空的指针解引用. 因此, <code>optional</code> 引用可以只存一个指针, 如果为空则表示 “没有引用”, 否则表示 “合法的引用”, 这完全是合情合理的. 它不会引入额外的开销 (甚至还能减少存储空间), 能提供更好的封装 (比起裸指针), 只可惜尚未进入标准库, 不过已经有 <a target="_blank" rel="noopener" href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2988r9.pdf">提案</a>.</p>
<p>对于 <code>optional</code>, 笔者推荐结合其成员函数 <code>.and_then</code>, <code>.or_else</code>, <code>.transform</code> 之类使用, 以获得 monad 的效果. 当然, 你也可以用 <code>if (auto opt = func())</code> 来分别实现 <code>optional</code> 非空和空的逻辑. <code>optional</code> 的解引用并没有做边界检查 (非空与 type safety 无关), 如果想要做检查, 请使用 <code>.value</code> 函数来获取内部得引用.</p>
<p>对于 <code>variant</code>, 笔者推荐使用 <code>std::visit</code> 来遍历类型. <code>std::hold_alternatives</code> 一般只适用于 <code>variant</code> 里面类型不多, 或者只需要特判是不是某一两种特殊的类型 case. 通过 <code>std::get</code> 来访问 <code>variant</code> 是 type-safe 的, 不用担心访问到错误类型.</p>
<p>在构造 <code>optional</code> 的时候, 可以用 <code>std::nullopt</code> 表示空, 或者直接花括号 <code>&#123;&#125;</code> 默认构造为空, 或者用一个对应存储的类型. 如果你想要给已有的一个 <code>optional</code> 更新它的值, 除了可以用 <code>=</code>, 也可以用 <code>emplace</code> 原地构造.</p>
<p><code>variant</code> 类似, 但是默认构造会调用 <code>variant</code> 里面第一次类型的构造函数 (不一定存在, 此时 <code>variant</code> 不可默认构造). 一般来说, 如果希望 <code>variant</code> 也存在某种类似的 “空” 的状态, 我们会用 <code>std::monostate</code>. 赋值和 <code>emplace</code> 类似 <code>optional</code>.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::variant&lt;std::monostate, <span class="type">int</span>, <span class="type">float</span>, std::string&gt; v &#123;&#125;; <span class="comment">// default monostate</span></span><br><span class="line">v = <span class="number">1</span>; <span class="comment">// ok, construct an int</span></span><br><span class="line">v.<span class="built_in">emplace</span>&lt;std::string&gt;(<span class="number">100</span>, <span class="string">&#x27;a&#x27;</span>); <span class="comment">// good, construct directly</span></span><br></pre></td></tr></table></figure>
<p>需要注意, <code>optional</code> 和 <code>variant</code> 不涉及堆内存分配, 所有数据都存在内部.</p>
<h3 id="any"><a href="#any" class="headerlink" title="any"></a>any</h3><p><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/utility/any">any</a>, <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/utility/any/any_cast">any_cast</a>, <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/utility/any/make_any">make_any</a></p>
<blockquote>
<p>Remark: 需要 C++17</p>
</blockquote>
<p>当你完全不确定可能的类型, 并且希望进一步增加未来的可拓展性, 完全 “擦除” 类型的时候, 你可以用 <code>void *</code>. 它直接把类型完全抹去了, 但对应的, 在调用处, 你为了获取其确切类型, 只能用 <code>std::any_cast</code> 一个一个去判断.</p>
<p><code>any_cast</code> 当传入的是 <code>std::any</code> 的指针的时候, 会返回一个指针, 如果为空表示 <code>any</code> 存储的不是这个类型的, 否则为指向对象的指针. 当传入的是 <code>std::any</code> 的左值或右值引用时, 如果不是这个类型则会抛出异常, 否则返回存储类型的值. <code>any_cast</code> 对于传入引用的情况, 会自动地选择返回时候是进行移动构造还是复制构造.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">std::any x;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">auto</span> *y = std::<span class="built_in">any_cast</span>&lt;<span class="type">int</span>&gt;(&amp;x)) &#123;</span><br><span class="line">    <span class="comment">// y is an int * in this case</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// x doesn&#x27;t store an int</span></span><br><span class="line">    <span class="keyword">if</span> (x.<span class="built_in">has_value</span>()) &#123;</span><br><span class="line">        <span class="comment">// x is not default, or nullptr, or .reset() called.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        x.<span class="built_in">reset</span>(); <span class="comment">// reset to a state of empty</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// this is a common error!</span></span><br><span class="line"><span class="comment">// 1.0 is implicitly cast to std::any &amp;&amp; in this case</span></span><br><span class="line"><span class="comment">// I think this is deficiency of std library......</span></span><br><span class="line">std::<span class="built_in">any_cast</span>&lt;<span class="type">int</span>&gt;(<span class="number">1.0</span>);</span><br></pre></td></tr></table></figure>
<p>在赋值一个 <code>any</code> 的时候, 除了常见的 <code>=</code> 之外, 你也可以类似 <code>optional</code> 和 <code>variant</code>, 使用 <code>emplace</code> 来原地构造, 减少潜在的移动和复制. 当然, 直接构造也可以用 <code>std::make_any</code>.</p>
<p>由于不确定对象的大小, <code>std::any</code> 的构造往往涉及堆内存的分配, 不过编译器一般都有 small object optimization.</p>
<h3 id="format"><a href="#format" class="headerlink" title="format"></a>format</h3><blockquote>
<p>Remark: 需要 C++20</p>
</blockquote>
<p>由于时间限制, 简单的介绍可以参考: <a href="/cpp20/" title="C++ 20 部分特性尝鲜">C++ 20 部分特性尝鲜</a>. 进阶请自行 cppref.</p>
<h2 id="类型和模板的魔法"><a href="#类型和模板的魔法" class="headerlink" title="类型和模板的魔法"></a>类型和模板的魔法</h2><p>模板是 C++ 的核心特性. 模板本身就是图灵完备的, 它的功能非常强大. 当和 C 语言的宏结合在一起的时候, 他几乎能创造一切的其他语言. 当然, 这稍微有点夸张了, 但是模板的力量是非常强大的. 结合 C++17 的折叠表达式, 以及 C++11 的 lambda 函数, 你可以写出非常优雅的代码.</p>
<h3 id="从-format-到模板推导"><a href="#从-format-到模板推导" class="headerlink" title="从 format 到模板推导"></a>从 format 到模板推导</h3><p><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/class_template_argument_deduction">CTAD</a>, <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/utility/format/format">format</a></p>
<p>模板推导是非常令人头疼的一部分. 举例:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add</span><span class="params">(std::vector&lt;T&gt; &amp;v, T x)</span> -&gt; <span class="type">void</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;i : v)</span><br><span class="line">        i += x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">f</span><span class="params">()</span> -&gt; std::vector&lt;<span class="type">int</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> x = std::vector&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; <span class="comment">// need C++ 17 deduction guide,</span></span><br><span class="line">                                   <span class="comment">// the compiler can deduce x as std::vector&lt;int&gt;</span></span><br><span class="line">    <span class="built_in">add</span>(x, <span class="number">1.0</span>); <span class="comment">// error, int and double are incompatible</span></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可能预期的是, <code>T</code> 能够自己转化为 <code>int</code> (带来的是 <code>1.0</code> 被 cast 为 <code>1</code>), 但是事实上, 这是不可能的. 遗憾的是, 这里的 <code>vector&lt;T&gt;</code> 和 <code>T</code> 共同参与了类型的推导, 因此 <code>T</code> 的类型不相同, 无法通过编译.</p>
<p>一个简单粗暴的解决方案是: 第二个参数也使用模板. 但这不是我们今天的主题. 事实上, 第二个类型可能也是依赖推导的模板类型, 比如 <code>list&lt;T&gt;</code>, 但是实现了类型转化函数或者有其他的特殊要求等等. 针对我们现在的场景, 我们希望类型推导完全由 <code>vector&lt;T&gt;</code> 来决定. 这时候, 我们可以用到 <code>std::type_identity_t</code>.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add</span><span class="params">(std::vector&lt;T&gt; &amp;v, std::<span class="type">type_identity_t</span>&lt;T&gt; x)</span> -&gt; <span class="type">void</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;i : v)</span><br><span class="line">        i += x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>他的原理是: <code>std::type_identity_t</code> 是一个模板别名, 实际是 <code>type_identity&lt;T&gt;::type</code>. 而这里作为类的成员类型, 并不会参与推导, 因此 <code>T</code> 的类型完全由 <code>vector&lt;T&gt;</code> 决定. 这样, 我们就可以正确的推导出 <code>T</code> 的类型了. 这部分实际非常复杂, 具体请参考 <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/class_template_argument_deduction">cppreference CTAD</a>. 这个在实践中的确被用到了, 可以参考 <code>std::format</code> 的实现.</p>
<p>在 <code>std::format</code> 中, <code>format_string</code> 是 <code>consteval</code> 的, 并且其含有实际 format 的类型作为模板参数, 这是为了编译期做出类型检查. 如果暴力的写, 它可能长这样:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ...Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">format</span><span class="params">(std::format_string&lt;Args...&gt; str, <span class="type">const</span> Args &amp;...args)</span> -&gt; std::string</span>;</span><br></pre></td></tr></table></figure>
<p>这里, 我们需要避免 <code>format_string</code> 参与模板类型推导, 因为 <code>Args</code> 完全是由入参决定的. 这时候, 注意观察 <code>format_string</code> 的定义:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="keyword">using</span> format_string = basic_format_string&lt;<span class="type">char</span>, <span class="type">type_identity_t</span>&lt;Args&gt;...&gt;;</span><br></pre></td></tr></table></figure>
<p>这意味着, 在 <code>using</code> 的内层, 它用到了 <code>type_identity_t</code> 来避免了推导, 笔者可以在这里把 <code>using</code> 直接理解为 <code>#define</code>, 即直接替换为 <code>basic_format_string&lt;char, type_identity_t&lt;Args&gt;...&gt;</code>.</p>
<h3 id="模板递归"><a href="#模板递归" class="headerlink" title="模板递归"></a>模板递归</h3><p><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/fold">fold expression</a></p>
<p>一般来说, 模板递归需要用到特化, 这样的代码非常啰嗦.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">f</span><span class="params">()</span> -&gt; <span class="type">void</span> </span>&#123;</span><br><span class="line">    <span class="comment">// end of recursion</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span>... _Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">f</span><span class="params">(_Tp &amp;&amp;t, _Args &amp;&amp;...args)</span> -&gt; <span class="type">void</span> </span>&#123;</span><br><span class="line">    <span class="built_in">g</span>(t); <span class="comment">// do something</span></span><br><span class="line">    <span class="built_in">f</span>(args...); <span class="comment">// recursive call</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>幸运的是, 在 C++17 中, 我们有了 <code>if constexpr</code>, 这在一定程度上能减轻我们的负担:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// helper class</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">end_of_recursion</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp = end_of_recursion, <span class="keyword">typename</span>... _Args&gt;</span><br><span class="line"><span class="keyword">auto</span> <span class="built_in">f</span>(<span class="type">const</span> _Tp &amp;t = &#123;&#125;, <span class="type">const</span> _Args &amp;...args) -&gt; <span class="type">void</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">constexpr</span> (std::is_same_v&lt;_Tp, end_of_recursion&gt;) &#123;</span><br><span class="line">        <span class="comment">// end of recursion</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">g</span>(t);</span><br><span class="line">        <span class="built_in">f</span>(args...);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然, 不要忘记了我们还有 lambda 函数和折叠表达式:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span>... _Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">f</span><span class="params">(<span class="type">const</span> _Tp &amp;t, <span class="type">const</span> _Args &amp;...args)</span> -&gt; <span class="type">void</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> fn = [](<span class="keyword">auto</span> &amp;&amp;t) &#123;</span><br><span class="line">        <span class="built_in">g</span>(t);</span><br><span class="line">    &#125;;</span><br><span class="line">    (<span class="built_in">fn</span>(t), ...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="模板-constexpr"><a href="#模板-constexpr" class="headerlink" title="模板 + constexpr"></a>模板 + constexpr</h3><p>模板还可以和强大的 <code>constexpr</code> 协同工作. 通过 <code>if constexpr</code>, 我们可以允许在输入模板参数不同的时候返回完全不一样的类型. 结合 <code>decltype</code>, 我们甚至可以更方便的写出根据某些常量来推导类型, 从而写出比 <code>std::conditional_t</code> 更加直观的代码.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> N&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">is_odd</span><span class="params">(<span class="type">int</span> n)</span> -&gt; <span class="type">bool</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n % <span class="number">2</span> == <span class="number">1</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> N&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(N == <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::string &#123;&#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">constexpr</span> (<span class="built_in">is_odd</span>(N)) &#123;</span><br><span class="line">        <span class="keyword">return</span> std::vector&lt;<span class="type">char</span>&gt; &#123;&#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> std::array&lt;<span class="type">char</span>, N&gt;&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">using</span> f_type = <span class="keyword">decltype</span>(<span class="built_in">f</span>&lt;N&gt;());</span><br><span class="line"></span><br><span class="line"><span class="comment">// use std::conditional_t</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">using</span> f_type2 = std::<span class="type">conditional_t</span>&lt;N == <span class="number">0</span>, std::string, std::<span class="type">conditional_t</span>&lt;<span class="built_in">is_odd</span>(N), std::vector&lt;<span class="type">char</span>&gt;, std::array&lt;<span class="type">char</span>, N&gt;&gt;&gt;;</span><br></pre></td></tr></table></figure>
<h3 id="模板-concept"><a href="#模板-concept" class="headerlink" title="模板 + concept"></a>模板 + concept</h3><p><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/sfinae">SFINAE</a>, <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/constraints">concept</a></p>
<p><code>SFINAE</code> 是一个老功能了. 他的全称是: <code>Substitution Failure Is Not An Error</code>. 他的作用是: 当模板参数推导失败时, 不会报错, 而是会继续尝试其他的模板. 例如:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">using</span> type = <span class="type">int</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="keyword">using</span> fallback = <span class="type">int</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">f</span><span class="params">(T)</span> -&gt; T::type </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">f</span><span class="params">(T)</span> -&gt; T::fallback </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">f</span>(A&#123;&#125;); <span class="comment">// ok, the first f is called</span></span><br><span class="line">    <span class="built_in">f</span>(B&#123;&#125;); <span class="comment">// ok, the second f is called</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里, 如果模板类型 <code>T</code> 没有 <code>type</code> 成员, 那么第一个 <code>f</code> 会被忽略, 而继续尝试第二个 <code>f</code>. 这就是 SFINAE 的作用. 其可以用于很多场景, 例如: 检查类型是否有某个成员, 检查类型是否满足某个特定的条件等等. 常见的搭配有 <code>std::enable_if_t</code>, <code>std::void_t</code> 等等. 如果 SFINAE 匹配到多个成功的模板, 会选择特化程度最厉害的, 这个说法一听就不是很严谨, 具体细节还是请参考 <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/sfinae">cppreference</a>.</p>
<p>然而, 在大部分情况下这样的代码可读性极差. 例如:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ensure T is an integral type, otherwise try other templates.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, std::<span class="type">enable_if_t</span>&lt;std::is_integral_v&lt;T&gt;, <span class="type">int</span>&gt; = <span class="number">0</span>&gt;</span><br><span class="line"><span class="keyword">auto</span> <span class="built_in">f</span>(T) -&gt; <span class="type">void</span> &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>幸运的是, C++20 的 <code>concept</code> 能够解决大部分这类问题, 其依然遵循的是 <code>SFINAE</code> 的原则, 但是使用更加直观的 <code>requires</code> 语句来明确指定模板的约束. <code>concept</code> 部分可以参考 <a href="https://darksharpness.github.io/cpp20">这篇文章</a>, 但是更推荐 <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/constraints">cppreference</a>.</p>
<p>对于上面那个例子, 可以简写为:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;std::integral T&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">f</span><span class="params">(T)</span> -&gt; <span class="type">void</span> </span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// another way</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">requires</span> std::integral&lt;T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">f2</span><span class="params">(T)</span> -&gt; <span class="type">void</span> </span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>无论如何, 可读性都比无 <code>concept</code> 的 <code>SFINAE</code> 强太多了. 关于 <code>concept</code> 的四种写法, 除了 <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/concepts">cppreference</a>, 也可以参考 <a href="/cpp20/" title="C++ 20 部分特性尝鲜">C++ 20 部分特性尝鲜</a>.</p>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/">C++</a><a class="post-meta__tags" href="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">基础知识</a></div><div class="post-share"><div class="social-share" data-image="https://s3.bmp.ovh/imgs/2025/04/07/52e46b1c151e1b77.jpg" data-sites="facebook,twitter,wechat,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://vdse.bdstatic.com//192d9a98d782d9c74c96f09db9378d93.mp4" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2023/02/17/bNFrOglBCW6ZaUq.png" alt="Wechat"/></a><div class="post-qr-code-desc">Wechat</div></li></ul></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/env-shell/" title="My Windows Terminal Configuration"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s3.bmp.ovh/imgs/2024/01/19/1d88e2436576d55c.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">My Windows Terminal Configuration</div></div><div class="info-2"><div class="info-item-1">This is the first time I write my BLOG in English.</div></div></div></a><a class="pagination-related" href="/torch/" title="dispatcher is all you need"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s3.bmp.ovh/imgs/2024/11/27/3e28dd3239526ce1.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">dispatcher is all you need</div></div><div class="info-2"><div class="info-item-1">pytorch 写的是真的好. 本文会简单分析 torch 的 dispatcher, 以及实现在 C++ 侧实现自定义的 torch extension.</div></div></div></a></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="giscus-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2023/01/28/SnEi2v9sdczUuyG.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">DarkSharpness</div><div class="author-info-description">逸一时，误一世!</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">36</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">24</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">25</div></a></div><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/DarkSharpness" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://space.bilibili.com/396961987" target="_blank" title="Bilibili"><i class="iconfont icon-bilibili"></i></a><a class="social-icon" href="https://www.zhihu.com/people/darksharpness" target="_blank" title="Zhihu"><i class="iconfont icon-zhihu"></i></a><a class="social-icon" href="https://music.163.com/#/user/home?id=8335592513" target="_blank" title="Cloudmusic"><i class="fa-solid fa-music"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">we will go certainly, till the end !</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8E%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%88%B0%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC"><span class="toc-number">1.</span> <span class="toc-text">从值类型到类型推导</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A6%E5%80%BC%E5%92%8C%E5%8F%B3%E5%80%BC"><span class="toc-number">1.1.</span> <span class="toc-text">左值和右值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A8%E5%AF%BC%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%98%AF%E4%B8%80%E4%B8%AA%E5%BC%95%E7%94%A8"><span class="toc-number">1.2.</span> <span class="toc-text">推导的类型是一个引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A8%E5%AF%BC%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%98%AF%E4%B8%80%E4%B8%AA%E6%8C%87%E9%92%88"><span class="toc-number">1.3.</span> <span class="toc-text">推导的类型是一个指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A8%E5%AF%BC%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%98%AF%E4%B8%80%E4%B8%AA%E9%80%9A%E7%94%A8%E5%BC%95%E7%94%A8"><span class="toc-number">1.4.</span> <span class="toc-text">推导的类型是一个通用引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A8%E5%AF%BC%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%98%AF%E4%B8%80%E4%B8%AA%E5%80%BC%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.5.</span> <span class="toc-text">推导的类型是一个值类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%B9%E8%A7%92%E6%96%99"><span class="toc-number">1.6.</span> <span class="toc-text">边角料</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#auto-%E6%8E%A8%E5%AF%BC"><span class="toc-number">1.7.</span> <span class="toc-text">auto 推导</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7"><span class="toc-number">2.</span> <span class="toc-text">语言特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#inline-%E5%92%8C-static"><span class="toc-number">2.1.</span> <span class="toc-text">inline 和 static</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#using"><span class="toc-number">2.2.</span> <span class="toc-text">using</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E5%8C%96%E7%BB%91%E5%AE%9A"><span class="toc-number">2.3.</span> <span class="toc-text">结构化绑定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#if-switch"><span class="toc-number">2.4.</span> <span class="toc-text">if&#x2F;switch</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#constexpr-consteval-constinit"><span class="toc-number">2.5.</span> <span class="toc-text">constexpr&#x2F;consteval&#x2F;constinit</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#constexpr"><span class="toc-number">2.6.</span> <span class="toc-text">constexpr</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#consteval"><span class="toc-number">2.7.</span> <span class="toc-text">consteval</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#constinit"><span class="toc-number">2.8.</span> <span class="toc-text">constinit</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#memory-safe"><span class="toc-number">3.</span> <span class="toc-text">memory-safe</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#unique-ptr"><span class="toc-number">3.1.</span> <span class="toc-text">unique_ptr</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#shared-ptr"><span class="toc-number">3.2.</span> <span class="toc-text">shared_ptr</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#smart-pointer-%E7%9A%84%E9%81%97%E6%86%BE"><span class="toc-number">3.3.</span> <span class="toc-text">smart pointer 的遗憾</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#non-owning-views"><span class="toc-number">3.4.</span> <span class="toc-text">non-owning views</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#type-safe"><span class="toc-number">4.</span> <span class="toc-text">type-safe</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#function"><span class="toc-number">4.1.</span> <span class="toc-text">function</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#optional-amp-variant"><span class="toc-number">4.2.</span> <span class="toc-text">optional &amp; variant</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#any"><span class="toc-number">4.3.</span> <span class="toc-text">any</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#format"><span class="toc-number">4.4.</span> <span class="toc-text">format</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%92%8C%E6%A8%A1%E6%9D%BF%E7%9A%84%E9%AD%94%E6%B3%95"><span class="toc-number">5.</span> <span class="toc-text">类型和模板的魔法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E-format-%E5%88%B0%E6%A8%A1%E6%9D%BF%E6%8E%A8%E5%AF%BC"><span class="toc-number">5.1.</span> <span class="toc-text">从 format 到模板推导</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E9%80%92%E5%BD%92"><span class="toc-number">5.2.</span> <span class="toc-text">模板递归</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF-constexpr"><span class="toc-number">5.3.</span> <span class="toc-text">模板 + constexpr</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF-concept"><span class="toc-number">5.4.</span> <span class="toc-text">模板 + concept</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/lily/" title="Lily White 在美国"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2025/07/11/54pNUfdTJlqFnxL.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Lily White 在美国"/></a><div class="content"><a class="title" href="/lily/" title="Lily White 在美国">Lily White 在美国</a><time datetime="2025-07-10T16:26:11.000Z" title="发表于 2025-07-11 00:26:11">2025-07-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/env-2/" title="My environment config v2.0"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2025/06/27/MW5js87vLXJgklo.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="My environment config v2.0"/></a><div class="content"><a class="title" href="/env-2/" title="My environment config v2.0">My environment config v2.0</a><time datetime="2025-06-23T08:38:25.000Z" title="发表于 2025-06-23 16:38:25">2025-06-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blockwithhold/" title="Block Withholding Attack"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s3.bmp.ovh/imgs/2025/06/04/56a990d5e50ecb5d.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Block Withholding Attack"/></a><div class="content"><a class="title" href="/blockwithhold/" title="Block Withholding Attack">Block Withholding Attack</a><time datetime="2025-05-26T06:47:33.000Z" title="发表于 2025-05-26 14:47:33">2025-05-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/env-shell/" title="My Windows Terminal Configuration"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s3.bmp.ovh/imgs/2024/01/19/1d88e2436576d55c.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="My Windows Terminal Configuration"/></a><div class="content"><a class="title" href="/env-shell/" title="My Windows Terminal Configuration">My Windows Terminal Configuration</a><time datetime="2025-05-02T09:22:43.000Z" title="发表于 2025-05-02 17:22:43">2025-05-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/cppModern/" title="Effective Modern C++"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s3.bmp.ovh/imgs/2025/04/07/52e46b1c151e1b77.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Effective Modern C++"/></a><div class="content"><a class="title" href="/cppModern/" title="Effective Modern C++">Effective Modern C++</a><time datetime="2025-04-07T01:42:39.000Z" title="发表于 2025-04-07 09:42:39">2025-04-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/torch/" title="dispatcher is all you need"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s3.bmp.ovh/imgs/2024/11/27/3e28dd3239526ce1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="dispatcher is all you need"/></a><div class="content"><a class="title" href="/torch/" title="dispatcher is all you need">dispatcher is all you need</a><time datetime="2024-11-26T18:08:43.000Z" title="发表于 2024-11-27 02:08:43">2024-11-27</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2025 By DarkSharpness</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">DarkSharpness welcomes you!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button><button id="blur_toggle" type="button" title="切换背景模糊"><i class="fas fa-cloud"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.isShuoshuo
  const option = null

  const getGiscusTheme = theme => theme === 'dark' ? 'dark' : 'light'

  const createScriptElement = config => {
    const ele = document.createElement('script')
    Object.entries(config).forEach(([key, value]) => {
      ele.setAttribute(key, value)
    })
    return ele
  }

  const loadGiscus = (el = document, key) => {
    const mappingConfig = isShuoshuo
      ? { 'data-mapping': 'specific', 'data-term': key }
      : { 'data-mapping': (option && option['data-mapping']) || 'pathname' }

    const giscusConfig = {
      src: 'https://giscus.app/client.js',
      'data-repo': 'DarkSharpness/DarkSharpness.github.io',
      'data-repo-id': 'MDEwOlJlcG9zaXRvcnkzNDE1Nzc5NDY=',
      'data-category-id': 'DIC_kwDOFFwQ2s4CT2jG',
      'data-theme': getGiscusTheme(document.documentElement.getAttribute('data-theme')),
      'data-reactions-enabled': '1',
      crossorigin: 'anonymous',
      async: true,
      ...option,
      ...mappingConfig
    }

    const scriptElement = createScriptElement(giscusConfig)

    el.querySelector('#giscus-wrap').appendChild(scriptElement)

    if (isShuoshuo) {
      window.shuoshuoComment.destroyGiscus = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }
  }

  const changeGiscusTheme = theme => {
    const iframe = document.querySelector('#giscus-wrap iframe')
    if (iframe) {
      const message = {
        giscus: {
          setConfig: {
            theme: getGiscusTheme(theme)
          }
        }
      }
      iframe.contentWindow.postMessage(message, 'https://giscus.app')
    }
  }

  btf.addGlobalFn('themeChange', changeGiscusTheme, 'giscus')

  if (isShuoshuo) {
    'Giscus' === 'Giscus'
      ? window.shuoshuoComment = { loadComment: loadGiscus }
      : window.loadOtherComment = loadGiscus
    return
  }

  if ('Giscus' === 'Giscus' || !true) {
    if (true) btf.loadComment(document.getElementById('giscus-wrap'), loadGiscus)
    else loadGiscus()
  } else {
    window.loadOtherComment = loadGiscus
  }
})()</script></div><script src="/js/meting.min.js"></script><script src="/js/user.js"></script><div class="aplayer no-destroy" data-volume="0.1" data-id="8149615949" data-autoplay="false" data-server="netease" data-type="playlist" data-loop="all" data-order="random" data-fixed="true" mutex="true"> </div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script>(() => {
  const destroyAplayer = () => {
    if (window.aplayers) {
      for (let i = 0; i < window.aplayers.length; i++) {
        if (!window.aplayers[i].options.fixed) {
          window.aplayers[i].destroy()
        }
      }
    }
  }

  const runMetingJS = () => {
    typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()
  }

  btf.addGlobalFn('pjaxSend', destroyAplayer, 'destroyAplayer')
  btf.addGlobalFn('pjaxComplete', loadMeting, 'runMetingJS')
})()</script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["link[rel=\"canonical\"]","meta[property=\"og:image\"]","meta[property=\"og:title\"]","meta[property=\"og:url\"]","head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => fn())
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      pjax.loadUrl('/404.html')
    }
  })
})()</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>