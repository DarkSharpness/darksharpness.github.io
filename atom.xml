<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>DarkSharpness&#39;s Dungeon</title>
  
  <subtitle>Home to Everyone</subtitle>
  <link href="http://darksharpness.github.io/atom.xml" rel="self"/>
  
  <link href="http://darksharpness.github.io/"/>
  <updated>2025-09-17T17:42:55.685Z</updated>
  <id>http://darksharpness.github.io/</id>
  
  <author>
    <name>DarkSharpness</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>mini-sglang</title>
    <link href="http://darksharpness.github.io/mini-sglang/"/>
    <id>http://darksharpness.github.io/mini-sglang/</id>
    <published>2025-07-28T15:44:08.000Z</published>
    <updated>2025-09-17T17:42:55.685Z</updated>
    
    <content type="html"><![CDATA[<p>封面出自笔者非常喜欢的一个乐队的新专 <a href="https://www.galneryus.jp/music/albums?item=the_stars_will_light_the_way">The stars will light the way</a>, <del>放一张飞龙在这里寓意着你也可以写一个性能非常强甚至超过 SGLang 和 vLLM 的框架</del></p><p>在 7 月初, 笔者在自己的项目中需要用到一个高性能的 LLM serving engine. 但是现有的开源 SOTA 比如 sglang, TensorRT-LLM, vllm 什么的, 过于重量级了, 笔者改起来无从下手. 于是决定了自己从头写一个 LLM 框架, 在这过程中也顺便能加深对于 serving engine 不同组件的理解. 于是就有了现在这个项目.</p><p>笔者最早是在六月最后两三天的时候开始写的, 中途因为去 OSDI 开会基本是中断了一周 (倒时差差点干死了笔者). 而且一开始这个框架也不是作为 serving engine. 总之实际花在上面的时间大约只有三周, 但是三周时间足以支持很多高性能 serving engine 所需要的核心 feature 了. 在写这个所谓 mini sglang 的过程中, 笔者自然也是参考了不少 sglang 的 codebase, 不过更多时候笔者还是自己 design, 作为一个做 system 的人, 自己 design 一个 system 再去不断 refine 才是最爽的.</p><p>废话不多说, 直接进入正题. 本文还会顺带介绍一些 LLM serving 中非常著名的 paper, 其中的 idea 现在看来并不复杂, 实现起来也没有很多细节.</p><h2 id="Model-Structure"><a href="#Model-Structure" class="headerlink" title="Model Structure"></a>Model Structure</h2><blockquote><p>Remark: 这部分笔者花了一周, 当然还有一些杂七杂八的 profiling 占据了不少时间片</p></blockquote><p>模型这部分是最 trivial 的, 理论上知道了模型的架构都非常好写, 但实操的时候还是有不小的细节要注意, 特别是 TP (tensor-parallism) 相关的.</p><p>从最外层的角度来看, 一个 LLM (Llama 这种) 需要这些 layer:</p><ol><li>Embedding layer (Embed)</li><li>Attention layer (Attn)</li><li>Feed forward network (FFN)</li></ol><h3 id="How-to-batch"><a href="#How-to-batch" class="headerlink" title="How to batch"></a>How to batch</h3><p>在 LLM serving 中, 一个比较重要的问题是, 我们怎么进行 batching, 这决定了后面我们搭建的 model 的结构, 以及 scheduler 的预处理部分.</p><p>首先, 在 LLM online serving 的场景中, 我们会有很多的请求 (Req) 到来, 对于每个 Req, 它的输入是一些文字, 我们会首先把这些 text tokenize 变成 tokens, 类似一个 list of int.</p><p>在没有 batching 的时候, 我们只需要把输入 tokens 喂给模型, 每次把新生成的 token append 到之前的 tokens 后面, 然后把新的 tokens 一起喂给模型.</p><p>我们可以简单的把 LLM 看作一个 function $f$, 那么实际上我们输入就是 $x$, 输出 $y=f(x)$. 其中 $x$ 的维度是 $[\text{seq-len}]$, 每个元素的取值范围是 $0 \sim \text{vocab-size}$, $y$ 的维度是 $[1]$, 每个元素的取值范围同 $x$. 下一轮的输入就是把 $y$ 拼接到 $x$ 的后面, 维度是 $\text{seq-len} + 1$.</p><p>在有 batching 的时候, 传统 DL model 的做法是新增一个维度, 在我们的例子里就是输入 $x$ 的维度变成 $[2, \text{seq-len}]$. 但是在 LLM serving 中, 不同请求的输入的长度是不一样的. 这时候, 一个比较暴力的做法就是 padding, 即我们取输入长度为 $\max(\text{seq-len})$, 维度就是 $[2, \max(\text{seq-len})]$, 但这样几乎不可避免会带来一些计算上的浪费, 尤其是一些动态性非常强的 workload (既有长输入的请求, 也有短输入的请求).</p><p>这时候, 一个比较优雅的 solution 是: 我们把输入摊平. 假设输入有 $x<em>1, \cdots, x_n$, 他们的长度分别是 $l_1, \cdots, l_n$, 那么我们把它拼起来, 直接合成一个大 $X$, 它的长度是 $\sum</em>{i=1}^{n} l_i$. 这样, 我们就没有一点计算是多余的.</p><p>这个方法看起来很简单, 实际上会有一些工程上的 trick. 幸运的是, LLM 常见的 kernel, 大部分很容易就能支持这个操作. 比如矩阵乘法操作 $A \times B$, 本质上是对于 $A$ 的行向量和 $B$ 的每个列向量做内积. 这时候, 你把不同请求的矩阵 $A_i$, 沿着列的维度拼接起来得到形如 $[A_1^T, \cdots, A_n^T]^T$ 的 $A$, 那么 $A \times B$. 此时等价于对于每个 $A_i$ 分别做乘法, 即 $[A_1^T B, \cdots, A_n^T B]$, 这是分块举证告诉我们的.</p><p>唯一比较 tricky 的部分是 attention kernel. 它是一个取决于每个请求 tokens 数量的 kernel, 并不像 linear kernel, 没有良好的线性性质. 不过幸运的是, 伟大的 flash attention 和 flashinfer 都提供了类似 <code>flash_attn_with_varlen</code> 的接口, 支持直接用拼接起来的 $q, k, v$ 计算. 具体来说, 我们把沿着 $\text{seq-len}$ 维度拼起来的 $q, k, v$, 以及每一段的长度以特定格式喂给 flash attention 或者 flashinfer 的接口, 即可得到每个 query 对应的输出了.</p><p>因此, 我们的 batching 思路就非常简单: 首先选出一些请求, 然后把这些请求的 tokens 拼接起来, 直接作为模型的输入, 最后得到输出后再把结果拆开来. (当然实际上我们有 KV Cache, 因此我们只需要把每个请求不在 KVCache 中的那部分后缀 tokens, 对于 decode 每个请求的这部分 tokens 长度是 1).</p><h3 id="Embedding-Layer"><a href="#Embedding-Layer" class="headerlink" title="Embedding Layer"></a>Embedding Layer</h3><p>首先分析单机的 Embedding layer. Embedding layer 的作用是, 把 tokenize 后的 ID (可以理解为 list of int) 转换为 embedding vector. 在单机上, 这其实就是一个根据 token ID 的值, 从一个 embedding vector list 中索引并且复制到输出的 tensor 里面.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="comment"># shape info:</span></span><br><span class="line"><span class="comment"># x: [n]</span></span><br><span class="line"><span class="comment"># weight [vocab_size, d]</span></span><br><span class="line"><span class="comment"># y: [n, d]</span></span><br><span class="line">y = F.embedding(x, weight)</span><br><span class="line"><span class="keyword">return</span> y</span><br></pre></td></tr></table></figure><p>在 TP 的时候, 我们的做法是把不同的 index 的 vector 分配到不同的机器上. 比如 TP=2 的时候, 我们会把前一半的 embedding vector 放在第一个 GPU 上, 后一半的 embedding vector 放在第二个 GPU 上. 假如我们要的 token id 比 $\frac{\text{vocab-size}}{2}$ 要小, 那么我们会从第一个 GPU 上取, 否则我们会从第二个 GPU 上取. 需要注意的是, 我们并没有切开 weight 的 $d$ 维度, 这也意味着每一个 vector 要么不在机器上, 要么就是完整的在一台机器上, 不会存在某个 token id 对应的 vector 横跨两台机器. 一个参考实现如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mask = (x &gt;= vocab_start_idx) &amp; (x &lt; vocab_end_idx)</span><br><span class="line">x = mask * (x - vocab_start_idx)</span><br><span class="line">y = F.embedding(x, weight)</span><br><span class="line">y = mask.unsqueeze(<span class="number">1</span>) * y</span><br><span class="line">all_reduce(y)</span><br><span class="line"><span class="keyword">return</span> y</span><br></pre></td></tr></table></figure><p>在这段代码中, 每个 TP rank 存的是 $[\text{vocab-start-idx}, \text{vocab-end-idx})$ 这一段的 vector, 因此我们会 mask 掉其他的 embedding 操作, 对于不在当前 rank 的 indexing, 我们会将值 mask 为 0. 最后, 我们会对输出做 all reduce. 因此最后我们要的值一定存在且只存在于其中某个 rank 上, 所以最后的加和就是正确的 embedding 的值.</p><h3 id="FFN"><a href="#FFN" class="headerlink" title="FFN"></a>FFN</h3><p>FFN 本质就是两个 linear 操作加上一个激活函数, 激活函数大部分也都是线性的, 所以这里仅讨论 linear 部分的处理, 即矩阵乘法. 在使用了摊平 batch 的方法后, 输入部分就是一个 $[n, d]$ 的二维矩阵. 对于非 TP 的情况, 我们直接用 torch 自带的 linear 函数即可.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import torch.nn.functional as F</span><br><span class="line"><span class="comment"># shape info:</span></span><br><span class="line"><span class="comment"># x: [n, d]</span></span><br><span class="line"><span class="comment"># up_proj [D, d]</span></span><br><span class="line"><span class="comment"># down_proj [d, D]</span></span><br><span class="line"><span class="comment"># y: [n, D]</span></span><br><span class="line"><span class="comment"># z: [n, d]</span></span><br><span class="line">y = F.linear(x, up_proj)</span><br><span class="line">z = F.linear(y, down_proj)</span><br><span class="line"><span class="built_in">return</span> y</span><br></pre></td></tr></table></figure><p>需要注意的是, <code>F.linear</code> 传入的 weight 是一个事先就已经转置好的矩阵, 这样矩乘效率会更高一点.</p><p>在 TP 的时候, 我们每一层的输入输出在每个 TP rank 上都是一样且完整的 $[n, d]$. 在过 FFN 的时候, 我们会把 intermediate dimension $D$ 拆开 (一般来说 $D &gt; d$, 所以叫做 <code>up_projection</code> 和 <code>down_projection</code>). 对于正常的 TP, 我们都会要求 GPU 总数量 $N$ 可以整除 $D$. 此时, 每个 $TP_rank$ 会持有一部分 <code>up_proj</code> $[\frac{D}{N}, d]$ 以及 <code>down_proj</code> $[d, \frac{D}{N}]$.</p><p>在经过 <code>up_proj</code> 之后, 每个 rank 只会持有一部分权重 $y_i$, 维度 $[n, \frac{D}{N}]$, 需要将所有 $GPU$ 的 $y$ 拼起来才能得到完整的 $y$. 但是, 为了减少通信次数, 我们可以将不完整的权重先过完 <code>down_proj</code>. 此时, 所有 rank 上得到的 $z_i$ 维度都是 $[n, d]$, 而根据分块矩阵乘法的知识可知, 此时完整的 $z$ 应该是所有的 $z_i$ 的和, 因此我们需要经过 all-reduce 操作. 这里的 all-reduce 是常见 collective operation 的一种, 详情可见 <a href="https://docs.nvidia.com/deeplearning/nccl/user-guide/docs/usage/collectives.html">NCCL 对于 collective operation 的介绍</a>.</p><p>下面是从 PyTorch 教程里面偷来的 Megatron 关于 TP 的 MLP (也就是 FFN) 的分析, 图比较直观, 读者可以自行用 $N = 2$ 的例子来验证最后输出的值 $Z$ 确实应该是 $\sum Z_i$, 这也是分块矩阵乘法告诉我们的.</p><p><img src="https://docs.pytorch.org/tutorials/_images/megatron_lm.png" alt="TP from megatron"></p><h3 id="Attention-Layer"><a href="#Attention-Layer" class="headerlink" title="Attention Layer"></a>Attention Layer</h3><p>Attention 正如前面讲过的, 我们可以把 batch 里面的 $q, k, v$ 一起喂给对应的 flash attention 或 flashinfer 实现的 kernel, 这里我们把具体 kernel 实现叫做 attention backend.</p><h4 id="KVCache"><a href="#KVCache" class="headerlink" title="KVCache"></a>KVCache</h4><p>在 LLM serving 中, 一个重要的优化是 KV-Cache, 这是因为 causal masking 使得每个 token 的 $K$ 和 $V$ 只和过去的 token 有关.</p><p>具体来说, 为了生成第 $i$ 个 token, 我们需要过去的 $[q_i k_1, q_i k_2, \cdots, q_i k_i]$, 对它做 softmax 后, 再和 $[v_1, \cdots, v_i]$ 做内积. 实际我们依赖的是 $q_i$ 和 $k_1, \cdots k_n$ 和 $v_1 \cdots v_n$, 在这个过程中 $q_i, k_i, v_i$ 都是根据这轮输入新生成的. $k_i$ 和 $v_i$ 只会依赖过去的 token (i.e. 下标不超过 $i$ 的结果的影响), 因此我们可以把对应的 $k_i$ 和 $v_i$ 给 cache 起来.</p><p>这么讲可能会非常抽象, 笔者在这里强烈建议读者手推一下 KVCache 的原理, 本文就不过多赘述了.</p><p>如果你暂时不理解, 那也没关系. 作为一个 system 人, 你只需要知道: 完整的计算第 $i$ 个 token, 需要过去前 $i - 1$ 轮的 $k$ 和 $v$ 向量, 以及这一轮根据输入 token 新生成的 $k<em>i$ 和 $v_i$ 和 $q_i$. 因此, 一个 naive 的 idea 就是: 我们可以把过去的 $k$ 和 $v$ 全部都收集起来. 在第一次收到一个长度为 $n$, 我们可以一口气生成 $k_1, \cdots, k_n$ 以及 $v_1, \cdots, v_n$. 在生成完第 $n$ 个 token, 开始生成第 $n + 1$ 个 token 的时候, 因为过去的 $k$ 和 $v$ 我们都 cache 住了, 我们只需要重新生成 $k</em>{n+1}$, $q<em>{n+1}$ 和 $v</em>{n+1}$, 然后计算 attention.</p><p>可以看到, 我们现在计算 attention 分为了两个阶段:</p><ol><li>预处理前 $n$ 个 token 的 $k$ 和 $v$, 同时生成第 $n$ 个 token.</li><li>生成新的 $k<em>{n + 1}$ 和 $v</em>{n+1}$, 同时生成第 $n + 1$ 个 token.</li></ol><p>第一阶段就被称作 <strong>Prefill</strong>, 而第二个阶段被称作 <strong>Decode</strong>. 很显然, 第二个阶段的计算量要远远小于第一个阶段.</p><h4 id="Paged-KVCache"><a href="#Paged-KVCache" class="headerlink" title="Paged KVCache"></a>Paged KVCache</h4><p>根据前文分析, 我们利用了 causal mask + attention 的数学性质, 可以用 KVCache 来加速生成 $token$. 我们也因此分成了 Prefill 和 Decode 两个阶段.</p><p>然而, 这带来了一些新的问题: decode 的时候, 常规的 attention 实现, 比如 <code>flash_attn_with_varlen</code>, 要求 $k$ 和 $v$ 存储是连续的. 但是我们 $k_i$ 和 $v_i$ 的时候都是一个一个生成的. 类比 C++, 我们每次会新增一个元素, 并且我们要求元素连续存储. 你会想到什么: <code>std::vector</code>! 只要用倍增的方法, 我们就可以解决了, 至多一倍的浪费.</p><p>但是呢, 事情并没有这么简单, 管理内存, 一个逃不开的问题就是: 内存碎片化. 一旦运行久了, 就容易出现碎片空余总和可能有 $n$ 那么多, 但你找不到一块连续的 $n$… 传统算法中有数不尽的相关 memory management 的 paper, 开源社区也有各种 malloc 实现, 问题看起来陷入死局.</p><p>事实上, 类似的 memory management 难题不仅在用户态程序存在, 对于操作系统 OS 也是存在的. 那么, OS 是怎么缓解这个问题的呢? 答案是 paging. 在通常的操作系统中, 我们给每个 4096 byte 对齐的连续空间称作一个 page, 然后会用页表来管理内存. 这样的好处是, 任何是 4096 整数倍的资源分配, 我们都可以保障 0 内存浪费. 同时, 页表也保证了 virtual address 看起来是连续的, 即使实际读写的 physical page 大概率并不连续.</p><blockquote><p>笔者注: 实际维护 $N$ 个页的页表还有一个 O(N) 的表的开销, 但是它的开销反比于 page size, 因此服务器内存管理有时候也会借助 huge page, 一个 page 占 2M 甚至 1G, 来减小页表管理的 memory 和 TLB overhead.</p></blockquote><p>这对我们的启发是, 我们也可以用 paging 的思想来节约显存 (GPU 的内存). 从硬件的角度, 我们可以修改 GPU 的 page table 实现. 当然, 调用硬件底层 API 很多时候相比软件方法还是会过于晦涩, 且不具有可拓展性. 在经典的 MLsys paper vLLM 中, 我们使用的就是软件管理的 paged KVCache. 具体来说, 我们一开始开好一个 memory pool, 在 attention kernel 里面读取 $k<em>i$ 和 $v_i$ 的值的时候, 先通过一个 table $t$ 查找的 $k$ 和 $v$ 在 memory pool 中真实存储的位置, 这类似于一个二级索引操作, 即 $k</em>{t[i]}$ 和 $v_{t[i]}$.</p><p>当然, 我们也可以自主调节 page size. 在 LLM serving 中, page size = $n$ 意味着对于任意 $n \cdot k, n \cdot k + 1, \cdots, n \cdot k + n - 1$, 这些 token 真实存储的位置必须是连续的. 不过, 在 LLM inference kernel 高度优化的今天, paging 带来的 overhead 以及可以几乎忽略不计了, 不同 page size 之间的性能差异已经很小了.</p><h4 id="Radix-KVCache"><a href="#Radix-KVCache" class="headerlink" title="Radix KVCache"></a>Radix KVCache</h4><p>我们已经讨论了 KVCache, 以及 paged KVCache. 重新回顾一下 KVCache, 对于每个 $k_i$ 和 $v_i$, 它只会依赖于过去的 $k$ 和 $v$, 也就是由过去 $i$ 个 token 生成的 $k$ 和 $v$. 也就是说, 第 $i$ 个 $k_i, v_i$ 会依赖于第 $1, \cdots, i$ 个token.</p><p>那么, 我们是不是可以复用一些缓存呢? 既然每个 $k$ 和 $v$ 都是 condition on 它的前缀, 那么只要两个请求, 它们的前缀是一样的, 那么它们生成的 $k$ 和 $v$ 也一定是一样的. (不过输出之前, 需要 sampling, 会引入一些随机性, 导致生成的第 $i$ 个 token 对两个请求可能是不一样的). 这就是 Prefix Caching.</p><p>实际上, 我们都不需要前缀完全 match, 只要我们输入的前缀有一部分匹配到了过去某个请求前缀 tokens, 那我们就可以复用这部分. 例如, 假如一个请求前缀 tokens 是 $[0, 1, 2, 3]$, 过去某个请求的前缀 tokens 是 $[0, 1, 2, 4, 3]$, 那我们可以复用其中 $[0, 1, 2]$ 的部分, 从而尽可能减少计算量.</p><p>关于这一个优化, 一个比较著名的工作是 SGLang, 可惜居然没中 OSDI, 有点可惜.</p><h4 id="TP-attention"><a href="#TP-attention" class="headerlink" title="TP attention"></a>TP attention</h4><p>在标准的 TP 中, attention 的计算类似 FFN, 也会拆分到不同 rank 上. attention 的操作比较简单, 它的结果类似 FFN, 也是不同的部分和做 reduce (求和) 操作. 在这里, 我们是对不同的 attention head 计算出来的值作 reduce. 对于 GQA 的模型, 这里就要拆分 key-value head. 比如 Llama-3.1-70B 的模型有 8 个 key-value head, GQA ratio 是 8, 那么开启 TP=4, 就是每个 rank 负责 2 个 key-value attention 的计算 (GQA ratio 不会改变, 依然是每个 key-value attention 对应 8 个 query). 最后在每个 rank 都计算完后, 我们会执行 all-reduce, 把不同 rank 上的部分和都加起来.</p><h2 id="Backend-engine"><a href="#Backend-engine" class="headerlink" title="Backend engine"></a>Backend engine</h2><p>后端的 engine, 对应的是 sglang 中的 TP worker. 一个 engine, 它需要做的事情就是执行 forward 操作. 当然, 现代的 LLM 往往还需要支持一些更加复杂的操作, 比如 cuda graph, 又比如 TP 的通信的初始化和管理, 还有 attention metadata 的处理, 以及模型权重的加载等杂七杂八的东西.</p><p>这里主要讨论两个, 一个是 attention metadata 的处理, 另一个是 cuda graph.</p><h3 id="Attention-Metadata"><a href="#Attention-Metadata" class="headerlink" title="Attention Metadata"></a>Attention Metadata</h3><h3 id="CUDA-Graph"><a href="#CUDA-Graph" class="headerlink" title="CUDA Graph"></a>CUDA Graph</h3><h2 id="Overlap-Scheduler"><a href="#Overlap-Scheduler" class="headerlink" title="Overlap Scheduler"></a>Overlap Scheduler</h2><h2 id="Frontend-design"><a href="#Frontend-design" class="headerlink" title="Frontend design"></a>Frontend design</h2>]]></content>
    
    
    <summary type="html">sglang, 但是极简版.</summary>
    
    
    
    <category term="system" scheme="http://darksharpness.github.io/categories/system/"/>
    
    <category term="MLsys" scheme="http://darksharpness.github.io/categories/system/MLsys/"/>
    
    
    <category term="system" scheme="http://darksharpness.github.io/tags/system/"/>
    
    <category term="LLM-serving" scheme="http://darksharpness.github.io/tags/LLM-serving/"/>
    
  </entry>
  
  <entry>
    <title>少女乐队和我的大三下</title>
    <link href="http://darksharpness.github.io/summary2025-01/"/>
    <id>http://darksharpness.github.io/summary2025-01/</id>
    <published>2025-07-12T16:18:26.000Z</published>
    <updated>2025-09-17T17:50:00.134Z</updated>
    
    <content type="html"><![CDATA[<p>拖拖拖, 一个月过去了, 最终还是开始写总结了. 大三转瞬即逝, 马上就要大四了. 这学期的时间又浪费到哪里去了呢?</p><h2 id="胡言乱语的-introduction"><a href="#胡言乱语的-introduction" class="headerlink" title="胡言乱语的 introduction"></a>胡言乱语的 introduction</h2><blockquote><p>这不是故事总结, 但是吐槽里面会有一些剧透</p></blockquote><p>老实说, 笔者其实很早就接触过 BanG Dream! 了. 笔者和 BanG Dream! 最早的交集是在高中, 那时候笔者非常喜欢看网上各路大神的吉他 cover 视频, 在疫情期间刷到了一位女装大佬 <a href="https://space.bilibili.com/186932">up 主</a> 的东方曲 cover. 那时候笔者还是一个单纯的东方 only 爱好者, 对二次元其他方面的了解几乎是 0. 在那时候, 笔者从这位 up 的 cover 曲子里面第一次听闻了 Roselia 的 Fire Bird, 一首非常 power 的曲子, 也非常符合笔者当时的胃口.</p><p><img src="https://static.wikia.nocookie.net/bandori/images/4/42/Roselia_9th_Single_Blu-Ray_Edition_Cover.jpg" alt="Roselia 9th Single Blu-Ray Edition Cover"></p><p>然后第二次接触 BanG Dream!, 大概就是今年 2025 年了. 从 2021 年到现在, 时间间隔也挺久的了. 这次笔者是通过 MyGO!!!!! 这个算是之前非常火热的一部番剧了解的. 看这部番的动机完全就是大三上过于高压, 在被考试和论文的重重压力打爆之后, 转向了无尽的自我补偿… 在第一遍看 MyGO!!!!! 的时候, 笔者并没有非常认真, 也并没有非常带入… 看完之后确实有点小感动, 故事情节还算可以. 当然, 看这部番还有另一个更直接的原因, 那就是追当季番: Ave Mujica. 总之, MyGO!!!!! 大致给笔者铺垫了追 Ave Mujica 所需要的全部背景知识, 然后就被笔者暂时的抛诸脑后了.</p><p>在一月末二月初准备托福的时候, 笔者每周最期待的事情, 就是周四晚上观看新的一集 Mujica. 在当时的笔者看来, Ave Mujica 是一个足够黑暗、猎奇的作品, 其上来就营造了一种高度压抑恐怖的氛围, 前几集可谓是集集爆 (nyamu 摘面具, sakiko失控, mutsumi 激活第二人格, 乐队解散), 观影体验一点也不轻松 (类似的氛围在 MyGO 的中间偏后几集的时候也有出现, 只不过这里上来就开大招了), 给了笔者一种独特的体验, 吸引着笔者追下去. OP 的那种宿命感, 以及 ED 的苍凉, 笔者在观看前的心理期望大抵是一部类似小圆的黑深残作品.</p><p>然而, 故事的发展逐渐有点失控. 第七集是笔者开始觉得诡异的一集, Crychic 的众人在了解到了 sakiko 之前家里发生的事情之后, 对 sakiko 的态度发生了大反转. 这个其实在意料之中, 但是令人很费解的是, 编剧在这一集中把众人无视 anon 不回消息进行了描写, 这种对主线 (Crychic 和解) 完全无关的描写很难让人觉得不是别有用心, 也让笔者觉得观感稍微有点差.</p><p>然后后面的剧情就是急转直下, 典型例子就是第八集 umiri 突然爆发, 自称是因为不爽想要买东西. 但是类似的情绪在之前的剧情中, 似乎并没有任何的体现, 笔者在这之前对她的认知完全是一个铁面无情的支援 bass 手, 仅仅在第 7 集结尾观看 Crychic 演出以及希望 sakiko 和 mutsumi 重组乐队对的时候才似乎有些情绪波动. 虽然这确实很符合现实中人的表现 —— 在现实中我们也不少见到一个比较内敛的人, 其实有丰富的内心活动, 但是在一部作品中, 这样突然的转变需要时间去消化. 一个人突然展现了自己不为人知的一面, 那就需要有对应的故事展开, 去支撑这个人内心的一面, 或者前文得有一些相关的蛛丝马迹. 不幸的是, 前文的铺垫似乎找不到任何提示 (对比之下, soyo 在 MyGO 中在一开始就给人一种心机大姐姐的感觉), 而实际故事展开又不像 sakiko 那样足以撑满一整集. 因此, 笔者面对这一个转变, 在第一次观看时的感觉是: “啊? (2 声)” 的确, 冷静下来的思考的话, umiri 的故事的确令人唏嘘: 第一支乐队的队友放了自己鸽子, 害怕类似的事情重现于是风险管理加入了很多乐队. 只可惜对于当时在追番的笔者来说, 第八集的剧情并没能成功让笔者很好的代入并共情.</p><p>当然, 笔者承认, 在第一次观看的过程中, 确实受到了身边同学的一些影响, 以一种稍微有点看乐子的心态去观赏作品… anyway, 追完之后, 笔者的第一感觉是: 这部番毁了, 也没有仔细再去品鉴的欲望.</p><p>在 4 月, 伴随着 Ave Mujica 的结束, 笔者大三下学期的各门课程也逐渐走向了收尾. Model Checking 大作业, 笔者花了大概 3 ~ 4 天速通了. 感想就是 modern C++ 的理论与实践, 也算是找到一个机会让笔者爽写了一次 modern C++. 自从在开源项目 xgrammar 打工之后, 笔者的对 C++ 的理解似乎提升了不少, 也开始包容更多种多样的写法. 在这个过程中, 笔者也学习了不少关于 github ci 的小知识, 并且把 <a href="https://github.com/DarkSharpness/MC">Model Checking 的大小作业</a> 全部用 github workflow 部署, 还是非常爽的. 在这段时间里, 笔者除了在等暑研的 DS2019, 也给 xmake 贡献了 xgrammar 的包, 能给自己喜欢的 toolchain 做出一些贡献, 也是一件非常开心的事情. 不过这确实并没有什么挑战, 只是一些纯经验, 生活中还是需要有一些更加 dokidoki 的事情的.</p><p>5 月份, Stanford 的 DS2019 迟迟到来, 笔者赶紧填完了各种表格, 一周的时间速通的签证. 由于是去广州办的签, 所以比较快, 如果办上海的估计排队得排到死. 笔者的运气比较好, 一次就顺利过签. 具体细节已经忘光光了, 只记得那个外国老哥在最后对我说了一句 “Enjoy your summer in Stanford!”, 我回了他一句 “Thank you”, 大概就这些吧. 总之, 到这里还算是一切顺利. 从广州回来后, 笔者先是急着肝完了 Eurosys 的实验. 这次 submission 真的是过于极限, 直到提交前 30min 甚至还没写完.</p><p>这次赶 paper 的经历也把笔者打穿了, 之后笔者回到家周末头疼了整整两天. 在修养完毕之后, 回到学校赶紧去办了学院流程. 这套流程并不简单, 中途笔者还填错了一次日期. 幸运的是, 笔者多次和相关老师联系求助, 最终也是极限在出发前的一周完成了所有的流程. 至此, 笔者的这个学期大抵也是结束了.</p><p>这个学期本身就没什么课程, 压力称不上大. 但笔者都在做些什么呢? 看番, 这确实很重要. 笔者追完了 Ave Mujica, 补了 MyGO!!!!!, Girl Bands Cry, 孤独摇滚. 少女乐队名著应该是齐全了 (如果算上高中笔者云过的轻音少女的话). GBC 和小孤独, 给笔者的感觉是纯纯的温馨治愈, 慢慢的人间真情… 在看 GBC 的那个下午笔者用掉不少纸巾, 而笔者也永远不会忘记看到小孤独融化那一刻, 自己脸上挂着的笑容. 确实是治愈系深作. 而 MyGO 和 Mujica, 这两部作品给笔者带来了不一样的思考, 虽然第一遍看的时候不是非常认真, 但确实让笔者感觉耐人寻味, 这也为笔者后来二刷埋下了伏笔.</p><p>6 月份, 笔者飞去了美国. 这是笔者这辈子第一次出国, 还是非常激动的. 加州确实是一个气候比较宜人的地方, 湾区 Stanford 那边尤其如此. 在短暂的 100 多天暑研的日子里, 笔者只撞上了一天下雨天, 还是在临走前的一天, 也算是非常幸运了. 加州整体呈现出一种比较干旱、类似沙漠的气候条件, 第一次逛 Stanford 的时候给人一种沙漠神殿的感觉, 不过据说冬天可能会更多下雨. 最令人满意的一点是, 即使是夏天, 最高温度基本也不会超过 30 摄氏度, 没有太阳直射的时候甚至会感到有点冷, 骑车必须得披上外套, 昼夜温差非常的大.</p><p>在 3 个月的暑研中, 比较有意思的是 7 月初和同学一起去 OSDI 玩. 虽然笔者自己对 system 的理解并不是很够, 也并不认识很多的领域内的人, 但是有身边的同学带着去认识各个老师, 整体体验还行, 没有太自闭, 最后顺走了 ATC/OSDI 的牌子也是挺搞笑的. OSDI 的收获还是挺大的, 听到了许多有意思的工作, 认识了不少的人, 也是第一次参加这么大型的会议, 机会真的难得.</p><p><img src="https://s2.loli.net/2025/09/18/c5aYMzos246wnrH.jpg" alt="OSDI/ATC-25"></p><p>这三个月中, 其实各种小事故也层出不穷. 比如刚到美国的时候手机卡直接 gg 了, 国内手机阉割了国外的频段直接没有信号, 最后的 solution 是直接买个新的手机, 幸亏有比较热心的人在笔者刚到的前几天帮忙, 不然大抵是要死在异国他乡了 (bushi). 然后刚安定下来没几天, 大力出奇迹把电脑的充电线搞坏了. 当时真的非常紧张, 然而冷静下来后笔者用手边的螺丝刀和一些小工具, 硬是把充电头里弯掉的那根针掰直, 然后就能用了…</p><p>总是, 意外一直都有发生. 在过去, 笔者遇到这些意外可能就会比较不知所措, 大概率会消极应对, 比如开摆或者拖延拒绝想办法直到不得已. 但是出国以后, 笔者就不能像是在国内这样瞎搞了, 毕竟容错更低了. 也算是强行培养了一波独立生存的能力.</p><p>6,7,8 三个月稍微出去玩了玩, 去过 NV 老巢, 去过 UCB sky lab 和 MIT. 虽然大部分时间笔者都是一个人呆在 lab, 不过由于 7,8 月份忙着手头的工作, 所以也不算太无聊, 只不过一个人稍微有点孤独, 但感觉在呆了 2 个月以后也习惯了这种感觉, 有时候也会觉得一个人呆着没有人打扰挺好的, 如果没有生活的压力的话.</p><p><img src="https://s2.loli.net/2025/09/18/YAfVJiXb56CluMN.jpg" alt="NVIDIA"></p><p>最大的插曲大抵是 UCLA 那边彻底 gg 了, 原因是笔者犯了一些愚蠢的错误, 导致最终去不了了, 这也是笔者最后回国了才发现的. 只能说以后对于一些重要的文件还是要更加慎重, 这类愚蠢的错误已经重演了不知道多少次了. 在 8 月中下旬意识到了必然去不了 UCLA 后, 笔者才突然意识到自己的暑研之旅即将结束了. 虽然笔者一直会有点抱怨说自己一个人干感觉非常自闭, 但一想到要走心里还是非常难过的.</p><p>总之, 暑假三个月一眨眼就过去了, 很快就来到了最终分别的时刻. 笔者自然是非常难过的. 笔者感觉还没怎么交流过 idea, 而且组里的老哥真的也都非常非常的 nice, 氛围可以说顶级好, 没有黑暗竞争内卷 (请勿对号入座). 本来打算拖到 DS2019 的 grace period 的最后一天离境的, 然而和家长的一次视频通话无意间提醒了笔者, 笔者没有请假还得回学校签到. 于是, 笔者就仓促的决定卡在极限时刻回国, 正好赶在开学报到前两天 (但实际是一天, 笔者一开始以为是周一报道…) 回国.</p><p>当地时间 (UTC - 07) 2025/09/12 凌晨, 笔者乘上了回国的航班. 飞机一点点的驶离海岸线, 看着黑夜里那点城市的灯火, 消失在远方地平线. 笔者知道, 自己这趟美国之旅大抵是彻底画上了句号.</p><p>在飞过阿拉斯加、白令海峡的时候, 笔者看到了窗外的点点星光. 说起来, 那里应该是北极附近吧. 下方就是无尽的白色海洋, 上面则是浩瀚的银河. 笔者是第一次见到如此壮丽的景色, 虽然没能拍下当时所见, 但是这一幕已经深深的映在了笔者脑海里, 笔者可能一辈子都忘不掉那一瞬间的震撼吧. 望向宇宙星空, 在这一刻, 一切都消失了, 剩下的只有无尽和永恒. 在漆黑的夜空中, 飞机侧翼的灯火成为了唯一的一盏灯.</p><p>以上大概是笔者大三下的整体 timeline 吧. 如果说上学期 (大三上) 是在压力爆炸之后, 回头寻找自己生活中 doki doki 的时刻, 那么这学期的笔者就是更多在主动创造属于自己的 doki doki 的时候. 笔者这学期最开心的事情, 就是补完了一堆少女乐队番: 在 1 月份补了 MyGO, 1 ~ 3 月追了 Ave Mujica, 4 月补了 孤独摇滚, 5 月补了 Girl Bands Cry, 6 月去美国飞机上认真二刷了 MyGO, 7 月在往返 OSDI 的飞机上二刷了 Ave Mujica, 最后在 9 月回国的飞机上补完了云了一万年剧情的轻音少女. 同时, 笔者在这学期也做到了自己给自己的约定, 基本每周都回家练琴. 比较遗憾的是在科研上目前还是 0 突破, 暑研也因为自己的一些原因也没做出满意的结果.</p><p>最后的一点感慨, 是如果有了想法不及时去做, 那么这份冲动很快就会消失. 所以一定要坚定的 carry out, 笔者不希望以后的自己再活在后悔之中.</p><blockquote><p>Intro 部分, 写于 2025/09/18 00:40 UTC + 08, D19 109 寝室</p></blockquote><h2 id="寒假"><a href="#寒假" class="headerlink" title="寒假"></a>寒假</h2><p>在大三上半学期 <a href="/misc/" title="杂七杂八的东西 - 大三上小结">杂七杂八的东西 - 大三上小结</a> 的时候, 笔者稍微有点被压力爆了, 因此寒假的时候笔者非常的低迷. 整个寒假, 笔者除了考完了托福, 没有做什么建设性的事情. 一个有意思的事情是, 在此之前, 笔者给 xgrammar 项目打工, integrate 进去了 sglang, 也算是给 lianmin 整了个投名状. 笔者一开始并没有想长期搞开源项目的打算, 可能只是因为为了完成承诺别人要求完成的事情罢了. 但是在寒假的时候, 笔者因为除了托福之外, 闲的没事情干, 于是便开始给 xgrammar 项目写代码. 这么做的动机非常简单, 笔者是一个 C++ 爱好者, 而 xgrammar 是一个 C++ 项目, 非常对笔者的胃口.</p><p>寒假的 highlight 自然是准备托福. 笔者的父母虽然早就让笔者好好准备托福, 但是笔者比较不耐烦, 一直以课程和项目作为开脱. 到了寒假, 实在是推不掉了, 只能硬着头皮开始学了. 事实上, 笔者一开始学的时候也不是非常的认真. 网课的时候非常没耐心, 经常切屏去刷 b 站/知乎, 即使知道这是一个意义重大的考试, 但也没有做好十足的准备. 这样的事情其实发生了很多次, 高考之前, 笔者也有过类似的行为: 在很重要的网课时期, 依然无法集中精力去听课, 上课不是在聊天就是在玩.</p><p>这样的后果是, 大约 2 月的第一周过半了以后, 笔者突然意识到距离最终考试只有 10 天了, 于是紧张和不安开始发力… 这个阶段笔者的效率倒是不错, 再加上家长找了一个还不错的一对一的老师, 练习的效果也很好, 提升很显著, 也积攒了不少的信心.</p><p>最后 15 号去上海大学考, 考完听力没错, 阅读扣两分, 口语虽然口胡了不少, 但没有出现致命卡顿, 还算是可以. 在这个时候, 笔者也联系上了 Stanford 的 PhD Zhiqiang, 一段惊心动魄的科研之旅即将开启.</p><p>整个寒假, 基本就是围着托福走. 除了托福, 也给 xgrammar 交了一两个小 PR, 其他就一点正事没干. 不过也是在寒假, 笔者重新拿起了吉他, 开始每天练习一些基本功. 在过去的 2024 年, 笔者不知道在忙些什么, 基本没有花多少时间在琴上. 直到这个寒假, 笔者才意识到, 自己是真的喜欢这个乐器的. 笔者在高中就听了不少大失真、以吉他编曲的核心的曲子, 而在上大学后则更多的接触了一些日本 ACG 的曲子, 听的大部分也算是 guitar-driven 的. 虽然笔者不太可能真的成为梦想中的 guitar 大师, 但至少笔者希望能成为自己的 guitar hero, 能够弹出让自己感动的旋律.</p><p>不过话说回来, 笔者在当时确实也意识到了自己一个寒假啥都没做, paper 也没咋看, 技术知识也没咋学, 心里自然是很焦急. 笔者一直都害怕落后别人, 也害怕自己不能兑现自己给其他人的一些承诺. 最近 (2025/09/17) 笔者看了 tianqi 的一个 talk, 其中提到 “你的勇气很大程度上, 来自于你过去对自己的承诺”, 结合当时和现在的自己来看, 这句话确实说的很有道理. 但这个承诺对笔者的约束, 可能更多的是恐惧驱动的, 害怕自己做的不好. 感觉虚荣和恐惧, 才是笔者一直以来的核心动力, 而笔者喜欢什么, 笔者可能自己也不知道. 自己喜欢什么, 想要在未来做些什么, 也成为了后面一直萦绕在笔者脑海里的问题.</p><h2 id="学期"><a href="#学期" class="headerlink" title="学期"></a>学期</h2><h3 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h3><blockquote><p>难得学期小结写点学期心得</p></blockquote><p>一个短暂的过渡学期. 学期的开始, 笔者有各种宏伟的计划, 比如 lead sglang 的一个小项目的 PR, 帮 zhiqiang 改 hicache, 学 RDMA 然后完善 system 2 的 tutorial. 到头来一个都没有干成. 即使列出来了计划, 生活中的一些琐事也会消磨笔者做事的热情, 最后就彻底把整件事情抛诸脑后. 当然, 这可能也是因为笔者对这些事情并没有足够的兴趣, 比如 sglang 那边笔者一开始完全的想法完全就是干点事情, 让自己看起来不要什么都没干. 而 zhiqiang 那边同理. RDMA 则是因为笔者自己完全不会, 而它听起来很厉害很高大上.</p><p>一个正常的学习路线, 笔者认为应该是, 意识到某个东西的有强大的功能或者不错的前景, 因此愿意为之付出时间去了解. 如果知识急于想要做点事情证明自己, 但是缺少一个良好的动机, 那么在学习的路上就会一直缺少正反馈, 最后学着学着就没耐心了.</p><p>动机, 一般是兴趣驱动. 但是笔者在这里又遇到了一个困境. 笔者自知自己比较喜欢一些比较 engineering 的事情, 比如写一些有趣的 C++ meta programming, 比如搭建一个 system (Compiler, OS), 但是这些东西很多时候没有什么 “科研价值”. 而笔者又非常渴望能做一些有意思的 “科研”, 想做一些大家认为非常 “fancy” 的工作. 前者可能是出于笔者的思维惯性 (笔者比较熟悉这些东西, 所以想做相关的东西), 后者则应该是处于笔者的虚荣心. 总之, 这两者很大程度上是 conflict 的. 想要做自认为喜欢的事情, 就感觉不够 “fancy”, 看起来不够酷. 想要做比较酷的东西, 可是论文又一点看不进去… 总之, 笔者似乎一直在做着 A, 但是又相信着 B…</p><p>当然, 可能也只是笔者对于那些 “fancy” 的东西的入门路线不太对, 不够熟悉, 尚未纳入舒适圈, 因此读起来比较坐牢. 这里一部分原因可能是, 笔者不希望自己看起来很菜, 因此经常会不懂装懂, 也不喜欢向别人提问, 导致进步非常的缓慢. 这一点笔者在学期中也逐渐意识到了, 也有在改变自己, 这一点或许是笔者这学期最大的提升吧, 放下所谓的 “面子”, 接受自己的无知, 承认他人的成功与优秀.</p><p>不过到头来, 笔者似乎还是不知道自己想要什么. 笔者甚至觉得, 自己对音乐的热爱远远超过了所谓的学术. 从高中的时候, 笔者就非常痴迷于音乐. 刚上高中接触东方不久, 就把东方同人音乐某一个子风格下面的乐队都翻了一遍, 从 THBwiki 翻到 BandCamp, 然后 twitter 每天关注自己喜欢的乐手的最新动态, 一有时间就上外网去找各种资源. 在高三的时候, 笔者甚至自己 DIY 了一个简易的 guitar, 并且也自己用数学推导了一些音乐理论 <del>玄学</del>. 那时候的疯狂现在的笔者恐怕是再也不会有了, 现在的笔者已经完全被学业缠住了… 但这真是笔者想要的答案吗.</p><p><img src="https://s2.loli.net/2025/09/17/OI2uBG7XqSwsU8m.png" alt="~~我从来没觉得搞学术快乐过~~"></p><p>简单来说, 最后大抵是给 sglang 和 xgrammar 贡献了一些非核心的小 PR, hicache 那边主要跑了跑实验, 讨论了讨论如何减少 PCIe stall, 然后把学期中正常的工作做完, 其他基本也没干些啥了. 至少, 笔者认为没有达到自己心目中的目标.</p><h3 id="番"><a href="#番" class="headerlink" title="番"></a>番</h3><p>笔者上半年刷了不少番 (比起过去算挺多的), 大部分都是少女乐队相关的. 不得不说, 这些 girl bands 也是笔者重新拿起吉他的动机之一.</p><h4 id="MyGO"><a href="#MyGO" class="headerlink" title="MyGO"></a>MyGO</h4><p>第一个看的是 MyGO!!!!!. 是在寒假回家前的那个下午速通的. 当时看的目的只是为了能去补当季新番 Ave Mujica, 并不是太认真. 不过后来在去美国的飞机上二刷了, 那次可真是哭的稀里哗啦啊 (bushi).</p><p>在 soyo (长崎爽世, そよ) 的身上, 笔者看到了自己曾经的影子. 笔者依然记得大一下的时候, 组织了一个 <a href="/mcImpart/" title="关于 Minecraft Impart 服务器">关于 Minecraft Impart 服务器</a> 服务器. 一开始, 大家看起来玩的都挺开心, 至少笔者自己是这么认为的. 然后到了大二的时候, 渐渐的就没人来了. 笔者不知道是哪里出了问题, 总之就是各种祈求大家能够回来. 那时的笔者和 soyo 为了能够重组 crychic 而奔走东西的样子真的太像了, 为了找回自己过去的快乐的记忆… 确实, 那时候的笔者也真是满脑子都是自己啊.</p><p><img src="https://s2.loli.net/2025/09/17/UkPe4HbpRAvGCEO.png" alt="名场面"></p><p>笔者也有时会像 soyo 一样, 在平时生活中经常会刻意的去表现自己 (当然不是 soyo 那种温柔表现), 也确实很希望身边人能够接纳自己, 真的非常希望能让身边每一个人开心, 害怕看到别人失落的表情. 每当遇到自己想不明白的事情, 就会放弃思考, 从来没敢直面这些问题. 正如 soyo 忘不掉 crychic, 笔者可能也一辈子忘不掉和同学一起快乐游戏的时光, 以及高中第一次听到自己喜欢的音乐时候激动, 还有自己倒腾音乐的那份热情了… but life still goes on, 笔者不应该过度沉溺在过去的那些事情中, 不能止步于自己的记忆之中. 可能这也是笔者看 MyGO 最大的感触吧.</p><p>在一刷的时候, 笔者其实对 soyo 并没有很深刻的印象. 在一开始的剧情中, 就已经处处透露出 soyo 这个人是一个表里不一、有小心思的人了, 因此后面会有什么样的反转, 其实基本已经在意料之中. 不过一刷的时候, 那个惊人的一跪, 这份对过去的执念, 也是吓到笔者了… 一刷的时候, 笔者的目光可能更多的放在阳角 anon 身上. anon 看起来就是一个看起来单线程, 稍微有点虚荣但又非常乐观向上的角色, 这种阳里稍微带点阴的角色塑造方式在当下, 笔者感觉甚至可以称的上有点扁平 (? 瞎说的不负责). 不过 anon 也是贡献了不少的名场面, 而且她和 tomorin 互相鼓励, 在迷茫中前进, 也确实算是这个番很大的一个看点.</p><p><img src="https://s2.loli.net/2025/09/17/UKXiYRMwTEek4fd.png" alt="至理名言"></p><p>小灯, tomorin, 是一个非常非常有意思的角色. 看起来自闭小孩, 其实有很强烈的情感, 并且在关键时候将 anon 拉出低谷, 被 rana 认为是有趣的女孩子, 也大胆唱出了 soyo 和 taki 以及众人的心声… 用歌词表达自己的情感, 这一点确实小灯确实做的非常好, 和 anon 的互相拯救 (也可能是单向) 真的看的笔者无比感动, 无论是一刷还是二刷. 虽然笔者可能和 tomorin 并没有太多的共鸣, 但这并不妨碍她成为笔者在 MyGO!!!!! 中和 soyo 并列最喜欢的角色. 有意思的女孩子.</p><p>这可能是笔者看的第一个人物关系写的这么复杂的番剧 <del>也可能是目前最接近百合番的</del> <del>好吧后面 Ave Mujica 看起来更是重百合</del>, 但里面的人物塑造在复杂的同时也没有过于脱离实际, 很好体现出了不同性格的人的不同特点. 最后 MyGO!!!!! 众人以真心相对、于迷茫中前行的结局, 也宛如童话一般美好, 算是这个番最大的泪点吧.</p><h4 id="GBC-amp-孤独摇滚"><a href="#GBC-amp-孤独摇滚" class="headerlink" title="GBC &amp; 孤独摇滚"></a>GBC &amp; 孤独摇滚</h4><p>非常抱歉笔者由于没有二刷这两部番, 时间也过去快半年了, 所以可能没法像 MyGO!!!!! 的分 (gui) 析 (che) 那样细致.</p><blockquote><p>未完待续.</p></blockquote><h4 id="Ave-Mujica"><a href="#Ave-Mujica" class="headerlink" title="Ave Mujica"></a>Ave Mujica</h4><h2 id="暑假"><a href="#暑假" class="headerlink" title="暑假"></a>暑假</h2><h3 id="Stanford"><a href="#Stanford" class="headerlink" title="Stanford"></a>Stanford</h3><p>感谢 lianmin 和 ying 的帮忙, 联系到了 Stanford 和 UCLA 的学长学姐. Stanford 这边联系上的是 Zhiqiang, 在去之前笔者一直有 (试图) 在帮着 hicache 相关的东西, 也因此笔者对 sglang 的框架有了更加深入的了解. Stanford 那边的手续, 笔者办的也是一波三折. 虽然 invitation letter 上写的是 6 月初要去, 但是直到 5 月初的时候, 笔者才收到正式的 DS2019, 而且还是在垃圾邮件中. 感谢上课玩手机, 让笔者没有错过这封至关重要的邮件.</p><p>invitation letter 上写的是 06/04 ~ 08/31, 不过实际上笔者 06/02 就去了 (btw, 插播一个广告, <a href="/lily/" title="Lily White 在美国">Lily White 在美国</a>). 到的当天笔者先是在住的地方硬撑到了晚上 18 点, 然后安详的睡了过去. 这可能是笔者出生以来睡得最香的一次, 笔者从来没有这么长时间的清醒过.</p><p>笔者花了一两天就安顿下来了, 时差其实也很快就倒过来了 <del>年轻就是好啊</del>. 在后面的几天里面, 笔者先开始干 sglang 的一些 PR.</p><p>前两周干的主要就是 radix tree API 的 clean up. 在当时, sglang hi-radix tree 的 integration 过于 bug prune (虽然似乎没啥问题, 稳定能跑), 而且根据在 core scheduler 里面充斥着各种根据是否开启 hicache 的 if 特判非常不对笔者的胃口, 于是笔者大刀阔斧的把 radix tree 相关的 API 都多做了一层封装. 然后是 C++ hi-radix tree, 这玩意一开始写出来是为了 scheduling 服务, 因为一些比较 fancy 的基于 prefix 信息的 scheduling 用 Python 实现过于慢了, 不过似乎 scheduling 那边因为过于复杂一直没 upstream 进去, 这个 hi-radix tree 最终也没啥后文了.</p><p>这段经历看起来对笔者的未来不会有任何的影响, 但实际上这段时间笔者完整 walk through 了 sglang 的 core scheduler, 给后面自己写的 LLM 框架埋下了伏笔 (真的吗?).</p><p>第三周的时候老板 Christos 开始找笔者聊项目的事情. 一开始 Zhiqiang 提议了 RL 的一些东西, 笔者后来也把和好友 <a href="https://github.com/Conless">Conless</a> 聊的 RL 那个 idea 给了老板画了个大饼, 不过一直没拿定主意. 在这个时候, 笔者稍微做了一点点 RL 的 profiling, 并且开始自己写一个 LLM training 框架. 其实一开始写框架的时候, 笔者只是纯觉得写代码爽, 再加上希望整点花活, 比如自动生成 model pipeline (实际是重载运算符, 不是很聪明的样子), deduplicate model 类, 于是便噌噌噌开始写自己人生第一个 LLM 框架了.</p><p>一开始的框架是想写的 general 一点, 因为一开始讨论的 idea 就包括了 colocate training &amp; inference, 笔者希望能够在一个 process 里面同时完成这两个任务. 这个框架从 6 月 26 号开始写, 在去 boston 前 (7/5) 基本写完了大概, forward pass 没有问题.</p><p>在 7 月的时候, 最有趣的事情就是 OSDI 之旅. 人生第一次参加顶会, 心里自然是非常激动的, 不过激动似乎有点过了头, 去那边的三天没有一晚上是睡好的… 本来想着去那边多认识一点老师, 只可惜笔者完全没做过什么攻略, 嘴上说着要大胆 social, 实际也只敢跟在同学的后面…</p><p>回来之后, 笔者最终在 RL 和 fault tolerance 的两个项目中选择了 fault tolerance 的项目. 老实说笔者自己也不太记得清楚是为什么了, 根据模糊的记忆, 可能是因为笔者害怕短短的三个月做不出结果, 因此放弃了之前就有过不少讨论了 RL project. 这么做确实有点功利和短视, 笔者当时也确实有点受到良心的拷打, 自己做科研一直动机不纯, 而且做的也挺烂的…</p><p>不过 fault tolerance 确实也不算一个完全无聊的项目. 笔者还是一步步找到了不少的 challenge, 并且也优化出了一些解决方案, 跑出了还不错的结果. 笔者是在之前的那个 LLM 框架上修改的. 感谢之前阅读 sglang core scheduler 源码的经历, 笔者得以在一周之内把一个 modern LLM serving engine 所需要的全部 feature 都写完. 在 7 月末的时候, 笔者的框架基本以及可以对标 sglang 了.</p><p>7 月的一切看起来都无比的顺利, 每周都有显著的推进, 事业看起来兴兴向荣, 然后就是灾难的 8 月.</p><p>8 月笔者感觉自己似乎完全是在止步不前, 除了稍微 tune 了一点自己的 DP-attention 调度算法, 测了一堆数据, 就没有其他的改进了. 由于前半个月老板在欧洲, 笔者拿不到 in-time 的 feedback, 笔者自己也拿不定主意, 因此不敢推进. 在这里, 笔者浪费了接近一个月的时间, 除了中间把之前 hicache 的 paper 的实验补了, 其他几乎什么都没干… 在这个阶段, 笔者也开始对自己的东西无比怀疑. 这玩意真的有人会 buy 吗. 至少如果只有 20% 的 gain, 那么笔者很难说服自己这是一个有意义的工作.</p><p>总之, 到 9 月, 直到笔者的 SEVIS 已经 inactive 了, 笔者才意识到自己的时间已经不多了. 在最后的一周里面, 笔者 3 天补完了后面需要的 host back up 部分, 并且实现了 parallel PCIe utilization. 最后也算是在走之前把工作的整体都实现完成了, 只剩下一点点 corner case 要补一下, 还需要测一些实验即可.</p><blockquote><p>未完待续</p></blockquote><h3 id="轻音"><a href="#轻音" class="headerlink" title="轻音"></a>轻音</h3>]]></content>
    
    
    <summary type="html">我, 大三下, BanG Dream!</summary>
    
    
    
    <category term="随笔" scheme="http://darksharpness.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="总结" scheme="http://darksharpness.github.io/categories/%E9%9A%8F%E7%AC%94/%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="随笔" scheme="http://darksharpness.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>Lily White 在美国</title>
    <link href="http://darksharpness.github.io/lily/"/>
    <id>http://darksharpness.github.io/lily/</id>
    <published>2025-07-10T16:26:11.000Z</published>
    <updated>2025-09-17T15:31:39.093Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2025/07/11/YXVcaobkQ2dnq5B.jpg" alt="SFO on 06/02"></p><p><img src="https://s2.loli.net/2025/07/11/d2jN4bf8lqBHr3T.jpg" alt="MAST lab on 07/05"></p><p><img src="https://s2.loli.net/2025/07/11/wy6mZXY7Usi4kaj.jpg" alt="MAST lab on 07/05"></p><p><img src="https://s2.loli.net/2025/07/11/XZBlj1dwf54gMqO.jpg" alt="ATC-25 on 07/08"></p><p><img src="https://s2.loli.net/2025/07/11/t4NiHsZde8YbB6Q.jpg" alt="Wankupi&#39;s lab on 07/09"></p><p><img src="https://s2.loli.net/2025/07/11/7ywi4nc6Csa2u3X.jpg" alt="Wankupi&#39;s home on 07/09"></p><p><img src="https://s2.loli.net/2025/07/11/jICRHXxUeuam37v.jpg" alt="My home on 07/11"></p><p><img src="https://s2.loli.net/2025/08/13/5fKeY96SwOGqgiM.jpg" alt="Lily in sky lab on 08/12"></p><p><img src="https://s2.loli.net/2025/08/13/KBfCsdrk39bZhyi.jpg" alt="Lily in sky lab on 08/12"></p><p><img src="https://s2.loli.net/2025/09/17/XkzE91uVNjqovUK.jpg" alt="Lily in my new home on 09/06"></p><p><img src="https://s2.loli.net/2025/09/17/1lYGLUHkIqBfVZy.jpg" alt="Lily in SFO on 09/11"></p><!-- ![Lily in Wuhan on 09/13](https://s2.loli.net/2025/09/17/ph3IKc4LFbgsfa7.jpg) -->]]></content>
    
    
    <summary type="html">Lily White in U.S.</summary>
    
    
    
    <category term="随笔" scheme="http://darksharpness.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="随笔" scheme="http://darksharpness.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>My environment config v2.0</title>
    <link href="http://darksharpness.github.io/env-2/"/>
    <id>http://darksharpness.github.io/env-2/</id>
    <published>2025-06-23T08:38:25.000Z</published>
    <updated>2025-08-19T02:06:38.839Z</updated>
    
    <content type="html"><![CDATA[<p>Recently, I frequently setup my environment on different cuda machines. Therefore, I keep a record of my environment config here. After this, we will have:</p><ol><li>Customized zsh</li><li>C++ &amp; cuda develop environement (with clangd)</li><li>Python develop environement (uv + pip)</li></ol><p>First, we need to start from a docker image. I like the image from nvidia. It’s clean.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># In a remote machine</span></span><br><span class="line">docker pull nvidia/cuda:12.8.0-devel-ubuntu22.04</span><br><span class="line">docker run -itd --shm-size 32g --gpus all --ipc=host --network=host --privileged --name cuda_dark nvidia/cuda:12.8.0-devel-ubuntu22.04 /usr/bin/bash</span><br><span class="line">docker <span class="built_in">exec</span> -it cuda_dark /usr/bin/bash</span><br></pre></td></tr></table></figure><p>In docker, we need to update and change to first.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Now in docker</span></span><br><span class="line">apt update</span><br><span class="line">apt install zsh tmux git ccache ninja-build cmake curl wget vim python3 pip lsb-release software-properties-common gnupg -y</span><br><span class="line">chsh $(<span class="built_in">whoami</span>) -s $(<span class="built_in">which</span> zsh)</span><br><span class="line"><span class="comment"># for ubuntu 24.04 image, you may need:</span></span><br><span class="line">apt install python3.12-venv</span><br></pre></td></tr></table></figure><p>To use VSCode tunnel, we will need to download VScode and run <code>./code tunnel</code> in a seperate terminal.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Now in zsh</span></span><br><span class="line">zsh</span><br><span class="line"><span class="built_in">mkdir</span> vscode</span><br><span class="line"><span class="built_in">cd</span> vscode</span><br><span class="line">curl -Lk <span class="string">&#x27;https://code.visualstudio.com/sha/download?build=stable&amp;os=cli-alpine-x64&#x27;</span> --output vscode_cli.tar.gz</span><br><span class="line">tar -xf vscode_cli.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># Before tmux, we may set up ~/.tmux.conf</span></span><br><span class="line"><span class="built_in">set</span> -g mouse on</span><br><span class="line"></span><br><span class="line"><span class="comment"># Now in tmux, we set up VSCode tunnel :)</span></span><br><span class="line">tmux</span><br><span class="line">./code tunnel</span><br></pre></td></tr></table></figure><p>This is my customized zsh.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">sh -c <span class="string">&quot;<span class="subst">$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)</span>&quot;</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/zsh-users/zsh-autosuggestions <span class="variable">$&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;</span>/plugins/zsh-autosuggestions</span><br><span class="line">git <span class="built_in">clone</span> https://gitee.com/Annihilater/zsh-syntax-highlighting.git <span class="variable">$&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;</span>/plugins/zsh-syntax-highlighting</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/romkatv/powerlevel10k.git <span class="variable">$ZSH_CUSTOM</span>/themes/powerlevel10k</span><br><span class="line"></span><br><span class="line"><span class="comment"># We now open zshrc in VSCode</span></span><br><span class="line">code ~/.zshrc</span><br><span class="line"></span><br><span class="line"><span class="comment"># find and set as following:</span></span><br><span class="line">ZSH_THEME=<span class="string">&quot;powerlevel10k/powerlevel10k&quot;</span></span><br><span class="line">plugins=(</span><br><span class="line">  git</span><br><span class="line">  gitfast</span><br><span class="line">  zsh-autosuggestions</span><br><span class="line">  zsh-syntax-highlighting</span><br><span class="line">  z</span><br><span class="line">  uv</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># For a colorful terminal, you might need:</span></span><br><span class="line"><span class="built_in">export</span> TERM=<span class="string">&quot;xterm-256color&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Bind ctrl + backspace to kill one word</span></span><br><span class="line"><span class="built_in">bindkey</span> <span class="string">&#x27;^\b&#x27;</span> vi-backward-kill-word</span><br></pre></td></tr></table></figure><p>My python environment.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># only on ubuntu 24.04, we can&#x27;t install in system pip</span></span><br><span class="line">python3 -m venv .venv</span><br><span class="line"><span class="built_in">source</span> .venv/bin/activate</span><br><span class="line"></span><br><span class="line"><span class="comment"># Now we need to restart zsh (or source ~/.zshrc)</span></span><br><span class="line"><span class="comment"># we need to configure p10k...</span></span><br><span class="line"><span class="comment"># after that, configure python</span></span><br><span class="line">pip install uv</span><br><span class="line"></span><br><span class="line"><span class="comment"># then add the following in ~/.zshrc</span></span><br><span class="line"><span class="comment"># alias pip=&quot;uv pip&quot;</span></span><br><span class="line"><span class="comment"># alias pip3=&quot;uv pip3&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># When creating a venv</span></span><br><span class="line">uv venv</span><br><span class="line"><span class="built_in">source</span> .venv/bin/activate</span><br><span class="line">uv pip install uv pip</span><br><span class="line"></span><br><span class="line"><span class="comment"># Some other things i may need</span></span><br><span class="line">pip install nvitop</span><br></pre></td></tr></table></figure><p>My C++ environment (no need to set up things like <code>--query-driver</code> in docker).</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># we need to set up clangd for C++ development</span></span><br><span class="line">wget https://apt.llvm.org/llvm.sh</span><br><span class="line"><span class="built_in">chmod</span> +x llvm.sh</span><br><span class="line">./llvm.sh 19 all <span class="comment"># add all if u just want all llvm packages</span></span><br><span class="line"><span class="built_in">rm</span> llvm.sh</span><br><span class="line">update-alternatives --install /usr/bin/clangd clangd /usr/bin/clangd-19 100 \</span><br><span class="line">    --slave /usr/bin/clang-format clang-format /usr/bin/clang-format-19</span><br></pre></td></tr></table></figure><p>For sglang, you might need:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install libnuma-dev libnuma1 -y</span><br></pre></td></tr></table></figure><p>My vimrc (stolen from <a href="https://github.com/hnyls2002/setup/blob/master/.vimrc">this link</a>).</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> cindent</span><br><span class="line"><span class="built_in">set</span> number</span><br><span class="line"><span class="built_in">set</span> autoindent</span><br><span class="line"><span class="built_in">set</span> smartindent</span><br><span class="line"><span class="built_in">set</span> tabstop=4</span><br><span class="line"><span class="built_in">set</span> softtabstop=4</span><br><span class="line"><span class="built_in">set</span> shiftwidth=4</span><br><span class="line"><span class="built_in">set</span> backspace=2</span><br><span class="line"><span class="built_in">set</span> mouse=a</span><br><span class="line"><span class="built_in">set</span> cursorline</span><br><span class="line"><span class="built_in">set</span> cursorcolumn</span><br><span class="line"><span class="built_in">set</span> clipboard=unnamed</span><br><span class="line"><span class="built_in">set</span> hlsearch</span><br><span class="line"><span class="built_in">set</span> wrap</span><br><span class="line"></span><br><span class="line"><span class="string">&quot; Make the search case insensitive</span></span><br><span class="line"><span class="string">set ignorecase</span></span><br><span class="line"><span class="string">&quot;</span> But make them case-sensitive <span class="keyword">if</span> they include capitals</span><br><span class="line"><span class="built_in">set</span> smartcase</span><br><span class="line"></span><br><span class="line">map &lt;C-h&gt; 5h</span><br><span class="line">map &lt;C-j&gt; 5j</span><br><span class="line">map &lt;C-k&gt; 5k</span><br><span class="line">map &lt;C-l&gt; 5l</span><br><span class="line">imap jk &lt;Esc&gt;</span><br><span class="line"></span><br><span class="line">map &lt;C-a&gt; ggVG</span><br><span class="line">imap &lt;C-a&gt; ggVG</span><br><span class="line"></span><br><span class="line">map &lt;F3&gt; : w&lt;CR&gt;:!python3 %&lt;CR&gt;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> g:powerline_loaded=1</span><br><span class="line"></span><br><span class="line"><span class="string">&quot; Use Ctrl-H to delete the previous word in insert mode</span></span><br><span class="line"><span class="string">inoremap &lt;C-H&gt; &lt;C-W&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">I hate configuring environment.</summary>
    
    
    
    <category term="计算机" scheme="http://darksharpness.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    <category term="工具" scheme="http://darksharpness.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="基础知识" scheme="http://darksharpness.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Block Withholding Attack</title>
    <link href="http://darksharpness.github.io/blockwithhold/"/>
    <id>http://darksharpness.github.io/blockwithhold/</id>
    <published>2025-05-26T06:47:33.000Z</published>
    <updated>2025-06-04T06:37:54.438Z</updated>
    
    <content type="html"><![CDATA[<p>Disclaimer: All the image in this post is uploaded to <a href="https://sm.ms/">sm.ms</a>, which may not be friendly to readers in mainland China.</p><h2 id="PoW-Mining-Model"><a href="#PoW-Mining-Model" class="headerlink" title="PoW Mining Model"></a>PoW Mining Model</h2><p>As we all know (?), in PoW (proof of work) blockchain system, miners can mine blocks to gain block reward (bitcoins). Mining blocks requires the miner to prove that they have done a certain amount of work. The most common proof of work is to find a hash that satisfy certain properties. For example, the hash value of a string in integer is no larger than a certain number $N$. Assume the range of the output of hash is $R$, then the probability of a random hash to be valid will be $\frac{N}{R}$.Due to the nature of cryptography secure hash functions, the distribution of output hash is unpredictable given any different strings as input, which means we may assume that the probability of any string to has a valid hash is $\frac{N}{R}$. Note that there can be other means of constrains for a block to be valid, but the core is simple: the probability of a hash to be valid will be $p$, which is typically a small number.</p><p>Let’s take a look at a well-known real-world example: Bit-Coin. In Bit-Coin, the threshold $N$ is related to <strong>difficulty</strong>. Trivially, the higher the difficulty is, the lower the threshold will be. This is threshold is adjusted dynamically by the system in response to the overall computing power in the Bit-Coin mining system. It’s public to all and can’t be configured manually. This is not the core of this blog post, so we will skip on this.</p><!--## Mining PoolNow, the problem is clear: as a miner, you want to be make money by mining Bit-Coin. However, if you mine alone (called solo miner), the variance of finding a block is large, which means higher risks.In Bit-Coin, the difficulty is adjusted to ensure that every new block will be found in around $T = 10$ minutes. Suppose the hash compute power of you is $h$, and the overall compute power in Bit-Coin mining is $H$, then in expectation you will find a valid block in $\frac{H}{h} \times T$ minutes. Since the probability of finding a block is the same at any time, the probability distribution adheres to possion distribution. As a result, the probability density function that the player find a block at $t$ is $F(t) = \lambda e ^{\lambda t}$. Note that $\mathbb{E}(tF) = \frac{1}{\lambda}$, so we have $\lambda = \frac{HT}{h}$, the variance of a solo miner is $\text{Var}(F) = \lambda = \frac{HT}{h} \propto \frac{H}{h}$That would be too big and thereby risky for a personal miner, as the proportion of personal hash power is rather small. For example, $H$ is around $800 \text{EH/s}$. $\text{EH/s}$ is a unit which stands for $10^{18}$ hash operation per second. For a personal computer's GPU (e.g. RTX 3090), the hash power $h$ is around $100 {MH/s}$, which is magnitudes smaller than $H$. For some designated hash machines, the $h$ is around $100 {TH/s}$, still much slower than $H$.--><h2 id="Why-do-we-need-a-mining-pool"><a href="#Why-do-we-need-a-mining-pool" class="headerlink" title="Why do we need a mining pool?"></a>Why do we need a mining pool?</h2><p>In short, Bitcoin’s security relies on proof-of-work: miners construct block headers (including a nonce and transactions) and hash them with SHA-256. A block is valid if its hash is below a global difficulty target (equivalently, starts with $z$ leading zero bits). Finding such a hash is probabilistic and computationally intensive. A solo miner with fraction $\alpha$ of the network’s total hash power will on average mine $\alpha$ fraction of the blocks over time.</p><p>Since the difficulty of Bitcoin is dynamically adjusted to maintain an average block interval of around $T = 10 \text{min}$, a solo miner finds a block every $\frac{T}{\alpha}$ on average.</p><p>As finding a valid hash (i.e. starts with $z$ leading zero bits) is random, we may assume the probability density function of finding the first block at time $t$ is modeled by exponential distribution $f(t)$.</p><p>Suppose $f(t) = \lambda e^{-\lambda t}$. Since $\mathbb{E}(t) = \frac{T}{\alpha}$, we have $\lambda = \frac{\alpha}{T}$.</p><ul><li>The variance of $f$ is $\sigma(f) = \frac{1}{\lambda} = \frac{T}{\alpha}$</li></ul><p>However, $\frac{T}{\alpha}$ may be prohibitively large for solo miners. Currently, the overall computation power in Bitcoin mining has reach around $800\text{EH/s}$, which is $8 \times 10^{20}$ hash per second. For a 3090, a common GPU for personal computer, the peak hash power is less than $200\text{MH/s}$, which is $2 \times 10^{8}$. Even for designated ASIC hash machines, their peak hash power can only reach $1000\text{TH/s}$, which is $1 \times 10^{15}$, still orders of magnitude lower.</p><p><img src="https://s2.loli.net/2025/05/26/d5JmjM17oxPA36D.png" alt="SOTA Miner"></p><p><img src="https://s2.loli.net/2025/06/04/Qqmw9LkdEtloP8H.png" alt="Computation Power"></p><h2 id="What-is-a-mining-pool"><a href="#What-is-a-mining-pool" class="headerlink" title="What is a mining pool?"></a>What is a mining pool?</h2><p>While $\frac{T}{\alpha}$ can correspond to years — or even decades — for a solo miner, this level of delay is typically infeasible. A practical solution to mitigate such high variance (and the associated financial risk) is the mining pool.</p><p>In a mining pool, coordinated by a pool operator, each miner performs a share of the total computational. Although only one block will be valid in a round, and only that valid block will make a profit, the miner will evenly distribute the reward $R$ of block to each miner, judged by each one’s contribution.</p><p>The rationale is intuitive: the more work a miner contributes, the more reward they receive. More importantly, participating in a pool significantly reduces the variance in individual earnings - a point we will analyze in more detail two slides later.</p><p>In real-world, it’s infeasible for a mining pool to distribute its income by each one’s real work: it would take equal time to verify the miners submit a nonce with its corresponding hash value.</p><p>To address this, miners do not submit every hash they compute. Instead, similar to Bitcoin’s global difficulty mechanism, miners submit selected (nonce, hash) pairs - known as shares, that satisfy:</p><ul><li>Correctness: $H$(nonce + transaction) = hash</li><li>Difficulty’: hash starts with $z’$ zeros.</li></ul><p>The value of $z’$ is determined by the pool operator and satisfies $0 \le z’ \le z$, where $z$ is the global difficulty. A lower $z’$ allows miners to find shares more frequently, while a higher $z’$ reduces verification overhead for the pool. Pool operators thus choose $z’$ to strike a balance between efficient mining and manageable validation cost.</p><p>So why is the variance reduced? Because the effective difficulty for submitting shares is significantly lower. As a result, miners can find valid shares more frequently. The new expected time to submit a share becomes: $\frac{T}{\alpha} \times 2^{z’ - z}$.</p><p>In practice, mining pools also incur additional overhead. For example, verifying (nonce, hash) pairs requires computational resources, and maintaining the pool server infrastructure adds operational cost. To cover these, pool operators typically take a small portion of the block reward $R$. As a result, the miner’s expected reward per block may be reduced to $\lambda_1 R$ where $0 \le \lambda_1 \le 1$.</p><p>Ultimately, this creates a trade-off: miners gain more stable and predictable returns (lower variance), but at the cost of slightly lower expected rewards. To fight alone or along, which is the right way…</p><p>Next, we will discuss block withholding attack (BWH) on mining pool.</p><h2 id="Why-there-are-Block-Withholding-attacks"><a href="#Why-there-are-Block-Withholding-attacks" class="headerlink" title="Why there are Block Withholding attacks?"></a>Why there are Block Withholding attacks?</h2><p>Not all the miners are honest. Some selfish people may think: Why do I need to submit a valid block to the pool operator? As the reward now is only judged by shares that one submits, one can refuse to submit shares that can be a valid block.</p><p>Although this seems to reduce the average reward per time unit for that miner, the malicious miner may have some compute hash power outside, which may take advantage. In other words, the hash power of a malicious miner can be divided into 2 (and even more) parts: one for dishonest mining, one for mining in other pools or solely. The second part may benefit from undermining the first part.</p><p>As long as the gain from sabotage &gt; loss of withheld rewards, a rational (but selfish) miner may choose to attack.</p><p>Even worse, some mining pools may deliberately encourage such malicious behavior. Since undermining other pools can bring competitive advantages, these evil pools may choose to reward attackers who successfully perform block withholding attacks against their rivals.</p><p>To prove the attack, a malicious miner only needs to show evidence that they found a valid block while mining for another pool, but intentionally withheld it. For example, they can submit the nonce and corresponding hash of that valid block to the sponsoring pool.</p><p>This strategy is known as a sponsored withholding attack. It significantly worsens the problem, turning individual dishonesty into a systemic threat, and may incentivize more miners to engage in block withholding for profit.</p><p>Now, we will prove that BWH may indeed benefit the 3rd-party, and how malicious can benefit from that.</p><h2 id="What-benefit-does-BWH-bring"><a href="#What-benefit-does-BWH-bring" class="headerlink" title="What benefit does BWH bring?"></a>What benefit does BWH bring?</h2><p>For simplicity, suppose there are only $3$ organizations: 2 public pools and 1 sole miner. The hash power fraction of first pool is $p$, and the hash power fraction of second pool is $p’$. The sole miner’s fraction is $\alpha$ and we have $p + p’ + \alpha = 1$.</p><p>Suppose the reward proportion distributed to each from a single pool is $\lambda_1$, which means the pool will keep $1 - \lambda_1$ of the block reward. Suppose reward $R = 1$.</p><p>We assume the sole miner is malicious, and $\beta$ of his hash power is used for attacking the first pool, which is $\alpha \times \beta$.</p><h3 id="Gains-of-the-3rd-party"><a href="#Gains-of-the-3rd-party" class="headerlink" title="Gains of the 3rd party"></a>Gains of the 3rd party</h3><p>First, we will show that BWH can benefit the 3rd-party.</p><p>Without any attack, the gain rate of the second pool is $\frac{p’}{1} = p$. After BWH, the effective overall hash power decreases to $1 - \alpha\beta$, so the new gain rate rises to $\frac{p’}{1 - \alpha\beta}$, with an increase of $\frac{\alpha \beta}{1 - \alpha\beta}p’$.</p><p>Similarly, we can define a similar “reward” proportion for attacking on another pool as $\lambda_2$.</p><h3 id="Gains-of-the-attacker"><a href="#Gains-of-the-attacker" class="headerlink" title="Gains of the attacker"></a>Gains of the attacker</h3><p>We assume attacker seeks maximum profit.</p><p>After joining the first pool, his work proportion is $\frac{\alpha\beta}{p + \alpha\beta}$, but the effective hash power of the first pool is still $p$ alone, as the malicious miner won’t submit any valid blocks. Therefore, he will in all gain $\lambda_1 \frac{\alpha\beta}{p + \alpha\beta} \frac{p}{1 - \alpha\beta}$ from the first pool.</p><p>Since he wants to maximize his profit, he won’t invest his money in other pools (otherwise, $1 - \lambda_1$ proportion will be taken away). He will use all his remaining $\alpha(1 - \beta)$ to mine solely. As a result, he will gain $\frac{\alpha(1 - \beta)}{1 - \alpha\beta}$ from that.</p><p>Finally, he will gain $\lambda_2 \frac{\alpha \beta}{1 - \alpha\beta}p’$ as the reward for betrayal.</p><p>In short, the overall gain of the attacker is:</p><script type="math/tex; mode=display">\begin{aligned}G' = ~ & \lambda_1 \frac{\alpha\beta}{p + \alpha\beta} \frac{p}{1 - \alpha\beta} + \frac{\alpha(1 - \beta)}{1 - \alpha\beta} + \lambda_2 \frac{\alpha \beta}{1 - \alpha\beta}p' \\= ~ & \frac{\alpha}{1 - \alpha\beta}(\lambda_1 \frac{\beta p}{p + \alpha \beta} + 1 - \beta + \lambda_2 \beta (1 - p - \alpha))\end{aligned}</script><p>The extra gain is:</p><script type="math/tex; mode=display">\Delta G = G' - \alpha = \frac{\alpha\beta}{1 - \alpha\beta}(\lambda_1 \frac{p}{p + \alpha \beta} + \alpha - 1 + \lambda_2 (1 - p - \alpha))</script><p>As long as the following formula holds true, the selfish miner can make a profit from the attack.</p><script type="math/tex; mode=display">\lambda_1 \frac{p}{p + \alpha \beta} + \alpha - 1 + \lambda_2 (1 - p - \alpha) > 0</script><p>which can be written in an informative form:</p><script type="math/tex; mode=display">\begin{aligned}\frac{\alpha\beta}{p}& < \frac{\lambda_1 + \lambda_2 (1 - p - \alpha) - (1 - \alpha)}{1 -\alpha - \lambda_2(1 - p - \alpha)} \\& = \frac{\lambda_1}{1 -\alpha - \lambda_2(1 - p - \alpha)} - 1 \\\end{aligned}</script><p>We will discuss the following formula in some special cases:</p><h3 id="Genuine-Bad-Guy"><a href="#Genuine-Bad-Guy" class="headerlink" title="Genuine Bad Guy"></a>Genuine Bad Guy</h3><p>$\lambda_2 \to 1$</p><p>In this case, as long as $\alpha \beta + p &lt; \lambda_1$, the attacker can benefit. Since $\lambda_1$ is close to $1$, this will always hold.</p><h3 id="No-sponsorship"><a href="#No-sponsorship" class="headerlink" title="No sponsorship"></a>No sponsorship</h3><p>$\lambda_2 \to 0$</p><p>In this case, we need $\frac{\alpha\beta}{p} &lt; \frac{\lambda_1}{1 - \alpha} - 1$. If $\alpha \le 1 - \lambda_1$, then it’s impossible for the miner to benefit from BWH.</p><h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><p>In short, the more incentive (larger $\lambda_2$), the more beneficial the attack is.</p><p>Here are some figures: (y-axis is $\dfrac{\Delta G}{\alpha}$)</p><div class="gallery-container" data-type="data" data-button="" data-limit="10" data-first="10">    <div class="gallery-items">[{"url":"https://s2.loli.net/2025/06/04/gMYBjUe4Jw1kWXp.png","alt":"image.png","title":""},{"url":"https://s2.loli.net/2025/06/04/DlKb6IRtL7rmhPF.png","alt":"image.png","title":""},{"url":"https://s2.loli.net/2025/06/04/jBM65zhPHxVQblp.png","alt":"image.png","title":""}]</div>  </div><p>$\lambda_1 = 1, p = 0.2, \alpha=0.02$, where $\lambda_2 = 0, 0.2, 1$</p><div class="gallery-container" data-type="data" data-button="" data-limit="10" data-first="10">    <div class="gallery-items">[{"url":"https://s2.loli.net/2025/06/04/ArFgDkTjPUOL4wW.png","alt":"image.png","title":""},{"url":"https://s2.loli.net/2025/06/04/ArFgDkTjPUOL4wW.png","alt":"image.png","title":""},{"url":"https://s2.loli.net/2025/06/04/yCjziIHSvZBm12k.png","alt":"image.png","title":""}]</div>  </div><p>$\lambda_1 = 0.9, p = 0.2, \alpha=0.02$, where $\lambda_2 = 0, 0.2, 0.9$</p><h3 id="Better-attack-strategy"><a href="#Better-attack-strategy" class="headerlink" title="Better attack strategy"></a>Better attack strategy</h3><p>In fact, the miner may attack several pools. Consider $\frac{\Delta G}{\alpha\beta}$. Let $\gamma = \alpha\beta$, then we have:</p><script type="math/tex; mode=display">\frac{\Delta G}{\alpha\beta} =  \frac{1}{1 - \gamma}(\lambda_1 \frac{p}{p + \gamma} - c), c \in [p, 1 - \alpha]</script><p>This function is always descending with respect to $\gamma$, so the best strategy of a selfish miner is to split his attack across different mining pools. That is, he can attack not only the first pool but even the second pool, which rewarded him to attack the first pool. And the theoretical upper bound of his attack is</p><script type="math/tex; mode=display">\lambda_1 + \lambda_2 (1 - p - \alpha) - (1 - \alpha)</script><p>exactly when $\beta \to 0$.</p><div class="gallery-container" data-type="data" data-button="" data-limit="10" data-first="10">    <div class="gallery-items">[{"url":"https://s2.loli.net/2025/06/04/f8ICuD13mVkTLXb.png","alt":"image.png","title":""},{"url":"https://s2.loli.net/2025/06/04/AZfBSoROmD1h3KN.png","alt":"image.png","title":""},{"url":"https://s2.loli.net/2025/06/04/kKCcaQvm2BW7jXt.png","alt":"image.png","title":""}]</div>  </div><p>$\lambda_1 = 0.9, p = 0.2, \alpha=0.02$, where $\lambda_2 = 0, 0.2, 0.9$. y-axis is $\dfrac{\Delta G}{\alpha \beta}$.</p><h2 id="Possible-Consequence-of-BWH"><a href="#Possible-Consequence-of-BWH" class="headerlink" title="Possible Consequence of BWH"></a>Possible Consequence of BWH</h2><p>These dynamics create a “pool game”. If a pool $P$ is attacked, its miners’ revenue density falls. Rational miners might then leave $P$ for more profitable pools, further weakening $P$. If $P’$ gains (and pays the attacker), $P’$’s miners see higher revenue density. In equilibrium, pools could be tricked to attack others to gain an advantage, potentially leading to a “race to the bottom” where all pools lose.</p><p>Imagine there are multiple attacks between pools, it will result in a sharp decline in effective hash power: much of them are wasted in BWH.</p><p>Thus, BWH (classical or sponsored) undermines pool stability and Bitcoin stability: it can drive small pools out of business and cause mining resources to concentrate.</p><h2 id="How-to-defend-against-BWH"><a href="#How-to-defend-against-BWH" class="headerlink" title="How to defend against BWH?"></a>How to defend against BWH?</h2><p>How to defend against BWH? The key insight is that: every miner could easily tell between a valid block and a normal share. As a result, they have the freedom not to submit those valid blocks, which may potentially harm those honest miners.</p><p>To fundamentally solve the issue, we should come up with cryptographic methods that guarantee the miner couldn’t tell between a valid block and a normal share. In this way, a miner who withholds any hash would not know if she was giving up a block or just an ordinary share, and he can’t selectively submit those non-block shares, which will stop BWH.</p><h3 id="Method-01"><a href="#Method-01" class="headerlink" title="Method-01"></a>Method-01</h3><p>In the paper “Bitcoin Block Withholding Attack: Analysis and Mitigation”, the following approach is proposed:</p><ol><li>The mining pool find a random string $r \in {0,1}^{z - z’}$ and another random string $s \in {0,1}^*$. Let $p = H(r || s)$</li><li>Both $z’$ and $p$ is made public. Note that the protocol of Bitcoin needs to be changed in this case, as part of the header.</li><li>The pool receives pool shares (partial proofs) from miners that its hash starts with $z’$ zeros.</li><li>In the new protocol, a block is valid if it starts with $z’$ zeros, followed by a new nonce $r$. So a pool operator just need to check whether the next $z - z’$ bits of is $r$.</li></ol><p>The approach above is as difficult as the old approach. Since the special nonce $r$ is sealed into $p$, which will be used in computing hash, it’s impossible to cheat by finding $r$ faster than brute force where:</p><script type="math/tex; mode=display">H(\cdots H(r||s) \cdots n \cdots) = 0^{z'} || r || \{0,1\}^{256 - z}</script><p>Consequently, the target is quite similar: for a fixed $r$, find some nonce $n$ such that its prefix $z’ + z - z’ = z$ bits are fixed as $0^{z’} || r$. The key insight of this approach is that miners can’t find the $r$, so they can’t tell between shares and valid blocks. The verification of a block can be done by a pool operator.</p><p>Sadly, this approach requires modification of the protocol of Bitcoin.</p><h3 id="Method-02"><a href="#Method-02" class="headerlink" title="Method-02"></a>Method-02</h3><p>Let’s review the process of block withholding attack. How Can we directly detect that? A prominent feature of BWH is that: one never submits valid blocks. So, a naive idea is that: we reward those valid blocks. This is a naive fusion of mining pool and sole mining.</p><p>As long as submitting a valid block to the pool is more profitable than to its rival, a greedy miner will do the right thing.</p><p>We will introduce a potential workaround for BWH in the next slide.</p><p>Suppose the reward ratio for a non-block share is $\lambda_3$, the share-block ratio is $\mu = 2 ^{z - z’} &gt; 1$, and the block reward ratio is $\lambda_4$. Assume the pool operator keeps the same proportion as before, then we have:</p><script type="math/tex; mode=display">\frac{1}{\mu} ((\mu - 1) \cdot \lambda_3 + 1 \cdot \lambda_4) = \lambda_1</script><p>We can then let $\lambda_3 = \lambda_1 - \delta, \lambda_4 = \lambda_1 + (\mu - 1) \delta$.</p><p>The effective $\lambda_1$ now drops to $\lambda_3 = \lambda_1 - \delta$.\</p><p>Note that this is not a free lunch. As $\delta$ grows larger, it will degenerate to sole mining, which means the variance will also grow larger and unacceptable. It’s yet another trade-off.</p>]]></content>
    
    
    <summary type="html">Introduction to Block Withholding Attack in PoW Blockchain.</summary>
    
    
    
    <category term="计算机" scheme="http://darksharpness.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    <category term="区块链" scheme="http://darksharpness.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
    <category term="作业" scheme="http://darksharpness.github.io/tags/%E4%BD%9C%E4%B8%9A/"/>
    
  </entry>
  
  <entry>
    <title>My Windows Terminal Configuration</title>
    <link href="http://darksharpness.github.io/env-shell/"/>
    <id>http://darksharpness.github.io/env-shell/</id>
    <published>2025-05-02T09:22:43.000Z</published>
    <updated>2025-05-02T11:35:16.149Z</updated>
    
    <content type="html"><![CDATA[<p>The week before the last week, when I was at home connected to remote machine, it suddenly came to me that I should learn more about the shell I’m using: Windows Terminal. As a result, I started to collect information on the internet and configure my terminal.</p><p>When doing experiment on remote machines, I’d prefer to use built-in shell rather than VScode integrated shell. The motivation is simple: I like a bigger full-screen terminal, and I think VSCode is just a code editor (easier than Vim). When tons of experiments are running, I think a stand-alone terminal is more efficient than VSCode integrated shell.</p><p>First of all, I learned some shortcuts for basic control of Windows terminal.</p><ul><li><code>Shift Alt +</code>: Duplicate a new panel in the right. (horizontal split)</li><li><code>Shift Alt -</code>: Create a new panel in the bottom. (vertical split)</li><li><code>Alt LeftArrow</code>: Move the focus to panel in the left.</li><li><code>Alt RightArrow</code>: Move the focus to panel in the right.</li><li><code>Alt DownArrow</code>: Move the focus to panel in the bottom.</li><li><code>Alt UpArrow</code>: Move the focus to panel above.</li><li><code>Ctrl Shift W</code>: Close current terminal.</li><li><code>Ctrl Shift T</code>: Create a new terminal in a new page (use <code>Ctrl + Tab</code> to switch between).</li><li><code>Ctrl ,</code>: Open setting with UI.</li><li><code>Ctrl Shift ,</code>: Open <code>setting.json</code>.</li></ul><p>These are the most useful shortcuts for me. I’m accustomed to split the terminal into 4 smaller panels once I start it. This is really useful on a large screen (e.g. my <code>3840x2160</code> screen at home).</p><p>At first, I wanted to install a <code>omz</code>-like plugin for my powershell, and found <code>omposh</code>. But I soon realized that the only usage of my Windows terminal is to connect to remote machines via <code>ssh</code> or test locally with <code>wsl</code>, so I gave up. Nevertheless, following the instruction of <code>omposh</code>, I still install some fonts needed by <code>omz</code>. In the past, my default Windows OS lack some icons necessary for <code>powerlevel10k</code> (a theme for <code>zsh</code>), so I can’t exploit the full potential of it. Now, my computer is equipped with <a href="https://www.nerdfonts.com/">the nerd font</a>, and everything is going well. Particularly, if you want to enable this font in your integrated shell in VScode, just update the setting <code>terminal.integrated.fontFamily</code> (you just need to add a line in your VSCode <code>setting.json</code>). I myself randomly choose <a href="https://www.nerdfonts.com/font-downloads">Inconsolata Nerd Font</a>.</p><p>The most important thing for a terminal must be a beautiful background. We just need to change the <code>defaults</code> field of <code>profiles</code>.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&quot;profiles&quot;: </span><br><span class="line">&#123;</span><br><span class="line">    &quot;defaults&quot;: </span><br><span class="line">    &#123;</span><br><span class="line">        &quot;backgroundImage&quot;: &quot;D:\\...\\114498589_p0.jpg&quot;,</span><br><span class="line">        &quot;backgroundImageOpacity&quot;: 0.1,</span><br><span class="line">        &quot;background&quot;: &quot;#0c0f16&quot;,</span><br><span class="line">        &quot;font&quot;:</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;face&quot;: &quot;Inconsolata Nerd Font&quot;,</span><br><span class="line">            &quot;size&quot;: 16</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;unfocusedAppearance&quot;:</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;backgroundImageOpacity&quot;: 0.02</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;scrollbarState&quot;: &quot;hidden&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>You can find more detailed configuration <a href="https://learn.microsoft.com/en-us/windows/terminal/customize-settings/profile-appearance">here</a>. For me, setting opacity of terminal is never a wise choice, since we can use <code>Ctrl + Shift + Scroll</code> to adjust the opacity of the terminal manually. In 99% cases, I won’t take any advantage of the opacity and opacity will just mess things up (lessons learnt from my VSCode configuration).</p><p>My background photo is this one, just as the front cover of this post:</p><p><img src="https://s3.bmp.ovh/imgs/2024/01/19/1d88e2436576d55c.jpg" alt="Artwork 114498589 by endlesscat"></p><p>You can find the original artwork here in <a href="https://www.pixiv.net/artworks/114498589">pixiv</a>.</p>]]></content>
    
    
    <summary type="html">This is the first time I write my BLOG in English.</summary>
    
    
    
    <category term="计算机" scheme="http://darksharpness.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    <category term="工具" scheme="http://darksharpness.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="基础知识" scheme="http://darksharpness.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Effective Modern C++</title>
    <link href="http://darksharpness.github.io/cppModern/"/>
    <id>http://darksharpness.github.io/cppModern/</id>
    <published>2025-04-07T01:42:39.000Z</published>
    <updated>2025-04-14T18:38:14.498Z</updated>
    
    <content type="html"><![CDATA[<p>难绷的被下一届的同学拉去给下下届讲 Modern C++ (不过笔者咕咕了). 想了半天, 最后还是决定讲讲 modern effective C++, 也算是笔者的启蒙读本了… 那也是 23 年春节的回忆, 转眼就过去两年了, 这两年笔者又学了些什么呢…</p><p>anyway, 不说废话了, 管理每小节开头给出所有用到的 <code>cppreference</code> 或者其他相关链接.</p><p>一些笔者平时看的链接: <a href="https://en.cppreference.com/">cppreference</a>, <a href="https://www.rust-lang.org/">rust-lang</a>, <a href="https://wanghenshui.github.io/cppweeklynews/">cppweekly 群友版</a></p><p>笔者写 C++ 的核心要义就这些:</p><ol><li>best effort 尽力优化性能, 但是不要试图认为自己比编译器聪明. 养成习惯就是随手的事情了.</li><li>做好抽象和封装, 把一些内部的逻辑/可能是不安全的操作封装起来, 对外只暴露必要的接口 API, 不要留任何可能带来问题的后门, 这些都是给自己埋雷…</li><li>尽量做好解耦, 每个模块只干自己的事情. 最好的办法就是模块内的变量/函数不要对外公开, 多分函数/作用域尽量减少变量名泄露的到处都是, 多用 lambda 函数且只捕获需要的.</li><li>做好防御式编程, 可以开一个只在 debug 模式验证的宏, 做好边界检查.</li><li><del>永远用最新的 C++ 标准</del></li></ol><h2 id="从值类型到类型推导"><a href="#从值类型到类型推导" class="headerlink" title="从值类型到类型推导"></a>从值类型到类型推导</h2><p>参考内容 <a href="https://cntransgroup.github.io/EffectiveModernCppChinese/1.DeducingTypes/item1.html">Effective Modern C++</a> Item 1, 23, 24. 虽然本文基本都是笔者口胡.</p><h3 id="左值和右值"><a href="#左值和右值" class="headerlink" title="左值和右值"></a>左值和右值</h3><p><a href="https://en.cppreference.com/w/cpp/language/value_category">Value Category</a></p><blockquote><p>Remark: 请牢记: C++ 移动在语义希望达成的是, 所有权的转移. 推荐读者在实践中, 要么是 fallback 到 copy, 要么就是移走资源.</p></blockquote><p>学完程序设计课之后, 大部分人都知道了 C++11 出了左值和右值这个东西, 但大概率是没有分太清楚的. 这里会简单介绍一下.</p><p>首先, 笔者假定读者能区分一个表达式的返回类型是不是值类型, 比如字面量 (除了字符串), 整数加减法 <code>a + b</code>, 或者返回类型是不含引用 <code>&amp;</code> 的函数, 又或者是 <code>static_cast</code> 为值类型, 这些表达式返回的一定是值类型.</p><p>区分不同的值类型, 一个最简单的规则是, <strong>有名字的东西</strong>一定是左值引用 <code>lvalue</code>, <code>std::move</code> 几乎必须作用于一个有名字的变量, 返回的是右值引用 <code>xvalue</code>, 而其他的返回值的表达式, 返回的是纯右值 <code>prvalue</code>, 函数结果则完全视其返回类型. 我们一般把后两者统称 <code>rvalue</code>, 前两者统称 <code>glvalue</code>. 这三个东西有什么区别呢? 如果你学过 rust, 你就知道有一个概念叫做生命周期, 而这里可以用生命周期来不严谨的解释一下: 对于 <code>lvalue</code> 和 <code>xvalue</code>, 他们都不涉及生命周期的相关的事情, 但对于 <code>prvalue</code>, 在整个表达式被执行结束之后, 它返回的值类型需要被析构.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> &amp;<span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> &amp;&amp;y)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">int</span>(x); <span class="comment">// as prvalue</span></span><br><span class="line">    x;      <span class="comment">// as lvalue</span></span><br><span class="line">    <span class="built_in">func</span>(); <span class="comment">// as lvalue</span></span><br><span class="line">    <span class="built_in">test</span>(); <span class="comment">// as prvalue</span></span><br><span class="line">    x + x;  <span class="comment">// as prvalue (but custom operator may not follow this)</span></span><br><span class="line">    <span class="built_in">static_cast</span>&lt;<span class="type">long</span>&gt;(x);   <span class="comment">// as value</span></span><br><span class="line">    std::<span class="built_in">move</span>(x);           <span class="comment">// as xvalue</span></span><br><span class="line">    <span class="built_in">static_cast</span>&lt;<span class="type">int</span> &amp;&amp;&gt;(x); <span class="comment">// same as above</span></span><br><span class="line">    <span class="built_in">static_cast</span>&lt;<span class="type">int</span> &amp;&amp;&gt;(y); <span class="comment">// as xvalue</span></span><br><span class="line">    y;                      <span class="comment">// as left reference (because named as `y`)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">str</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(std::string)</span></span>;</span><br><span class="line"><span class="function">std::string &amp;&amp;<span class="title">strange_func</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">strange_func2</span><span class="params">(std::string &amp;&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lifespan</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        std::string x;</span><br><span class="line">    &#125; <span class="comment">// x will call ~string(); after it dies.</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">func</span>(<span class="built_in">str</span>());</span><br><span class="line">    <span class="comment">// the code above is very similar to the code below</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> tmp = <span class="built_in">str</span>();</span><br><span class="line">        <span class="built_in">func</span>(<span class="built_in">static_cast</span>&lt;std::string &amp;&amp;&gt;(tmp));</span><br><span class="line">    &#125; <span class="comment">// after evaluation of func, the temporary value returned will be destructed</span></span><br><span class="line">    <span class="built_in">strange_func2</span>(t); <span class="comment">// similar to above, the temporary will be binded and then destroyed</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">func</span>(<span class="built_in">strange_func</span>()); <span class="comment">// this will construct an std::string, then destroy after func</span></span><br><span class="line">    <span class="built_in">strange_func2</span>(<span class="built_in">strange_func</span>()); <span class="comment">// this will not call any ~string(); no lifespan is ended</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特别注意的是, 右值引用的变量, 它看起来是一个 <code>rvalue</code> 之类的东西, 但根据我们的 “有名字” 原则, 它返回的其实是一个 <code>lvalue</code>. 事实上, 所谓的右值引用, 和左值引用, 他们起到的只是影响重载决议的作用. 两者都是引用, 实现上几乎 100% 是由指针实现 (事实上, 笔者一直把引用当作一种保证非空的指针的语法糖). 换句话说, 只有在编译期选择对应的函数的时候, 这两个东西才会起到区分的作用. 只是一般来说, 大家会认为接收到右值引用的时候, 传入的对象即将被析构, 所以可以 “移走” 它的资源, 故称作 <code>move</code>.</p><p>所以, 读者想必可以理解为什么 <code>std::move</code> 几乎一定作用在一个有名字的变量上, 它的作用就是告诉编译器, 请选择右值引用相关的重载. 实际上, 他就等于 <code>static_cast&lt;T &amp;&amp;&gt;</code> 强行转化, 算是标准库提供的语法糖. <strong>一般来说</strong>, 通过右值进行的移动构造, 因为允许从传入的对象中接管资源 (e.g. <code>std::vector</code> 的内部数据的指针, <code>std::shared_ptr</code> 的指针), 往往会比 copy 更加高效. (当然, 这也只是君子协议, 如果用户没有实现移动构造, 或者故意在移动构造里面 <code>while(1)</code> 卡住, 那也是没有办法的事, 毕竟编译器只负责帮你选择应该调用的函数.)</p><p><strong>特别需要注意的是</strong>, <code>std::move</code> 无法改变 <code>const</code> 属性, 如果你希望通过 <code>move</code> 收益, 请确保入参没有 <code>const</code>.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A sample implementation of std::move</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">typename</span> std::remove_reference&lt;_Tp&gt;::<span class="function">type&amp;&amp;</span></span><br><span class="line"><span class="function"><span class="title">move</span><span class="params">(_Tp&amp;&amp; <span class="type">__t</span>)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> std::remove_reference&lt;_Tp&gt;::type&amp;&amp;&gt;(<span class="type">__t</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// good, always need to move since named parameter is `lvalue`</span></span><br><span class="line">    <span class="built_in">MyClass</span>(std::string a, std::string &amp;b, std::string &amp;&amp;c):</span><br><span class="line">        <span class="built_in">m_a</span>(std::<span class="built_in">move</span>(a)), <span class="built_in">m_b</span>(std::<span class="built_in">move</span>(b)), <span class="built_in">m_c</span>(std::<span class="built_in">move</span>(c)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// bad, move a const will not work. `const &amp;&amp;` is completely useless! never use it!</span></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">const</span> std::string a, <span class="type">const</span>  std::string &amp;b, <span class="type">const</span> std::string &amp;&amp;c):</span><br><span class="line">        <span class="built_in">m_a</span>(std::<span class="built_in">move</span>(a)), <span class="built_in">m_b</span>(std::<span class="built_in">move</span>(b)), <span class="built_in">m_c</span>(std::<span class="built_in">move</span>(c)) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string m_a;</span><br><span class="line">    std::string m_b;</span><br><span class="line">    std::string m_c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在铺垫了这么多值类型之后, 可以来讲讲模板的类型推导了. 在这里, 笔者将忽略 <code>volatile</code> 这个病态的东西.</p><h3 id="推导的类型是一个引用"><a href="#推导的类型是一个引用" class="headerlink" title="推导的类型是一个引用"></a>推导的类型是一个引用</h3><p><a href="https://cntransgroup.github.io/EffectiveModernCppChinese/1.DeducingTypes/item1.html">Item 1</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(T &amp;)</span></span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cfunc</span><span class="params">(<span class="type">const</span> T &amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> &amp;<span class="title">ref</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> &amp;y = x;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> z = x;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;w = y;</span><br><span class="line"></span><br><span class="line"><span class="built_in">func</span>(x); <span class="comment">// [T = int]</span></span><br><span class="line"><span class="built_in">func</span>(y); <span class="comment">// [T = int]</span></span><br><span class="line"><span class="built_in">func</span>(z); <span class="comment">// [T = const int]</span></span><br><span class="line"><span class="built_in">func</span>(w); <span class="comment">// [T = const int]</span></span><br><span class="line"><span class="built_in">func</span>(<span class="built_in">ref</span>()); <span class="comment">// [T = int]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// func(1); // prvalue not acceptable</span></span><br><span class="line"><span class="comment">// func(std::move(x)); // xvalue not acceptable</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cfunc</span>(x); <span class="comment">// [T = int]</span></span><br><span class="line"><span class="built_in">cfunc</span>(y); <span class="comment">// [T = int]</span></span><br><span class="line"><span class="built_in">cfunc</span>(z); <span class="comment">// [T = int]</span></span><br><span class="line"><span class="built_in">cfunc</span>(w); <span class="comment">// [T = int]</span></span><br><span class="line"><span class="built_in">cfunc</span>(<span class="built_in">ref</span>()); <span class="comment">// [T = int]</span></span><br><span class="line"><span class="built_in">cfunc</span>(<span class="number">1</span>);     <span class="comment">// [T = int], the integer will be destroyed after func returns, though do nothing.</span></span><br><span class="line"><span class="built_in">cfunc</span>(std::<span class="built_in">move</span>(x)); <span class="comment">// [T = int]</span></span><br></pre></td></tr></table></figure><p>这个 case 相对比较简单, <code>func</code> 要求传入的值一定是一个 <code>lvalue</code>, <code>T</code> 会保留传入参数是否是 <code>const</code>, 并且是不含引用的值类型. 而 <code>cfunc</code> 则比较特殊, 它可以接受任何类型的值, <code>T</code> 会被推导为不含 <code>const</code> 和引用的类型. 读者或许可以联想到上学期讲到的 <code>const &amp;</code> 可以绑定一切并延长 <code>prvalue</code> 的生命周期, 道理的确是类似的.</p><h3 id="推导的类型是一个指针"><a href="#推导的类型是一个指针" class="headerlink" title="推导的类型是一个指针"></a>推导的类型是一个指针</h3><p><a href="https://cntransgroup.github.io/EffectiveModernCppChinese/1.DeducingTypes/item1.html">Item 1</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(T *)</span></span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cfunc</span><span class="params">(<span class="type">const</span> T *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;y = x;</span><br><span class="line"><span class="built_in">func</span>(&amp;x); <span class="comment">// [T = int]</span></span><br><span class="line"><span class="built_in">func</span>(&amp;y); <span class="comment">// [T = const int]</span></span><br><span class="line"><span class="built_in">cfunc</span>(&amp;x); <span class="comment">// [T = int]</span></span><br><span class="line"><span class="built_in">cfunc</span>(&amp;y); <span class="comment">// [T = int]</span></span><br></pre></td></tr></table></figure><p>规则几乎和引用完全一样. 唯一特殊的是, 入参必须是指针类型, 并且不存在 <code>const *</code> 可以延长生命周期之类的, 这是因为我们不存在左右指针这回事.</p><p>特别注意的是, 只有 <code>lvalue</code> 可以被 take address, <code>xvalue</code> 和 <code>prvalue</code> (即 <code>rvalue</code>) 是不行的. 举例:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> &amp;&amp;<span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">g</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// all the code below is illegal</span></span><br><span class="line">&amp;(<span class="built_in">f</span>());</span><br><span class="line">&amp;(<span class="built_in">g</span>());</span><br><span class="line">&amp;(<span class="built_in">f</span>() + <span class="built_in">g</span>());</span><br><span class="line">&amp;(<span class="built_in">static_cast</span>&lt;<span class="type">int</span> &amp;&amp;&gt;(x))</span><br></pre></td></tr></table></figure><h3 id="推导的类型是一个通用引用"><a href="#推导的类型是一个通用引用" class="headerlink" title="推导的类型是一个通用引用"></a>推导的类型是一个通用引用</h3><p><a href="https://cntransgroup.github.io/EffectiveModernCppChinese/1.DeducingTypes/item1.html">Item 1</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(T &amp;&amp;param)</span></span>;</span><br></pre></td></tr></table></figure><p>这是一个非常特殊的 case, 要理解这个 case, 我们首先要了解万能引用, 以及理解 <code>std::forward</code>, 以及引用折叠.</p><p>考虑以下的引用场景: 你为用户提供了一个包装函数, 你可能会把用户的入参传给内部调用的另一个函数. 同时, 你希望有更好的泛化性, 用的是模板. 自然, 用户有的时候传入的是左值, 有的时候是右值, 你希望把这个左还是右的信息原封不动的传给内部调用的那个函数. 这时候, 就需要用到 <code>std::forward</code>.</p><p>简单来说, <code>std::forward</code> 功能是, 如果传入的是 <code>lvalue reference</code>, 那么就返回一个 <code>lvalue</code>; 如果传入的是 <code>rvalue reference</code>, 那就返回一个 <code>xvalue</code>, 此时类似 <code>std::move</code>. (需要注意, 入参不做任何操作的话, 一定是被当作 <code>lvalue</code> 的, 因为它 “有名字”)</p><p>而入参同时接受左/右值, 这就需要用到 <strong>通用引用</strong>, 或者说 <strong>万能引用</strong>. 在上述代码中, 如果传入的是一个 <code>lvalue</code> 类型比如 <code>int &amp;</code>, 那么 <code>T</code> 会被推导为 <code>int &amp;</code>, 同时 <code>param</code> 的类型应当是 <code>int &amp; &amp;&amp;</code>. 这看起来很奇怪, 因为这里需要 <strong>引用折叠</strong> 的概念. 简单来说, 在推导的过程中, 这里 <code>param</code> 的类型会被折叠为 <code>int &amp;</code>. 而如果传入的是一个 <code>rvalue</code> 类型比如 <code>int &amp;&amp;</code> 或者 <code>int</code>, 那么 <code>T</code> 会被推导为 <code>int</code> 本身, <code>param</code> 就是 <code>int &amp;&amp;</code> 类型, 没有什么歧义.</p><p>那 <code>std::forward</code> 是怎么工作的呢, 我们需要在 <code>func</code> 内部调用 <code>std::forward&lt;T&gt;</code>. 当 <code>T</code> 是引用类型的时候, 他会返回一个 <code>lvalue</code>; 反之, 则类似 <code>std::move</code> 返回一个 <code>xvalue</code>. 这其实就对应了入参推导 <code>T</code> 的两种 case. 参考实现如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> _Tp&amp;&amp;</span></span><br><span class="line"><span class="function"><span class="title">forward</span><span class="params">(<span class="keyword">typename</span> std::remove_reference&lt;_Tp&gt;::type&amp; <span class="type">__t</span>)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;_Tp&amp;&amp;&gt;(<span class="type">__t</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> _Tp&amp;&amp;</span></span><br><span class="line"><span class="function"><span class="title">forward</span><span class="params">(<span class="keyword">typename</span> std::remove_reference&lt;_Tp&gt;::type&amp;&amp; <span class="type">__t</span>)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;_Tp&amp;&amp;&gt;(<span class="type">__t</span>); &#125;</span><br></pre></td></tr></table></figure><p>现在来看看 Modern Effective C++ Item 1 具体的例子:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; param)</span></span>;</span><br><span class="line"><span class="type">int</span> x = <span class="number">27</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> cx = x;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;rx = cx;</span><br><span class="line"><span class="built_in">f</span>(x);   <span class="comment">// [T = int &amp;, T&amp;&amp; = int &amp;]</span></span><br><span class="line"><span class="built_in">f</span>(cx);  <span class="comment">// [T = const int &amp;, T&amp;&amp; = const int &amp;]</span></span><br><span class="line"><span class="built_in">f</span>(rx);  <span class="comment">// [T = const int &amp;, T&amp;&amp; = const int &amp;]</span></span><br><span class="line"><span class="built_in">f</span>(<span class="number">27</span>);  <span class="comment">// [T = int, T&amp;&amp; = int &amp;&amp;]</span></span><br></pre></td></tr></table></figure><h3 id="推导的类型是一个值类型"><a href="#推导的类型是一个值类型" class="headerlink" title="推导的类型是一个值类型"></a>推导的类型是一个值类型</h3><p><a href="https://cntransgroup.github.io/EffectiveModernCppChinese/1.DeducingTypes/item1.html">Item 1</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(T)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> &amp;y = x;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> z = x;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;w = y;</span><br><span class="line"><span class="built_in">func</span>(x); <span class="comment">// [T = int]</span></span><br><span class="line"><span class="built_in">func</span>(y); <span class="comment">// [T = int]</span></span><br><span class="line"><span class="built_in">func</span>(z); <span class="comment">// [T = int]</span></span><br><span class="line"><span class="built_in">func</span>(w); <span class="comment">// [T = int]</span></span><br></pre></td></tr></table></figure><p>这个非常特别, 这意味着无论入参是什么, 如果是推导的话一定会拷贝一份新的对象, 并且 <code>T</code> 类型推导出来不会含有引用和 <code>const</code>. (当然, 用户也可以强行指定模板的类型 <code>T</code> 为含有引用的类型).</p><p>需要注意, 这里推导出来不会含有 <code>const</code> 指的是值类型本身, 如果传入的类型是 <code>const int *</code> 之类的 <code>const</code> 指针, 指向内容的 <code>const</code> 性自然是不能变的.</p><h3 id="边角料"><a href="#边角料" class="headerlink" title="边角料"></a>边角料</h3><p><a href="https://cntransgroup.github.io/EffectiveModernCppChinese/1.DeducingTypes/item1.html">Item 1</a></p><p>比较恶心的是数组实参和函数实参.</p><p>在推导值类型或者指针类型的时候, 数组会退化为指针, 函数同理. 在推导引用相关类型的时候, 数组会被推导为特殊的数组引用, 函数同理.</p><h3 id="auto-推导"><a href="#auto-推导" class="headerlink" title="auto 推导"></a>auto 推导</h3><p><a href="https://cntransgroup.github.io/EffectiveModernCppChinese/1.DeducingTypes/item1.html">Item 1</a></p><p><code>auto</code> 作为 C++11 的一大亮点, 自然是不会拉下的. <code>auto</code> 的类型推导规则几乎和函数一致, 例如 <code>auto</code> 对应的是推导值类型, <code>auto &amp;</code> 和 <code>const auto &amp;</code> 是推导一般的引用类型, 而 <code>auto &amp;&amp;</code> 则是万能引用推导. 特别地, 相信大家也在程序设计课上了解过, <code>const auto &amp;</code> 可以接受一个 <code>rvalue</code> 对象. 更加特别地, 如果 <code>const auto &amp;</code> 或者 <code>auto &amp;&amp;</code> 绑定的是一个 <code>prvalue</code>, 那么它可以延长这个 <code>prvalue</code> 的生命周期, 直到 <code>auto</code> 的这个变量离开作用域之后, 才析构. 对于 <code>xvalue</code>, 由于其并非返回一个临时的值, 编译器不会去管它的生命周期, 因此也不存在延长不延长一说.</p><p>比较恶心的是, <code>auto</code> 如果用初始化列表初始化, 会有一些奇怪的行为. 对于一个函数模板推导, 传入一个初始化列表一样的东西比如 <code>&#123;1, 2, 3&#125;</code> 是无法工作的. 但对于 <code>auto</code> 声明变量, 这个是允许的.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> x = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; <span class="comment">// deduced as std::initializer_list&lt;int&gt;</span></span><br><span class="line"><span class="keyword">auto</span> y = &#123;<span class="number">1</span>, <span class="number">2.0</span>&#125;;  <span class="comment">// failure in deduction</span></span><br><span class="line"><span class="keyword">auto</span> z &#123;<span class="number">1</span>&#125;;         <span class="comment">// deduced as int</span></span><br></pre></td></tr></table></figure><p>特别地, C++14 以后也允许了 <code>auto</code> 作为返回类型 (即不含尾置的返回类型), C++11 lambda 函数不写返回类型的话也是默认以 <code>auto</code> 返回, 此时会按照类似的规则进行推导. 如果是返回的是 <code>auto &amp;</code> 则同理. lambda 函数的参数中的 <code>auto</code> 和 C++20 以后函数参数中的 <code>auto</code> 也同理.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">func</span><span class="params">(<span class="type">int</span> &amp;x, <span class="type">int</span> &amp;y)</span> -&gt; <span class="keyword">auto</span> &amp; </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; y)</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line">[](<span class="type">const</span> <span class="keyword">auto</span> &amp;x) &#123; <span class="keyword">return</span> x; &#125; (<span class="number">1</span>); <span class="comment">// lambda, auto deduced as `int`, return `int`.</span></span><br></pre></td></tr></table></figure><h2 id="语言特性"><a href="#语言特性" class="headerlink" title="语言特性"></a>语言特性</h2><h3 id="inline-和-static"><a href="#inline-和-static" class="headerlink" title="inline 和 static"></a>inline 和 static</h3><p><a href="https://en.cppreference.com/w/cpp/language/inline">inline</a>, <a href="https://en.cppreference.com/w/cpp/language/storage_duration#Static_block_variables">static</a></p><p><code>inline</code> 和 <code>static</code> 都属于是语言中存在很久的关键词了, 早在 C 里面就已经存在. 然而, 很多人对这两个关键词存在一定的误区.</p><p><code>inline</code> 关键词 在 C++ 中和所谓的内联优化可以说没有一点关系. 这么说可能比较绝对, 但是为了便于读者区分, 建议读者也这么来理解. <code>inline</code> 的作用是告诉编译器, 这个符号允许被多次定义, 即在多个编译单元中出现.</p><p>这里首先要铺垫一下, 编译单元是什么. 在传统的算法竞赛题里面, 只有一个 <code>main.cpp</code>, 那么编译单元就只有这一个 <code>main.cpp</code>. 其他的文件都是被 <code>#include</code> 加进来的, 而众所周知, <code>#include</code> 其实就是文本替换, 把代码里面的文本复制了进来. 而一般大一点的 C++ 项目, 我们往往会看到一个 <code>CMakeLists.txt</code>, 其中经常会列出若干 <code>cpp</code> 文件, 例如 <code>src/1.cpp, src/2.cpp</code>. 这时候, 其中每个 <code>.cpp</code> 都是一个独立的编译单元, 在处理不同的单元的时候, 编译器可以并行编译, 这样在一个多核心的服务器上并行编译可以大大的减少编译的时间. 在多文件编译的时候, 往往编译器先会编译到 <code>.o</code> 文件, 然后把多个编译单元生成的多个 <code>.o</code> 文件链接为一个二进制可执行文件例如 <code>.exe</code>, <code>.out</code>. 在这个过程中, 每一个全局变量/函数都会生成一个符号, 其他的编译单元如果调用了一个声明的符号, 需要在链接期间找到符号对应的变量/函数的地址.</p><p>如果多个编译单元都看到了某个函数的声明和定义, 那么在编译到 <code>.o</code> 的过程中, 这些单元都会把这个函数的符号记下来, 读者可以认为是每个单元都维护了一个符号表 <code>map</code>, 而 <code>map</code> 里面 <code>key</code> 为这个函数名字的一项记录了这个函数的地址 (这是一个不严谨的说法, 请不要细究细节). 而在链接的阶段, 不同的编译单元的符号表需要合并, 但如果合并的时候发现某一个 <code>key</code> 有两个对应的记录, 那么就会报错. 事实上, C/C++ 要求最后所有编译单元的结果中, 每个符号 (包括全局变量/函数) 只有一处定义, 这也就是所谓的 <strong>One Definition Rule</strong> (ODR), 即一个函数只能有一个定义.</p><p>然而, 很多时候, 对于一些简单的函数, 比如 <code>int add_1(int x) &#123; return x + 1; &#125;</code>, 我们想把它放到头文件里面, 而不是某个 <code>.cpp</code> 里面. 一般情况下, 当多个编译单元包含了这个文件的时候, 这会违反 ODR. 这时候, 我们就需要用到 <code>inline</code> 关键词. <code>inline</code> 关键词的作用是, 在一个符号在多个编译单元里面出现时, 编译器随机保留其中的一份, 丢弃其他的. 因为多个编译单元中包括的是同一个头文件, 看到的也是同一个函数的实现 (比如上述例子中的 <code>add_1</code>), 因此保留哪一份不会影响正确性. 特别地, C++ 默认类内提供实现的成员函数都是 <code>inline</code> 的, <del>所以大家多用面向对象吧</del>.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MyStructTest</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">// default set as inline, safe to be included in a header.</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// if in .h/.hpp, need to manually add `inline` here, because definition is out of the class</span></span><br><span class="line"><span class="comment">// if in .cpp, we shouldn&#x27;t add inline here!</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">MyStructTest::func2</span><span class="params">()</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p><code>static</code> 修饰一个 <code>class</code> 成员函数/变量比较特殊, 这里讨论的是 <code>static</code> 修饰一个全局变量/函数. <code>static</code> 要求修饰的这个符号变成内部符号, 即最终这个符号不会对外暴露, 当前编译单元内所有用到这个符号的地方, 都会变成对内部符号的调用. 换句话说, 它不会在最终 <code>.o</code> 里面的符号表里面出现. 因此, 别的编译单元无论如何都无法直接调用这一个函数.</p><p>总结一下, <code>inline</code> 是允许多个定义, 编译器保留其中任意一份, 而 <code>static</code> 是让符号变成内部符号, 类似 private, 不再对外暴露. 对于在头文件中提供了定义的全局函数, 笔者建议使用 <code>inline</code>. 对于没有在 <code>.h</code> 中声明, 仅仅用于当前编译单元 (<code>.cpp</code>) 的一些内部辅助函数, 笔者建议使用 <code>static</code>. 当然, 同样的概念不仅仅适用于函数, 同样也适用于变量 (需要 C++17). 以下是一些样例代码.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> dark &#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">short_func</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// declare and define constexpr value in header</span></span><br><span class="line"><span class="comment">// highly recommended in C++, maybe best practice</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">constexpr</span> <span class="type">int</span> kZero = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="comment">// this static just means not a member variable,</span></span><br><span class="line">    <span class="comment">// but shared by the class `Test`</span></span><br><span class="line">    <span class="keyword">inline</span> <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> kon = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace dark</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;test.h&quot;</span></span></span><br><span class="line"><span class="keyword">namespace</span> dark &#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">internal_helper</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// do not add static or inline here</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">short_func</span>();</span><br><span class="line">    <span class="built_in">internal_helper</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace dark</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;test.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    dark::<span class="built_in">func</span>();</span><br><span class="line">    dark::<span class="built_in">short_func</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>感兴趣的读者可以再自行去了解一下匿名 <code>namespace</code> 的概念, 详情请参考 <a href="https://en.cppreference.com/w/cpp/language/namespace">cppreference</a>. 简单来说, 它让其中的所有符号都变成 <code>static</code> 的, 非常适合放在 <code>.cpp</code> 文件中.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">no_need_to_mark_static</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="using"><a href="#using" class="headerlink" title="using"></a>using</h3><p><a href="https://en.cppreference.com/w/cpp/keyword/using">using</a></p><p>一些笔者想到的常用功能:</p><ol><li><code>using enum</code>: C++20 引入的, 可以把 <code>enum</code> 的作用域引入当前作用域, 非常适用于 <code>switch</code> 内部.</li><li><code>using namespace xxx</code>: 不推荐, 除非是 <code>using std::literals::chrono_literals</code> 来引入 <code>s</code> 这类用户定义字面量.</li><li><code>using ns::xxx</code>: 引入 namespace <code>ns</code> 中的 <code>xxx</code>, 适用于一个封闭作用域内部 (比如函数).</li><li><code>using A = B</code>: 非常常见, 请全面禁用 <code>typedef</code>, 我们不应该兼容 <code>C++11</code> 之前的代码.</li></ol><h3 id="结构化绑定"><a href="#结构化绑定" class="headerlink" title="结构化绑定"></a>结构化绑定</h3><p><a href="https://en.cppreference.com/w/cpp/language/structured_binding">binding</a>, <a href="https://en.cppreference.com/w/cpp/language/adl">ADL</a></p><p>在 C++17 中, 引入了结构化绑定: 对于一个聚合类 (即没有基类, 没有用户声明的构造函数) 或者按照 <a href="https://en.cppreference.com/w/cpp/language/structured_binding">特殊规则</a> 重载了对应的函数的类, 我们可以类似 python 中 <code>tuple</code> 解包的形式写代码. 比如 <code>std::pair</code>, <code>std::tuple</code>, <code>std::array</code> 以及原生的数组都是支持的. 语法如下, 需要注意的是必须用 <code>auto</code>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">std::tuple&lt;<span class="type">int</span>, <span class="type">float</span>, std::string&gt; t;</span><br><span class="line"><span class="keyword">auto</span> &amp;[x, y, z] = t;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyStruct</span> &#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">&#125; tmp;</span><br><span class="line"><span class="keyword">auto</span> [a, b] = tmp; <span class="comment">// must use auto</span></span><br></pre></td></tr></table></figure><p>如果你对于自定义的非聚合类也想使用结构化绑定, 那么你需要提供一个 <code>get</code> 函数, 并且特化 <code>std::tuple_size</code> 和 <code>std::tuple_element</code> 两个模板. 例如:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">double</span> y;</span><br><span class="line">    <span class="type">int</span> other;</span><br><span class="line">    <span class="comment">// this violate the definition of aggregate class</span></span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> x, <span class="type">double</span> y) : <span class="built_in">x</span>(x), <span class="built_in">y</span>(y), <span class="built_in">other</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">std</span>::tuple_size&lt;A&gt; : std::integral_constant&lt;std::<span class="type">size_t</span>, <span class="number">2</span>&gt; &#123;</span><br><span class="line">    <span class="comment">// now, std::tuple_size&lt;A&gt;::value is 2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;std::<span class="type">size_t</span> I&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">get</span><span class="params">(A &amp;a)</span> -&gt; <span class="keyword">decltype</span>(<span class="keyword">auto</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(I == <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.x;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">constexpr</span> (I == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> a.y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;std::<span class="type">size_t</span> I&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">get</span><span class="params">(<span class="type">const</span> A &amp;a)</span> -&gt; <span class="keyword">decltype</span>(<span class="keyword">auto</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(I == <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.x;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">constexpr</span> (I == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> a.y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;std::<span class="type">size_t</span> I&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">std</span>::tuple_element&lt;I, A&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> type = <span class="keyword">decltype</span>(<span class="built_in">get</span>&lt;I&gt;(std::<span class="built_in">declval</span>&lt;A&gt;()));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">main</span><span class="params">()</span> -&gt; <span class="type">int</span> </span>&#123;</span><br><span class="line">    A a&#123;<span class="number">1</span>, <span class="number">1.0</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> &amp;[x, y] = a;</span><br><span class="line">    std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; y &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里你可能会好奇了: 编译器为什么知道调用的是哪个 <code>get</code> 函数? 为什么不是 <code>std::get</code>? 这里就涉及 C++ 中 Argument Dependent Lookup (ADL) 的知识了. 考虑到 ADL 对于一般读者还是过于抽象和晦涩, 这里笔者只给出一个 <a href="https://en.cppreference.com/w/cpp/language/adl">cppref 链接</a>, 笔者也是在 23 年暑假花了整整一个暑假才嚼明白, 并且在漫长的实践中才真正理解.</p><h3 id="if-switch"><a href="#if-switch" class="headerlink" title="if/switch"></a>if/switch</h3><p><a href="https://en.cppreference.com/w/cpp/language/if">if</a>, <a href="https://en.cppreference.com/w/cpp/language/switch">switch</a></p><p>在 C++17 中, 引入了 <code>if</code> 初始化语句. 简单来说, 你可以在判断一个条件的同时把结果放在 <code>if</code> 内部 (注意, 条件判断不一定返回的是 <code>bool</code>, 只要可以 <code>static_cast&lt;bool&gt;</code> 即可), 或者为 <code>if</code> 额外的添加初始化语句, 从而避免变量名泄露, 把变量的生命周期限制在 <code>if</code> 语句内部. 这对 <code>switch</code> 也是类似的.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">foo</span><span class="params">()</span> -&gt; std::shared_ptr&lt;<span class="type">int</span>&gt;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// before</span></span><br><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; ptr = <span class="built_in">foo</span>();</span><br><span class="line"><span class="keyword">if</span> (ptr) &#123;</span><br><span class="line">    <span class="comment">// do something A</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// do something B</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ptr != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="comment">// yet another way</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// after</span></span><br><span class="line"><span class="keyword">if</span> (std::shared_ptr&lt;<span class="type">int</span>&gt; ptr = <span class="built_in">foo</span>()) &#123;</span><br><span class="line">    <span class="comment">// do something A</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// do something B</span></span><br><span class="line">    <span class="comment">// note that ptr is still reachable in this branch.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ptr dies here.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="type">int</span> x = <span class="number">0</span>, y = <span class="number">2</span>; std::shared_ptr&lt;<span class="type">int</span>&gt; ptr = <span class="built_in">foo</span>()) &#123;</span><br><span class="line">    <span class="comment">// yet another way</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (std::shared_ptr&lt;<span class="type">int</span>&gt; x = <span class="built_in">foo</span>(); x &amp;&amp; *x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// this is also ok</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (std::shared_ptr&lt;<span class="type">int</span>&gt; y = <span class="built_in">foo</span>(); x &amp;&amp; y &amp;&amp; *x == *y) &#123;</span><br><span class="line">    <span class="comment">// also works for else if</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个设计最大的好处是, 可以干净的, 只为 <code>if</code> 所在的作用域声明变量, 避免变量名泄露, 严格控制变量的生命周期. 笔者认为这是现代语言必须的一个特点, 即闭包化, 每个模块尽量解耦, 严格限制模块之间潜在的耦合, 进而写出更高质量的代码.</p><h3 id="constexpr-consteval-constinit"><a href="#constexpr-consteval-constinit" class="headerlink" title="constexpr/consteval/constinit"></a>constexpr/consteval/constinit</h3><p>在 C++20 中, 推出了两个有趣的关键词: <code>consteval</code>和 <code>constinit</code>. 前者要求函数必须在编译期求值, 后者要求变量必须在编译期初始化.</p><h3 id="constexpr"><a href="#constexpr" class="headerlink" title="constexpr"></a>constexpr</h3><p><a href="https://en.cppreference.com/w/cpp/keyword/constexpr">constexpr</a></p><p><code>constexpr</code> 是 C++11 引入的, 当修饰变量的时候, 要求变量在编译期初始化, 当修饰函数的时候, 表示函数允许在编译期求值. 这些你应该都在课上已经了解了. 在逐渐发展的过程中, <code>constexpr</code> 也在变得更强. 在 C++20 中, <code>constexpr</code> 修饰的函数甚至允许动态分配内存, 仅仅要求在编译期确定大小以及释放 (虽然这是编译器对 <code>std::allocator</code> 开洞…).</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">find_the_kth_prime</span><span class="params">(<span class="type">int</span> k)</span> -&gt; <span class="type">int</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> vec      = std::vector&lt;<span class="type">int</span>&gt;&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> is_prime = [&amp;vec](<span class="type">int</span> x) -&gt; <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;p : vec)</span><br><span class="line">            <span class="keyword">if</span> (x % p == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">int</span> num = vec.<span class="built_in">back</span>() + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (vec.<span class="built_in">size</span>() &lt; <span class="built_in">static_cast</span>&lt;std::<span class="type">size_t</span>&gt;(k)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">is_prime</span>(num))</span><br><span class="line">            vec.<span class="built_in">push_back</span>(num);</span><br><span class="line">        num += <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// vec is dynamically allocated and freed in compile time</span></span><br><span class="line">    <span class="comment">// so it&#x27;s ok to use as a temporary variable</span></span><br><span class="line">    <span class="keyword">return</span> vec[k - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ok</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> val = <span class="built_in">find_the_kth_prime</span>(<span class="number">100</span>);</span><br></pre></td></tr></table></figure><p>事实上, 传统很多使用模板元编程的奇技淫巧基本都可以用 <code>constexpr</code> 来替换了, 这种写法可读性更高, 也更加直观.</p><h3 id="consteval"><a href="#consteval" class="headerlink" title="consteval"></a>consteval</h3><p><a href="https://en.cppreference.com/w/cpp/keyword/consteval">consteval</a></p><p><code>consteval</code> 的核心在于: 函数必须在编译期求值. 例如:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">consteval</span> <span class="keyword">auto</span> <span class="title">must_be_0</span><span class="params">(<span class="type">int</span> x)</span> -&gt; <span class="type">int</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述函数中, 如果你的入参不是 <code>0</code>, 那么编译器会报错 (因为 throw 无法在编译期执行), 代码无法通过编译. 这有两点:</p><ol><li>强制某些函数的计算在编译期完成. 虽然 C++ 编译器有着非常强大的优化能力, 但是对于极其复杂的函数, 并不保证能够优化出来, 即使被标上了 <code>constexpr</code>, 只要不是赋值给 <code>constexpr</code> 的变量, 编译器也不会强制在编译期求值 (虽然大多数情况下会). 这时候, <code>consteval</code> 就派上用场了.</li><li>给编译期间的错误提供了更多的可能. 例如上述代码, 如果你传入了一个非 0 的值, 编译器会报错. 我们因此可以实现类似功能: 只要当函数的输入类型/参数满足特定条件的时候, 才能通过编译 (参考 <code>std::format</code>).</li></ol><p>需要注意的是, <code>consteval</code> 和重载决议无关. 编译器在选择了正确的函数之后, 如果该函数不满足 <code>consteval</code> 的要求, 编译器会报错. 你可能会联想到 SFINAE, 但是遗憾的是, SFINAE 只会影响重载的选择, 而 <code>consteval</code> 是在重载选择之后才会起作用的, 因此两者并无关系.</p><h3 id="constinit"><a href="#constinit" class="headerlink" title="constinit"></a>constinit</h3><p><a href="https://en.cppreference.com/w/cpp/keyword/constinit">constinit</a></p><p>有的人可能认为 <code>constinit</code> 就是 <code>constexpr</code>, 但是这是错误的. <code>constinit</code> 是要求变量在编译期初始化, 变量本身可以是非 <code>const</code> 的, 而 <code>constexpr</code> 则暗含了 1. 变量是 <code>const</code> 的, 2. 变量在编译期初始化. 例如:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constinit</span> <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    x = <span class="number">1</span>; <span class="comment">// ok</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码是合法的, 因为 <code>x</code> 是 <code>constinit</code>, 而不是 <code>const</code>. 但是如果你把 <code>constinit</code> 换成 <code>constexpr</code>, 那么编译器会报错. 好奇的你可能想问: 那这个关键词有什么用呢? 事实上, 它是为了解决一个问题而生的: 静态变量的初始化顺序问题.</p><p>在 C++ 中, 静态变量(你可以理解为全局变量)的初始化顺序是不确定的, 如果你有两个静态变量, 他们之间有依赖关系, 那么你可能会遇到问题. 例如:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">f</span><span class="params">()</span> -&gt; <span class="type">int</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line"><span class="type">int</span> y = <span class="built_in">f</span>();</span><br><span class="line"><span class="type">int</span> x = y;</span><br></pre></td></tr></table></figure><p>这个初始化顺序是可能不确定的 (虽然实测几乎没出过错, 可能主要还是在跨编译单元的时候, 容易出问题), 有可能 <code>x</code> 先初始化, 也有可能 <code>y</code> 先初始化. 这时候, 你可以使用 <code>constinit</code> 来解决这个问题:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">consteval</span> <span class="keyword">auto</span> <span class="title">f</span><span class="params">()</span> -&gt; <span class="type">int</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line"><span class="keyword">constinit</span> <span class="type">int</span> y = <span class="built_in">f</span>();</span><br><span class="line"><span class="type">int</span> x = y;</span><br></pre></td></tr></table></figure><p>同时, <code>constinit</code> 也可以支持 <code>extern</code> 的变量, 这是 <code>constexpr</code> 做不到的.</p><h2 id="memory-safe"><a href="#memory-safe" class="headerlink" title="memory-safe"></a>memory-safe</h2><p>Modern C++ 一个突出的特点是, 内存安全. 其中, RAII 给我们的实现提供了巨大的便利. 而 <code>memory safe</code> 的实现, 其靠的就是 smart pointer. 在大多数的情况下, 我们都应该用智能指针替代裸指针.</p><ul><li><code>unique_ptr</code> 只能有一个拥有者的指针.</li><li><code>shared_ptr</code> 可以被多处拥有的指针, 需要注意防止循环引用.</li></ul><p>说实话, 这些智能指针其实最大的便利不是访问的安全性, 用户依然可以随便就写出访问空指针的代码, 它们最大的好处还是, 实现了内存资源的自动回收. 这其实本质就是 RAII 思想的运用, 构造处获取资源, 析构处回收资源, 而移动语义则一般表示资源的转交 (比如 <code>unique_ptr</code>, 在移动构造/赋值之后, 被移动的对象会被重置为空指针). 这些先进的理念也被后来很多更加先进的编程语言所采纳, 比如 <code>rust</code>.</p><h3 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h3><p><a href="https://cntransgroup.github.io/EffectiveModernCppChinese/4.SmartPointers/item18.html">Item 18</a>, <a href="https://en.cppreference.com/w/cpp/memory/unique_ptr">unique_ptr</a>, <a href="https://en.cppreference.com/w/cpp/memory/unique_ptr/make_unique">make_unique, make_unique_for_overwrite</a></p><p>主要截取自 item 18. 对于独占 (尤其是不可复制) 的资源, 我们会用 <code>unique_ptr</code> 来管理内存.</p><p>一般来说, 如果使用 <code>unique_ptr</code> 我们会更加倾向于用一个工厂函数来构建这个 <code>unique_ptr</code> 对象, 例如标准库提供的 <code>std::make_unique</code>. 当然, 如果你想支持一些更加复杂的功能, 特别是自定义删除器的时候, 很多时候需要自己手写, 可以用到 C++14 的 auto 返回类型 + lambda 函数来实现一些优雅的功能. 下面例子节选自 item 18.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Ts&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">makeInvestment</span><span class="params">(Ts &amp;&amp;...params)</span> </span>&#123; <span class="comment">// need C++14 </span></span><br><span class="line">    <span class="keyword">auto</span> delInvmt = [](Investment *pInvestment) &#123;</span><br><span class="line">        <span class="comment">// pInvestment pointer will not be nullptr.</span></span><br><span class="line">        <span class="built_in">makeLogEntry</span>(pInvestment);</span><br><span class="line">        <span class="keyword">delete</span> pInvestment;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;Investment, <span class="title">decltype</span><span class="params">(delInvmt)</span>&gt; <span class="title">pInv</span><span class="params">(<span class="literal">nullptr</span>, delInvmt)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (...) &#123;</span><br><span class="line">        pInv.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">Stock</span>(std::forward&lt;Ts&gt;(params)...));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (...) &#123;</span><br><span class="line">        pInv.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">Bond</span>(std::forward&lt;Ts&gt;(params)...));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (...) &#123;</span><br><span class="line">        pInv.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">RealEstate</span>(std::forward&lt;Ts&gt;(params)...));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pInv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然, 如果你不是特别关心效率, 但是非常关心泛化性, 你也可以用 <code>std::function&lt;void(T *)&gt;</code> 来作为删除器, 支持任意的仿函数作为删除器, 缺点是会增加存储的空间. 同时, <code>unique_ptr</code> 也可以很方便的转化为 <code>shared_ptr</code>, 提供了不少的便利性.</p><p>特别地, <code>unique_ptr</code> 允许指针转化为派生类或者基类的 <code>unique_ptr</code>, 不过这很容易带来内存泄露的问题, 析构的时候可能会找到错误的析构函数. 在笔者的日常使用中, <code>unique_ptr</code> 经常会搭配抽象基类 (<code>virtual class</code>), 虚类的 <code>virtual</code> 析构函数可以让 <code>unique_ptr</code> 在 destroy 指针指向的对象的时候找到正确析构, 避免资源泄露.</p><p>最后, 以 item 18 的 notes 总结一下:</p><ol><li><code>std::unique_ptr</code> 是轻量级、快速的、只可移动 <code>(move-only)</code> 的管理专有所有权语义资源的智能指针</li><li>默认情况，资源销毁通过 <code>delete</code> 实现, 但是支持自定义删除器. 有状态的删除器和函数指针会增加 <code>std::unique_ptr</code> 对象的大小</li><li>将 <code>std::unique_ptr</code> 转化为 <code>std::shared_ptr</code> 非常简单</li><li><code>std::unique_ptr</code> 在大部分的使用情况, 性能和裸指针无异 (一句话, 我相信编译器优化).</li></ol><blockquote><p>Remark: 一般来说, 笔者不鼓励使用传入一个 <code>new</code> 出来的指针构造 <code>unique_ptr</code>, 除非有特殊的删除器, 否则笔者推荐全部用 <code>std::make_unique</code> 来构造.</p></blockquote><h3 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h3><p><a href="https://cntransgroup.github.io/EffectiveModernCppChinese/4.SmartPointers/item19.html">Item 19</a>, <a href="https://en.cppreference.com/w/cpp/memory/shared_ptr">shared_ptr</a>, <a href="https://en.cppreference.com/w/cpp/memory/enable_shared_from_this">enable_shared_from_this</a>, <a href="https://en.cppreference.com/w/cpp/memory/shared_ptr/make_shared">make_shared, make_shared_for_overwrite</a></p><p>比起 <code>unique_ptr</code>, <code>shared_ptr</code> 会更加灵活, 其通过了引用计数来控制了对象的生命周期, 允许高效的拷贝, 当然缺点就是可能成环导致资源泄露. 笔者并不经常使用 <code>shared_ptr</code>, 这里就不过多介绍了. 为了避免循环引用, 需要把可能的循环中的一部分设置为 <code>weak_ptr</code>, 具体用法请参考 cppreference.</p><p><code>shared_ptr</code> 更加灵活的一点是, 它支持传入一个自定义的删除器作为构造参数的一部分, 而不需要像 <code>unique_ptr</code> 那样在模板里面显式指出来. 正因如此, 你可以放心的把派生类的 <code>shared_ptr</code> 转化为基类的 <code>shared_ptr</code>, 不用担心基类不是 <code>virtual</code> 可能会带来资源泄露, 这是因为 <code>shared_ptr</code> 在一开始已经把对应指针类型的删除函数给 “记下来了”. 这自然是有开销的, 但是也能带来不小的便利.</p><p>特别地, 使用 <code>shared_ptr</code> 的时候, 一个常见的问题是把一个指针, 由两个 <code>shared_ptr</code> 来接管 (包括 <code>unique_ptr</code> 也会有这种问题), 或者错误的由 <code>this</code> 指针来构造一个 <code>shared_ptr</code> (这并不会正确的构造一个指向同一个引用计数块的 <code>shared_ptr</code>). 因此, 笔者认为无论如何, 在没有自定义删除器的情况下, 请尽一切可能使用 <code>std::make_shared</code> 来构造一个 <code>shared_ptr</code>. 同时, 对于前面提到的从 <code>this</code> 构造 <code>shared_ptr</code> 的例子, 正确的做法是继承一个 <code>std::enable_shared_from_this&lt;T&gt;</code>, 然后调用基类的 <code>shared_from_this</code> 函数. 下面的例子改变自 <a href="https://en.cppreference.com/w/cpp/memory/enable_shared_from_this">cppreference</a>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Good</span> : <span class="keyword">public</span> std::enable_shared_from_this&lt;Good&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::shared_ptr&lt;Good&gt; <span class="title">getptr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">shared_from_this</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Best</span> : <span class="keyword">public</span> std::enable_shared_from_this&lt;Best&gt; &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Private</span> &#123;&#125;;</span><br><span class="line">    <span class="built_in">Best</span>(Private) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Everyone else has to use this factory function</span></span><br><span class="line">    <span class="comment">// Hence all Best objects will be contained in shared_ptr</span></span><br><span class="line">    <span class="function"><span class="type">static</span> std::shared_ptr&lt;Best&gt; <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">make_shared</span>&lt;Best&gt;(<span class="built_in">Private</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::shared_ptr&lt;Best&gt; <span class="title">getptr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">shared_from_this</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Bad</span> &#123;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;Bad&gt; <span class="title">getptr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">shared_ptr</span>&lt;Bad&gt;(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Bad</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Bad::~Bad() called\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果以上这些说法都没法说服你用 <code>std::make_shared</code>, 那么笔者可以再告诉你一个有趣的小细节. <code>shared_ptr</code> 由两部分组成: 对象指针和控制块指针 (常见 <code>gcc</code> 和 <code>clang</code> 的实现, <code>sizeof(shared_ptr&lt;T&gt;)</code> 都是 <code>16</code> 即两个指针). 控制块比较特殊, 管理了对象的析构函数, 引用计数等一系列东西. 而如果你用 <code>std::make_shared</code>, 那么在一般的实现中 (比如 <code>gcc</code>), 它的控制块和对象会共用一大块存储, 而不需要申请两次空间. 试着运行一下以下的代码吧.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// no inline, required by [replacement.functions]/3</span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> sz)</span> </span>&#123;</span><br><span class="line">    std::<span class="built_in">printf</span>(<span class="string">&quot;1) new(size_t), size = %zu\n&quot;</span>, sz);</span><br><span class="line">    <span class="keyword">if</span> (sz == <span class="number">0</span>)</span><br><span class="line">        ++sz; <span class="comment">// avoid std::malloc(0) which may return nullptr on success</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="type">void</span> *ptr = std::<span class="built_in">malloc</span>(sz))</span><br><span class="line">        <span class="keyword">return</span> ptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> std::bad_alloc&#123;&#125;; <span class="comment">// required by [new.delete.single]/3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// no inline, required by [replacement.functions]/3</span></span><br><span class="line"><span class="type">void</span> *<span class="keyword">operator</span> <span class="keyword">new</span>[](std::<span class="type">size_t</span> sz) &#123;</span><br><span class="line">    std::<span class="built_in">printf</span>(<span class="string">&quot;2) new[](size_t), size = %zu\n&quot;</span>, sz);</span><br><span class="line">    <span class="keyword">if</span> (sz == <span class="number">0</span>)</span><br><span class="line">        ++sz; <span class="comment">// avoid std::malloc(0) which may return nullptr on success</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="type">void</span> *ptr = std::<span class="built_in">malloc</span>(sz))</span><br><span class="line">        <span class="keyword">return</span> ptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> std::bad_alloc&#123;&#125;; <span class="comment">// required by [new.delete.single]/3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span> *ptr)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    std::<span class="built_in">puts</span>(<span class="string">&quot;3) delete(void*)&quot;</span>);</span><br><span class="line">    std::<span class="built_in">free</span>(ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span> *ptr, std::<span class="type">size_t</span> size)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    std::<span class="built_in">printf</span>(<span class="string">&quot;4) delete(void*, size_t), size = %zu\n&quot;</span>, size);</span><br><span class="line">    std::<span class="built_in">free</span>(ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="type">void</span> *ptr) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">    std::<span class="built_in">puts</span>(<span class="string">&quot;5) delete[](void* ptr)&quot;</span>);</span><br><span class="line">    std::<span class="built_in">free</span>(ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="type">void</span> *ptr, std::<span class="type">size_t</span> size) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">    std::<span class="built_in">printf</span>(<span class="string">&quot;6) delete[](void*, size_t), size = %zu\n&quot;</span>, size);</span><br><span class="line">    std::<span class="built_in">free</span>(ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">object</span> &#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">10</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">main</span><span class="params">()</span> -&gt; <span class="type">int</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> tmp = std::<span class="built_in">make_shared</span>&lt;object&gt;();</span><br><span class="line">    std::<span class="built_in">puts</span>(<span class="string">&quot;7) make_shared&quot;</span>);</span><br><span class="line">    <span class="keyword">auto</span> tmp2 = std::<span class="built_in">shared_ptr</span>&lt;object&gt;(<span class="keyword">new</span> object&#123;&#125;);</span><br><span class="line">    std::<span class="built_in">puts</span>(<span class="string">&quot;8) shared_ptr&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结一下, <code>shared_ptr</code> 是一个非常强大而方便的管理指针数据的工具, 它维护了指针的析构器和引用计数, 它的引用计数甚至是线程安全的. 自然, 这会带来一些不必要的开销, 但是在很多时候, 灵活性带来的好处远胜于一些微不足道的开销带来的弊端.</p><p>一个非常非常非常常见的 use case 是 <code>pimpl</code>. 具体来说, 我们在对象中维护了一个 <code>std::shared_ptr&lt;Impl&gt;</code>, 但是 <code>Impl</code> 只有声明 (即 <code>struct Impl</code>), 而实现处放在了 <code>.cpp</code> 文件中而不是在 <code>.h</code>. 这是因为头文件在编译的时候, <code>#include</code> 的内容会被替换到文件里面, 而一个类的实现可能会包含很多其他的依赖 (比如标准库里面的 <code>vector, unordered_set</code>, 或者是第三方库的一些代码). 如果我们把类的实现 (注意, 是类的实现, 而不仅仅是类的成员的实现) 放在了 <code>.h</code> 里面, 那么一旦你的类的结构发生了任何改变 (比如添加了一个函数, 或者删除了一个成员), 编译的时候, 所有依赖这个 <code>.h</code> 的 <code>.cpp</code> 文件都需要重新编译. 在一个庞大的项目里面, 这会极大地拖垮编译速度, 可能会慢到无法接受, 1 ~ 2 个小时都是有可能的. 这时候, 把类的结构完全分离到 <code>.cpp</code> 中 (包括内部成员和所有成员函数), 只对外暴露一些必要的接口或者说 API, 不仅可以极大地提升编译速度, 还能强制把接口和实现分离, 提高了代码的可读性.</p><p>这个问题的解决方案有一个是前向声明一个不完整类型 <code>struct Impl;</code>, 而在传参的时候尽量用引用类型比如 <code>const &amp;</code> (虽然指针也行, 但是 Modern C++ 不提倡指针) (这里传值需要看到类型的完整定义). 同时, 对于一个类型的对象, 总需要有一个持有者吧. 这时候 <code>shared_ptr</code> 就可以作为这个持有者. 下面是著名开源项目 <a href="https://github.com/mlc-ai/xgrammar">xgrammar</a> 里面的一些代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment"> *  Copyright (c) 2024 by Contributors</span></span><br><span class="line"><span class="comment"> * \file xgrammar/object.h</span></span><br><span class="line"><span class="comment"> * \brief Utilities for creating objects.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> XGRAMMAR_OBJECT_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XGRAMMAR_OBJECT_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span>   <span class="comment">// IWYU pragma: keep</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span>  <span class="comment">// IWYU pragma: keep</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> xgrammar &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment"> * \brief A tag type for empty constructor.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Since XGRAMMAR_DEFINE_PIMPL_METHODS already occupies the default constructor to</span></span><br><span class="line"><span class="comment"> * construct a null object, this tag is used to define an empty constructor for</span></span><br><span class="line"><span class="comment"> * the object.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">EmptyConstructorTag</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XGRAMMAR_DEFINE_PIMPL_METHODS(TypeName)                                \</span></span><br><span class="line"><span class="meta"> public:                                                                       \</span></span><br><span class="line"><span class="meta">  class Impl;                                                                  \</span></span><br><span class="line"><span class="meta">  <span class="comment">/* The default constructor constructs a null object. Note operating on a */</span>  \</span></span><br><span class="line"><span class="meta">  <span class="comment">/* null object will fail. */</span>                                                 \</span></span><br><span class="line"><span class="meta">  explicit TypeName() : pimpl_(nullptr) &#123;&#125;                                     \</span></span><br><span class="line"><span class="meta">  <span class="comment">/* Construct object with a shared pointer to impl. The object just stores */</span> \</span></span><br><span class="line"><span class="meta">  <span class="comment">/* a pointer. */</span>                                                             \</span></span><br><span class="line"><span class="meta">  explicit TypeName(std::shared_ptr<span class="string">&lt;Impl&gt;</span> pimpl) : pimpl_(std::move(pimpl)) &#123;&#125; \</span></span><br><span class="line"><span class="meta">  TypeName(const TypeName&amp; other) = default;                                   \</span></span><br><span class="line"><span class="meta">  TypeName(TypeName&amp;&amp; other) noexcept = default;                               \</span></span><br><span class="line"><span class="meta">  TypeName&amp; operator=(const TypeName&amp; other) = default;                        \</span></span><br><span class="line"><span class="meta">  TypeName&amp; operator=(TypeName&amp;&amp; other) noexcept = default;                    \</span></span><br><span class="line"><span class="meta">  <span class="comment">/* Access the impl pointer. Useful in implementation. */</span>                     \</span></span><br><span class="line"><span class="meta">  Impl* operator-&gt;() &#123; return pimpl_.get(); &#125;                                  \</span></span><br><span class="line"><span class="meta">  const Impl* operator-&gt;() const &#123; return pimpl_.get(); &#125;                      \</span></span><br><span class="line"><span class="meta">                                                                               \</span></span><br><span class="line"><span class="meta"> private:                                                                      \</span></span><br><span class="line"><span class="meta">  std::shared_ptr<span class="string">&lt;Impl&gt;</span> pimpl_</span></span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace xgrammar</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">// XGRAMMAR_OBJECT_H_</span></span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment"> *  Copyright (c) 2024 by Contributors</span></span><br><span class="line"><span class="comment"> * \file xgrammar/grammar.h</span></span><br><span class="line"><span class="comment"> * \brief The header for the definition and construction of BNF grammar.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> XGRAMMAR_GRAMMAR_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XGRAMMAR_GRAMMAR_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xgrammar/object.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;optional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> xgrammar &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">StructuralTagItem</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Grammar</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function">std::string <span class="title">ToString</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="function"><span class="type">static</span> Grammar <span class="title">FromEBNF</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="type">const</span> std::string&amp; ebnf_string, <span class="type">const</span> std::string&amp; root_rule_name = <span class="string">&quot;root&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">  )</span></span>;</span><br><span class="line">  <span class="function"><span class="type">static</span> Grammar <span class="title">FromJSONSchema</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="type">const</span> std::string&amp; schema,</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="type">bool</span> any_whitespace = <span class="literal">true</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">      std::optional&lt;<span class="type">int</span>&gt; indent = std::<span class="literal">nullopt</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">      std::optional&lt;std::pair&lt;std::string, std::string&gt;&gt; separators = std::<span class="literal">nullopt</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="type">bool</span> strict_mode = <span class="literal">true</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="type">bool</span> print_converted_ebnf = <span class="literal">false</span></span></span></span><br><span class="line"><span class="params"><span class="function">  )</span></span>;</span><br><span class="line">  <span class="function"><span class="type">static</span> Grammar <span class="title">FromRegex</span><span class="params">(<span class="type">const</span> std::string&amp; regex, <span class="type">bool</span> print_converted_ebnf = <span class="literal">false</span>)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">static</span> Grammar <span class="title">FromStructuralTag</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="type">const</span> std::vector&lt;StructuralTagItem&gt;&amp; tags, <span class="type">const</span> std::vector&lt;std::string&gt;&amp; triggers</span></span></span><br><span class="line"><span class="params"><span class="function">  )</span></span>;</span><br><span class="line">  <span class="function"><span class="type">static</span> Grammar <span class="title">BuiltinJSONGrammar</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">static</span> Grammar <span class="title">Union</span><span class="params">(<span class="type">const</span> std::vector&lt;Grammar&gt;&amp; grammars)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">static</span> Grammar <span class="title">Concat</span><span class="params">(<span class="type">const</span> std::vector&lt;Grammar&gt;&amp; grammars)</span></span>;</span><br><span class="line">  <span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="type">const</span> Grammar&amp; grammar);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">XGRAMMAR_DEFINE_PIMPL_METHODS</span>(Grammar);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace xgrammar</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">// XGRAMMAR_GRAMMAR_H_</span></span></span><br></pre></td></tr></table></figure><h3 id="smart-pointer-的遗憾"><a href="#smart-pointer-的遗憾" class="headerlink" title="smart pointer 的遗憾"></a>smart pointer 的遗憾</h3><p>smart pointer 在笔者看来, 已经极大地解决了 <code>memory safe</code> 的问题. 但它并没有解决一个信任链的问题. 那就是, 这个指针到底会不会是一个空指针. 无论是 <code>shared_ptr</code> 还是 <code>unique_ptr</code>, 都有一个 “指向空” 的默认状态, 这就导致用户永远可能担心: 这个指针是不是空啊?</p><p>诚然, 这样似乎显得有些做作, 但这在一个超级大的多人协作的项目中, 是非常重要的. 你需要知道一个返回值的精确语义. 在大部分情况下, 多加一个 <code>if (ptr != nullptr)</code> 这样的判断并不会有太大的开销, 但是还是有很多性能非常重要的场景, 我们想要保证一个对象, 它维护了一个指向非空的指针, 同时维护了对象的所有权. 前者我们一般会用引用来直接代替 (引用的语义基本就是, 一个指向对象而非空的指针), 后者我们会用智能指针来管理. 那么两者兼顾呢? 似乎并没有一个工具能实现这一点. 事实上, C++ 中完成这个几乎注定是不可能的: 考虑一个这样的智能非空指针被移动之后的状态, 它不再持有所有权, 那么它的指针指向什么呢? 指向原来的对象将会带来垂悬引用, 这是极其危险的. 事实上, 除非编译器提供支持, 在编译期间做出静态检查, 否则我们永远无法跳出 “这个智能指针可能是空” 的难题, 要么通过高质量的代码和注释来清楚的告诉开发者 “这里一定不是空”, 要么就是强迫开发者使用前判断这个指针是否为空 (当然, 你也可以自己包一层智能指针, 所有涉及解引用的操作前插入检查, 如果为空则抛出异常, 相当于防御式编程). 这时候, rust 生命周期那套相关的东西, 以及强制的边界检查, 或许可能可以帮你避免 C++ 这边 “指针是不是空” 的心智负担, 而那些现代语言提供的语法糖 (比如结构化匹配 <code>match</code>), 也能有助于读者写出更有可读性、更易于维护的代码.</p><p>总之, 笔者强烈建议所有写 Modern C++ 的读者认真的去了解、体验一下 rust, 这一定会在你的编程生涯留下浓墨重彩的一笔.</p><h3 id="non-owning-views"><a href="#non-owning-views" class="headerlink" title="non-owning views"></a>non-owning views</h3><p><a href="https://en.cppreference.com/w/cpp/container/span">span</a>, <a href="https://en.cppreference.com/w/cpp/string/basic_string_view">string_view</a>, <a href="https://www.rust-lang.org/">rust</a></p><p>其实就是 <code>std::span</code> 和 <code>std::string_view</code>. <code>std::span</code> 表示对于一个内存上连续区域的视图, 类似一个裸指针 + 区间长度, 而 <code>std::string_view</code> 则几乎就是 <code>std::span&lt;const char&gt;</code>. 需要注意 non-owning 不代表元素不能修改, 只是表明这个区间的元素不是由持有 <code>span</code> 或者 <code>string_view</code> 的人来析构, 保证在持有 <code>span</code> 和 <code>string_view</code> 时区间尚未被析构而已. 要彻底搞明白生命周期, 笔者还是建议读者亲自实践一下 <code>rust</code>.</p><p>笔者强烈建议尽可能用 <code>std::span</code> 替换所有的 <code>const std::vector&lt;T&gt; &amp;</code>, 用 <code>std::string_view</code> 替换一切的 <code>const std::string &amp;</code> (除非要求 null-terminated string). 这不仅是写法更加 modern 代码语义更精确, 它有时还能稍微提升一点代码性能, 并且比起裸指针, 提供了更好的封装.</p><blockquote><p>Remark: 我想要 <code>std::optional &lt;T&amp;&gt;</code>, 请参考后文 <a href="#optional--variant">optional 一章</a></p></blockquote><h2 id="type-safe"><a href="#type-safe" class="headerlink" title="type-safe"></a>type-safe</h2><p>Modern C++ 一个突出的特点是, 我们要保证类型安全, 避免危险的 <code>reinterpret_cast</code> 防止错误的内存访问. 而标准库也提供了不少容器来帮助我们实现这一点.</p><p>需要注意的是, 这些实现并不一定是最高效的, 相信读者自然能想出更加 memory efficient 的实现, 但是在大部分不是那么关心性能/memory 的场景, 尤其是短小的、几乎一定会被 “内联优化” 的函数里面, 以下这些标准库组件能给用户带来极大的便利.</p><h3 id="function"><a href="#function" class="headerlink" title="function"></a>function</h3><p><a href="https://en.cppreference.com/w/cpp/utility/functional/function">function</a>, <a href="https://en.cppreference.com/w/cpp/utility/functional/move_only_function/move_only_function">move_only_function</a></p><p><code>std::function</code> 传入一个函数签名作为模板参数, 其是裸函数指针的一个替代品, 但是更加灵活. 对于任何一个实现了 <code>operator()</code> 并且参数满足函数签名的一个对象, 我们称之为仿函数 (functor), 这是重载运算符给我们带来的便利. 如果这个对象满足可以被复制 (e.g. 函数指针, 常见的 lambda 函数等等), 那么 <code>std::function</code> 就可以对应的构造.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">std::function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; f; <span class="comment">// a function that takes in as an int as argument, return void</span></span><br><span class="line">f = [](<span class="type">int</span> x) &#123; <span class="keyword">return</span> x; &#125;; <span class="comment">// ok, discard return value</span></span><br><span class="line">f = [](<span class="type">float</span>) &#123;&#125;; <span class="comment">// ok, cast int to float when f is called</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">my_functor</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span>)</span> -&gt; <span class="type">void</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">f = my_functor&#123;&#125;; <span class="comment">// ok, functor can be invoked with an integer</span></span><br></pre></td></tr></table></figure><p>这自然不是免费的午餐, 代价是它类似函数指针, 会引入间接跳转的开销, 而且会拷贝/移动一份对象, 这中间可能涉及堆上内存的分配 (虽然 <code>gcc</code> 和 <code>clang</code> 都有做 small object optimization). 同时, 经典的 <code>std::function</code> 要求对象满足可以复制的条件, 这也并不是适用于所有对象 (比如持有类似 <code>std::unique_ptr</code> 类似的唯一资源的对象), 这是因为 <code>std::function</code> 为了保证本身可以复制所做出的牺牲.</p><p>幸运的是, 如果我们希望得到一个内部对象只可移动 (即转交所有权) 而不需要可复制的 <code>std::function</code>, 在 C++23 中有 <code>move_only_function</code> 可供选择.</p><p>事实上, <code>std::function</code> 内部需要持有一份对象, 这本身其实暗含了一种所有权, 也因此不可避免地需要构造/拷贝一份. 那么你可能会好奇了, 如果我们想有一种类似 <code>std::string_view</code> 或 <code>std::span</code> 那种视图一样不含所有权的结构, 应该怎么解决呢? 在 <code>C</code> 语言中, 常见的一种解决是传入一个内容指针 <code>context</code>, 以及一个回调的函数指针 <code>func</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">(<span class="type">void</span> *context, <span class="type">void</span>(*func)(<span class="type">void</span> *))</span> &#123;</span><br><span class="line">    func(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 C++ 中, 我们自然也可以自己实现一个类似的 <code>function_view</code>, 只需要在涉及右值的时候处理好生命周期即可 (我们不应该保存右值的视图, 因为 <code>rvalue</code> 可能是 <code>prvalue</code>, 在表达式结束后生命周期就结束被析构了). 这玩意网上的参考实现也很多, 这里就不多介绍了.</p><h3 id="optional-amp-variant"><a href="#optional-amp-variant" class="headerlink" title="optional &amp; variant"></a>optional &amp; variant</h3><p><a href="https://en.cppreference.com/w/cpp/utility/optional">optional</a>, <a href="https://en.cppreference.com/w/cpp/utility/variant">variant</a>, <a href="https://en.cppreference.com/w/cpp/utility/variant/get">get</a>, <a href="https://en.cppreference.com/w/cpp/utility/variant/get_if">get_if</a>, <a href="https://en.cppreference.com/w/cpp/utility/variant/visit">visit</a>, <a href="https://en.cppreference.com/w/cpp/utility/variant/holds_alternative">holds_alternative</a></p><blockquote><p>Remark: 需要 C++17</p></blockquote><ul><li><code>optional</code> 表示一个值可能是不存在, 也可能是存在的. 常见的场景是查找一个元素是否存在, 如果存在则返回这个元素, 否则返回一个特殊的状态, 表示不存在.</li><li><code>variant</code> 则表示存储的 <strong>可以且必须</strong> 是某几种值中的一个, 可以认为是加强版的 <code>optional</code>.</li></ul><p>可以看出, 这两个东西的存在就是为了取代 C 里面 <code>union</code> 的存在 (如果你还不知道, 可以自己先去了解一下). <code>union</code> 最大的问题, 是 RAII 资源管理相关的. 假如 <code>union</code> 里面的成员有析构函数, 那么在析构的时候, 应该调用哪个成员的析构函数呢? 处理不当, 非常容易造成资源泄露. 这时候, 我们就可以用到 <code>variant</code> 来管理了. 特别地, 如果只有 “有” 和 “没有” 两种状态, 那么我们可以用 <code>optional</code>, 它提供了更准确的语义.</p><p>当然, 虽然笔者一直提倡使用标准库, 但标准库也不是十全十美的. 比如 <code>optional</code> 里面, 标准禁止了其直接存引用类型例如 <code>std::optional&lt;int&gt;</code> (至少截至 C++23 如此). 仔细思考一下引用的语义是什么: 引用一个对象, 语义上等价于保证非空的指针解引用. 因此, <code>optional</code> 引用可以只存一个指针, 如果为空则表示 “没有引用”, 否则表示 “合法的引用”, 这完全是合情合理的. 它不会引入额外的开销 (甚至还能减少存储空间), 能提供更好的封装 (比起裸指针), 只可惜尚未进入标准库, 不过已经有 <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2988r9.pdf">提案</a>.</p><p>对于 <code>optional</code>, 笔者推荐结合其成员函数 <code>.and_then</code>, <code>.or_else</code>, <code>.transform</code> 之类使用, 以获得 monad 的效果. 当然, 你也可以用 <code>if (auto opt = func())</code> 来分别实现 <code>optional</code> 非空和空的逻辑. <code>optional</code> 的解引用并没有做边界检查 (非空与 type safety 无关), 如果想要做检查, 请使用 <code>.value</code> 函数来获取内部得引用.</p><p>对于 <code>variant</code>, 笔者推荐使用 <code>std::visit</code> 来遍历类型. <code>std::hold_alternatives</code> 一般只适用于 <code>variant</code> 里面类型不多, 或者只需要特判是不是某一两种特殊的类型 case. 通过 <code>std::get</code> 来访问 <code>variant</code> 是 type-safe 的, 不用担心访问到错误类型.</p><p>在构造 <code>optional</code> 的时候, 可以用 <code>std::nullopt</code> 表示空, 或者直接花括号 <code>&#123;&#125;</code> 默认构造为空, 或者用一个对应存储的类型. 如果你想要给已有的一个 <code>optional</code> 更新它的值, 除了可以用 <code>=</code>, 也可以用 <code>emplace</code> 原地构造.</p><p><code>variant</code> 类似, 但是默认构造会调用 <code>variant</code> 里面第一次类型的构造函数 (不一定存在, 此时 <code>variant</code> 不可默认构造). 一般来说, 如果希望 <code>variant</code> 也存在某种类似的 “空” 的状态, 我们会用 <code>std::monostate</code>. 赋值和 <code>emplace</code> 类似 <code>optional</code>.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::variant&lt;std::monostate, <span class="type">int</span>, <span class="type">float</span>, std::string&gt; v &#123;&#125;; <span class="comment">// default monostate</span></span><br><span class="line">v = <span class="number">1</span>; <span class="comment">// ok, construct an int</span></span><br><span class="line">v.<span class="built_in">emplace</span>&lt;std::string&gt;(<span class="number">100</span>, <span class="string">&#x27;a&#x27;</span>); <span class="comment">// good, construct directly</span></span><br></pre></td></tr></table></figure><p>需要注意, <code>optional</code> 和 <code>variant</code> 不涉及堆内存分配, 所有数据都存在内部.</p><h3 id="any"><a href="#any" class="headerlink" title="any"></a>any</h3><p><a href="https://en.cppreference.com/w/cpp/utility/any">any</a>, <a href="https://en.cppreference.com/w/cpp/utility/any/any_cast">any_cast</a>, <a href="https://en.cppreference.com/w/cpp/utility/any/make_any">make_any</a></p><blockquote><p>Remark: 需要 C++17</p></blockquote><p>当你完全不确定可能的类型, 并且希望进一步增加未来的可拓展性, 完全 “擦除” 类型的时候, 你可以用 <code>void *</code>. 它直接把类型完全抹去了, 但对应的, 在调用处, 你为了获取其确切类型, 只能用 <code>std::any_cast</code> 一个一个去判断.</p><p><code>any_cast</code> 当传入的是 <code>std::any</code> 的指针的时候, 会返回一个指针, 如果为空表示 <code>any</code> 存储的不是这个类型的, 否则为指向对象的指针. 当传入的是 <code>std::any</code> 的左值或右值引用时, 如果不是这个类型则会抛出异常, 否则返回存储类型的值. <code>any_cast</code> 对于传入引用的情况, 会自动地选择返回时候是进行移动构造还是复制构造.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">std::any x;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">auto</span> *y = std::<span class="built_in">any_cast</span>&lt;<span class="type">int</span>&gt;(&amp;x)) &#123;</span><br><span class="line">    <span class="comment">// y is an int * in this case</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// x doesn&#x27;t store an int</span></span><br><span class="line">    <span class="keyword">if</span> (x.<span class="built_in">has_value</span>()) &#123;</span><br><span class="line">        <span class="comment">// x is not default, or nullptr, or .reset() called.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        x.<span class="built_in">reset</span>(); <span class="comment">// reset to a state of empty</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// this is a common error!</span></span><br><span class="line"><span class="comment">// 1.0 is implicitly cast to std::any &amp;&amp; in this case</span></span><br><span class="line"><span class="comment">// I think this is deficiency of std library......</span></span><br><span class="line">std::<span class="built_in">any_cast</span>&lt;<span class="type">int</span>&gt;(<span class="number">1.0</span>);</span><br></pre></td></tr></table></figure><p>在赋值一个 <code>any</code> 的时候, 除了常见的 <code>=</code> 之外, 你也可以类似 <code>optional</code> 和 <code>variant</code>, 使用 <code>emplace</code> 来原地构造, 减少潜在的移动和复制. 当然, 直接构造也可以用 <code>std::make_any</code>.</p><p>由于不确定对象的大小, <code>std::any</code> 的构造往往涉及堆内存的分配, 不过编译器一般都有 small object optimization.</p><h3 id="format"><a href="#format" class="headerlink" title="format"></a>format</h3><blockquote><p>Remark: 需要 C++20</p></blockquote><p>由于时间限制, 简单的介绍可以参考: <a href="/cpp20/" title="C++ 20 部分特性尝鲜">C++ 20 部分特性尝鲜</a>. 进阶请自行 cppref.</p><h2 id="类型和模板的魔法"><a href="#类型和模板的魔法" class="headerlink" title="类型和模板的魔法"></a>类型和模板的魔法</h2><p>模板是 C++ 的核心特性. 模板本身就是图灵完备的, 它的功能非常强大. 当和 C 语言的宏结合在一起的时候, 他几乎能创造一切的其他语言. 当然, 这稍微有点夸张了, 但是模板的力量是非常强大的. 结合 C++17 的折叠表达式, 以及 C++11 的 lambda 函数, 你可以写出非常优雅的代码.</p><h3 id="从-format-到模板推导"><a href="#从-format-到模板推导" class="headerlink" title="从 format 到模板推导"></a>从 format 到模板推导</h3><p><a href="https://en.cppreference.com/w/cpp/language/class_template_argument_deduction">CTAD</a>, <a href="https://en.cppreference.com/w/cpp/utility/format/format">format</a></p><p>模板推导是非常令人头疼的一部分. 举例:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add</span><span class="params">(std::vector&lt;T&gt; &amp;v, T x)</span> -&gt; <span class="type">void</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;i : v)</span><br><span class="line">        i += x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">f</span><span class="params">()</span> -&gt; std::vector&lt;<span class="type">int</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> x = std::vector&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; <span class="comment">// need C++ 17 deduction guide,</span></span><br><span class="line">                                   <span class="comment">// the compiler can deduce x as std::vector&lt;int&gt;</span></span><br><span class="line">    <span class="built_in">add</span>(x, <span class="number">1.0</span>); <span class="comment">// error, int and double are incompatible</span></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可能预期的是, <code>T</code> 能够自己转化为 <code>int</code> (带来的是 <code>1.0</code> 被 cast 为 <code>1</code>), 但是事实上, 这是不可能的. 遗憾的是, 这里的 <code>vector&lt;T&gt;</code> 和 <code>T</code> 共同参与了类型的推导, 因此 <code>T</code> 的类型不相同, 无法通过编译.</p><p>一个简单粗暴的解决方案是: 第二个参数也使用模板. 但这不是我们今天的主题. 事实上, 第二个类型可能也是依赖推导的模板类型, 比如 <code>list&lt;T&gt;</code>, 但是实现了类型转化函数或者有其他的特殊要求等等. 针对我们现在的场景, 我们希望类型推导完全由 <code>vector&lt;T&gt;</code> 来决定. 这时候, 我们可以用到 <code>std::type_identity_t</code>.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add</span><span class="params">(std::vector&lt;T&gt; &amp;v, std::<span class="type">type_identity_t</span>&lt;T&gt; x)</span> -&gt; <span class="type">void</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;i : v)</span><br><span class="line">        i += x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>他的原理是: <code>std::type_identity_t</code> 是一个模板别名, 实际是 <code>type_identity&lt;T&gt;::type</code>. 而这里作为类的成员类型, 并不会参与推导, 因此 <code>T</code> 的类型完全由 <code>vector&lt;T&gt;</code> 决定. 这样, 我们就可以正确的推导出 <code>T</code> 的类型了. 这部分实际非常复杂, 具体请参考 <a href="https://en.cppreference.com/w/cpp/language/class_template_argument_deduction">cppreference CTAD</a>. 这个在实践中的确被用到了, 可以参考 <code>std::format</code> 的实现.</p><p>在 <code>std::format</code> 中, <code>format_string</code> 是 <code>consteval</code> 的, 并且其含有实际 format 的类型作为模板参数, 这是为了编译期做出类型检查. 如果暴力的写, 它可能长这样:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ...Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">format</span><span class="params">(std::format_string&lt;Args...&gt; str, <span class="type">const</span> Args &amp;...args)</span> -&gt; std::string</span>;</span><br></pre></td></tr></table></figure><p>这里, 我们需要避免 <code>format_string</code> 参与模板类型推导, 因为 <code>Args</code> 完全是由入参决定的. 这时候, 注意观察 <code>format_string</code> 的定义:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="keyword">using</span> format_string = basic_format_string&lt;<span class="type">char</span>, <span class="type">type_identity_t</span>&lt;Args&gt;...&gt;;</span><br></pre></td></tr></table></figure><p>这意味着, 在 <code>using</code> 的内层, 它用到了 <code>type_identity_t</code> 来避免了推导, 笔者可以在这里把 <code>using</code> 直接理解为 <code>#define</code>, 即直接替换为 <code>basic_format_string&lt;char, type_identity_t&lt;Args&gt;...&gt;</code>.</p><h3 id="模板递归"><a href="#模板递归" class="headerlink" title="模板递归"></a>模板递归</h3><p><a href="https://en.cppreference.com/w/cpp/language/fold">fold expression</a></p><p>一般来说, 模板递归需要用到特化, 这样的代码非常啰嗦.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">f</span><span class="params">()</span> -&gt; <span class="type">void</span> </span>&#123;</span><br><span class="line">    <span class="comment">// end of recursion</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span>... _Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">f</span><span class="params">(_Tp &amp;&amp;t, _Args &amp;&amp;...args)</span> -&gt; <span class="type">void</span> </span>&#123;</span><br><span class="line">    <span class="built_in">g</span>(t); <span class="comment">// do something</span></span><br><span class="line">    <span class="built_in">f</span>(args...); <span class="comment">// recursive call</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>幸运的是, 在 C++17 中, 我们有了 <code>if constexpr</code>, 这在一定程度上能减轻我们的负担:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// helper class</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">end_of_recursion</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp = end_of_recursion, <span class="keyword">typename</span>... _Args&gt;</span><br><span class="line"><span class="keyword">auto</span> <span class="built_in">f</span>(<span class="type">const</span> _Tp &amp;t = &#123;&#125;, <span class="type">const</span> _Args &amp;...args) -&gt; <span class="type">void</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">constexpr</span> (std::is_same_v&lt;_Tp, end_of_recursion&gt;) &#123;</span><br><span class="line">        <span class="comment">// end of recursion</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">g</span>(t);</span><br><span class="line">        <span class="built_in">f</span>(args...);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然, 不要忘记了我们还有 lambda 函数和折叠表达式:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span>... _Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">f</span><span class="params">(<span class="type">const</span> _Tp &amp;t, <span class="type">const</span> _Args &amp;...args)</span> -&gt; <span class="type">void</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> fn = [](<span class="keyword">auto</span> &amp;&amp;t) &#123;</span><br><span class="line">        <span class="built_in">g</span>(t);</span><br><span class="line">    &#125;;</span><br><span class="line">    (<span class="built_in">fn</span>(t), ...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模板-constexpr"><a href="#模板-constexpr" class="headerlink" title="模板 + constexpr"></a>模板 + constexpr</h3><p>模板还可以和强大的 <code>constexpr</code> 协同工作. 通过 <code>if constexpr</code>, 我们可以允许在输入模板参数不同的时候返回完全不一样的类型. 结合 <code>decltype</code>, 我们甚至可以更方便的写出根据某些常量来推导类型, 从而写出比 <code>std::conditional_t</code> 更加直观的代码.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> N&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">is_odd</span><span class="params">(<span class="type">int</span> n)</span> -&gt; <span class="type">bool</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n % <span class="number">2</span> == <span class="number">1</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> N&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(N == <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::string &#123;&#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">constexpr</span> (<span class="built_in">is_odd</span>(N)) &#123;</span><br><span class="line">        <span class="keyword">return</span> std::vector&lt;<span class="type">char</span>&gt; &#123;&#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> std::array&lt;<span class="type">char</span>, N&gt;&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">using</span> f_type = <span class="keyword">decltype</span>(<span class="built_in">f</span>&lt;N&gt;());</span><br><span class="line"></span><br><span class="line"><span class="comment">// use std::conditional_t</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">using</span> f_type2 = std::<span class="type">conditional_t</span>&lt;N == <span class="number">0</span>, std::string, std::<span class="type">conditional_t</span>&lt;<span class="built_in">is_odd</span>(N), std::vector&lt;<span class="type">char</span>&gt;, std::array&lt;<span class="type">char</span>, N&gt;&gt;&gt;;</span><br></pre></td></tr></table></figure><h3 id="模板-concept"><a href="#模板-concept" class="headerlink" title="模板 + concept"></a>模板 + concept</h3><p><a href="https://en.cppreference.com/w/cpp/language/sfinae">SFINAE</a>, <a href="https://en.cppreference.com/w/cpp/language/constraints">concept</a></p><p><code>SFINAE</code> 是一个老功能了. 他的全称是: <code>Substitution Failure Is Not An Error</code>. 他的作用是: 当模板参数推导失败时, 不会报错, 而是会继续尝试其他的模板. 例如:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">using</span> type = <span class="type">int</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="keyword">using</span> fallback = <span class="type">int</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">f</span><span class="params">(T)</span> -&gt; T::type </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">f</span><span class="params">(T)</span> -&gt; T::fallback </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">f</span>(A&#123;&#125;); <span class="comment">// ok, the first f is called</span></span><br><span class="line">    <span class="built_in">f</span>(B&#123;&#125;); <span class="comment">// ok, the second f is called</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里, 如果模板类型 <code>T</code> 没有 <code>type</code> 成员, 那么第一个 <code>f</code> 会被忽略, 而继续尝试第二个 <code>f</code>. 这就是 SFINAE 的作用. 其可以用于很多场景, 例如: 检查类型是否有某个成员, 检查类型是否满足某个特定的条件等等. 常见的搭配有 <code>std::enable_if_t</code>, <code>std::void_t</code> 等等. 如果 SFINAE 匹配到多个成功的模板, 会选择特化程度最厉害的, 这个说法一听就不是很严谨, 具体细节还是请参考 <a href="https://en.cppreference.com/w/cpp/language/sfinae">cppreference</a>.</p><p>然而, 在大部分情况下这样的代码可读性极差. 例如:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ensure T is an integral type, otherwise try other templates.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, std::<span class="type">enable_if_t</span>&lt;std::is_integral_v&lt;T&gt;, <span class="type">int</span>&gt; = <span class="number">0</span>&gt;</span><br><span class="line"><span class="keyword">auto</span> <span class="built_in">f</span>(T) -&gt; <span class="type">void</span> &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>幸运的是, C++20 的 <code>concept</code> 能够解决大部分这类问题, 其依然遵循的是 <code>SFINAE</code> 的原则, 但是使用更加直观的 <code>requires</code> 语句来明确指定模板的约束. <code>concept</code> 部分可以参考 <a href="https://darksharpness.github.io/cpp20">这篇文章</a>, 但是更推荐 <a href="https://en.cppreference.com/w/cpp/language/constraints">cppreference</a>.</p><p>对于上面那个例子, 可以简写为:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;std::integral T&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">f</span><span class="params">(T)</span> -&gt; <span class="type">void</span> </span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// another way</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">requires</span> std::integral&lt;T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">f2</span><span class="params">(T)</span> -&gt; <span class="type">void</span> </span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无论如何, 可读性都比无 <code>concept</code> 的 <code>SFINAE</code> 强太多了. 关于 <code>concept</code> 的四种写法, 除了 <a href="https://en.cppreference.com/w/cpp/language/concepts">cppreference</a>, 也可以参考 <a href="/cpp20/" title="C++ 20 部分特性尝鲜">C++ 20 部分特性尝鲜</a>.</p>]]></content>
    
    
    <summary type="html">被人拉着去讲 Modern C++ 了, 故作此文.</summary>
    
    
    
    <category term="C++" scheme="http://darksharpness.github.io/categories/C/"/>
    
    <category term="基础知识" scheme="http://darksharpness.github.io/categories/C/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="C++" scheme="http://darksharpness.github.io/tags/C/"/>
    
    <category term="基础知识" scheme="http://darksharpness.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>dispatcher is all you need</title>
    <link href="http://darksharpness.github.io/torch/"/>
    <id>http://darksharpness.github.io/torch/</id>
    <published>2024-11-26T18:08:43.000Z</published>
    <updated>2025-01-26T07:20:05.024Z</updated>
    
    <content type="html"><![CDATA[<!-- 咕咕咕, 等 OSDI 后再写. 如果你来 ping 我, 我会更快的更新. --><p><a href="http://blog.ezyang.com/2020/09/lets-talk-about-the-pytorch-dispatcher/">参考文献</a>. 这篇很经典, 讲的比我好多了. 本文只是基于笔者的实践, 对于原文的选择性翻译. 本文全部图片来自那篇 blog.</p><p>具体的实验配置请参考 <a href="#环境配置">环境配置</a> 章节.</p><blockquote><p>小插曲: 由于原网站只支持 http, 而大部分浏览器默认的是禁止 mix http with https, 本网站又是强制 https 的, 所以图片链接全炸了. 笔者因此把那部分图片全部传到自己的图床了.</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在你使用 PyTorch 的时候, 你是否有想过, 对应的函数例如 <code>torch.add</code> 具体是如何操纵数据的? 更进一步, 在你调用 <code>with torch.no_grad()</code> 的时候, 究竟是什么机制使得所有的 kernel 都不会保留 gradient?</p><p>你可能会说: <code>if</code> ! 对的, 等效的来看, <code>torch</code> 的实现无非是借助一个一个的 <code>if</code>, 如果你的 tensor 在 GPU 上, 并且你的数据类型是 <code>float16</code>, 那么就会调用对应的 <code>cuda + float16 + add</code> 的 kernel.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> dtype == torch.float16 <span class="keyword">and</span> device.<span class="built_in">type</span> == <span class="string">&#x27;cuda&#x27;</span>:</span><br><span class="line">    <span class="keyword">return</span> cuda_float16_add</span><br></pre></td></tr></table></figure><p>但是, 考虑到 dtype 不是一成不变的 (学术界会提出越来越多的 quantization dtype 例如 <code>bfloat16</code>, <code>float8_e5m2</code>), 以及未来潜在的新的 device (比如 TPU, FPGA 等等). 在考虑可拓展性的情况下, 如果每种 kernel 都写成这种又臭又长的 <code>if</code> 条件判断的话, 那么后期的代码维护将会变得异常困难. 每多一个新的 dtype 或者 device, 开发者就需要把每个 kernel 都加上新的 <code>if</code>. 显然, 我们希望对于一个新的场景, 可以在不侵入修改原有代码的情况下实现.</p><p>这时候, 你可能会从你大一的程序设计课程中寻找灵感, 于是(笔者假设)你找到了一个类似的场景: 对于同一个函数, 表现出多态性, 可以使用虚函数 + 继承来实现. 这的确可以直接解决烦人的一堆 <code>if</code>, 但也有自己的局限性.</p><ol><li>虚函数一般是由虚表实现的, 而虚表是静态的, 无法在运行时注册用户的函数, 需要在编译期就全部确定, 用户拓展体验极差.</li><li>虚函数无法做到 bypass. 即对于同一个 tensor 的同一个函数 (比如前面的 <code>cuda + fp16 + add</code>), 在不同状态下 (比如 <code>with torch.no_grad()</code>), 选择不同的 kernel 去调用.</li></ol><p>为了更好的动态性和可维护性, 我们需要一套更加灵活的框架, 于是就有了 torch 的 Dispatcher.</p><h2 id="一些术语"><a href="#一些术语" class="headerlink" title="一些术语"></a>一些术语</h2><p><code>op</code>(operator): 算子, 表示对于数据的某种抽象操作, 比如 <code>add</code>.<br><code>kernel</code>: 算子的某种具体实现 (一般场景下可能指的是 cuda kernel, 但是本文放宽到所有类型的实现)<br><code>dtype</code>: torch 中表示数据类型的类, 常见的数据类型有 <code>int32</code>, <code>float32</code> 等等.<br><code>device</code>: torch 中表示数据所在的设备的类, 常见的设备有 <code>cuda</code>, <code>cpu</code> 等等.<br><code>layout</code>: torch 中表述数据存储形式的类, 常见的有 <code>strided</code>, <code>sparse_coo</code> 等等.<br><code>Tensor</code>: torch 的核心数据抽象, 可以理解为一块多维的矩阵, 可以认为是一个 <code>shared_ptr</code> + 内部实现.<br><code>IValue</code>(Interpreter Value): torch 的一种值类型, 类似 <code>std::any</code>, 可以存储常见值类型 (比如 <code>Tensor</code>, <code>int</code>).</p><h2 id="什么是-Dispatcher"><a href="#什么是-Dispatcher" class="headerlink" title="什么是 Dispatcher"></a>什么是 Dispatcher</h2><p>Dispatcher, 简单来说, 就是每个 op 具体应该调用哪个 kernel 的决定者. 决定调用哪个 op, 首先肯定要取决于输入 op 的 tensor 的本身的 dtype 和 device. 同时, 为了能够支持全局的某些开关 (比如 <code>torch.no_grad()</code>), 我们在 dispatch 的时候也需要考虑全局 global 的一些设定.</p><p>于是乎, 我们可以开始快乐的手搓动态虚表啦. 我们给每个可能的 key (op + device + dtype) 注册一个函数, 保留对应的函数指针. 但是, 事情并没有想象的那么简单.</p><h3 id="Boxing"><a href="#Boxing" class="headerlink" title="Boxing"></a>Boxing</h3><p>首先, 不同的 op 接受的参数是不一样的. <code>add</code> 需要输入两个 tensor 作为输入, 但是 <code>to</code> 就需要一个 tensor 加上对应的 dtype 或者 device. C++ 作为一种静态语言, 调用的 function 的函数签名必须是编译期确定并且匹配的, 但是每个 op 的函数签名是不尽相同的. 如果要中心化的用 dispatcher 来管理 dispatch, 那么 C++ 静态特性要求你的函数签名必须是完全相同的, 否则你就需要给每种函数签名单独维护一个 mapping, 这样的代码也会变得臃肿而难以维护.</p><p>因此在这里, 我们需要引入 boxing 的概念. boxing 指的是, 我们对于 torch 中的用到的类型, 比如 <code>tensor</code>, <code>int64</code>, <code>float32</code> 等等, 统一装到一个类型里面. 看到这里, 相信读者很自然的能联想到 <code>std::any</code>, <code>std::variant</code> 之类的东西. 这就是 torch 里面重要的值类型: <code>IValue</code>. 他把类型签名全部抹去, 把不同的类都尽可能装入了同一个 <code>IValue</code> 类里面, 从而部分解决了 C++ 静态类型的问题. 当然, 这样是不够的, 除了参数类型不同, 参数数量可能也是不一样的, 所以我们还需要手动维护一个 std::vector 类似的结构, 使得输入的参数类型可以是变长的即可. 以下即为一种简单的实现:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Possible combination of keys</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">KeyType</span> &#123;</span><br><span class="line">    std::string op_name;</span><br><span class="line">    Dtype data;</span><br><span class="line">    Device device;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// Possible Implementation</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DispatchTable</span> &#123;</span><br><span class="line">    std::unordered_map&lt;KeyType, std::function&lt;std::any(std::vector&lt;std::any&gt;)&gt;&gt; table;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://s3.bmp.ovh/imgs/2025/01/26/1cc1d873b86666a1.png" alt="关于 box 的示意图">.</p><p>通过 boxing, 我们就可以很方便的中心化管理一个大 mapping, 其本质上是 C++ 中类型擦除的思想, 在 <code>std::any</code> 和 <code>std::variant</code> 中都有涉及.</p><h3 id="Dispatch-Logic"><a href="#Dispatch-Logic" class="headerlink" title="Dispatch Logic"></a>Dispatch Logic</h3><p>boxing 解决了接口一致性的问题, 使得中心化管理变得可能. 但这样一个框架, 他不一定方便. 假如 torch 真的采用了类似我们的伪代码的实现, 那么其很难支持动态的插入 <code>torch.no_grad()</code> 等涉及全局状态逻辑.</p><p>对于每一种涉及全局状态的逻辑, 如果把 global state 也直接暴力融入 dispatch key 之中, 那么就会遇到复杂度爆炸: 对于每一种可能的组合, 你都需要给予一种映射规则, 但是在考虑上全局状态后, 每一个额外的状态都会使得组合的可能乘以 2 (e.g. device + dtype + auto_grad + tracing……). 而全局状态到处都是: tracing, auto_grad, fake tensor 等等. 重新审视我们的全局状态, 很多时候我们其实不 care 两个 state 同时启用的时候是如何协同的, 在层层抽象之后, 不同模块之间应当已经良好的解耦了.</p><p>对于 tracing, auto_grad, fake_tensor 这些类似 hook 的功能, 我们其实只是希望能在调用真实的 kernel 前后先做点事情. 更近一步, 我们更希望的是他能像 python 的 decorator 一样, 由具体的实现来决定是否继续调用下面的 kernel:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">dummy_hook_function</span>(<span class="params">f, args</span>):</span><br><span class="line">    <span class="comment"># in reality, you may do something before/after `f`</span></span><br><span class="line">    <span class="comment"># you may even avoid calling `f` under certain circumstance</span></span><br><span class="line">    <span class="keyword">return</span> f(args)</span><br><span class="line"><span class="comment"># original</span></span><br><span class="line">real_kernel(args);</span><br><span class="line"><span class="comment"># original + hook</span></span><br><span class="line">hook_function(real_kernel, args);</span><br></pre></td></tr></table></figure><p>因此, 我们实际要做的是, 对于某些全局状态, 如果启用了, 那么在 dispatch 的时候, 在调用真实 kernel 的前后插入一些执行逻辑.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Possible combination of keys</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">KeyType</span> &#123;</span><br><span class="line">    std::string op_name;</span><br><span class="line">    Dtype data;</span><br><span class="line">    Device device;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// Possible Implementation</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DispatchTable</span> &#123;</span><br><span class="line">    <span class="keyword">using</span> Args_t = std::vector&lt;std::any&gt;;</span><br><span class="line">    <span class="keyword">using</span> F = std::function&lt;std::<span class="built_in">any</span>(Args_t)&gt;;</span><br><span class="line">    std::unordered_map&lt;KeyType, F&gt; table;</span><br><span class="line">    std::vector &lt;std::pair&lt;F, Args_t&gt;&gt; hooks;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>事实上, 复杂度爆炸一个很重要的原因就是, 存在协同操作的可能. 如果功能两两不相交, 那么 dispatch 的时候只需要调用最高优先级的那个 kernel 就可以了, 是否继续往下调用取决于最高优先级的 kernel, 这些适用于绝大部分的全局状态. 如果维护两两相交的状态, 假设一共有 $n$ 种状态, 那么复杂度一下子就从 $O(n)$ 上升到了 $O(n^2)$, 更别说所有的一起考虑, 那就是 $O(2^n)$ 了.</p><p>在实际的 torch dispatcher 的实现中, 是以 op 为中心维护的. 对于一个 op, 其维护了一个 key_set, 表示可能的 backend (即 device) 以及 functional key (即前面说的 Fake Tensor, Autocast 之类的). 而 DispatchKeySet 则是由两者拼接而成的, 本质上是一个 bitset.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Part of the code from PyTorch: include/c10/core/DispatchKey.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> C10_FORALL_BACKEND_COMPONENTS(_, extra) \</span></span><br><span class="line"><span class="meta">  _(CPU, extra)                                 \</span></span><br><span class="line"><span class="meta">  _(CUDA, extra)                                \</span></span><br><span class="line"><span class="meta">  _(HIP, extra)                                 \</span></span><br><span class="line"><span class="meta">  _(XLA, extra)                                 \</span></span><br><span class="line"><span class="meta">  _(MPS, extra)                                 \</span></span><br><span class="line"><span class="meta">  _(IPU, extra)                                 \</span></span><br><span class="line"><span class="meta">  _(XPU, extra)                                 \</span></span><br><span class="line"><span class="meta">  _(HPU, extra)                                 \</span></span><br><span class="line"><span class="meta">  _(VE, extra)                                  \</span></span><br><span class="line"><span class="meta">  _(Lazy, extra)                                \</span></span><br><span class="line"><span class="meta">  _(MTIA, extra)                                \</span></span><br><span class="line"><span class="meta">  _(PrivateUse1, extra)                         \</span></span><br><span class="line"><span class="meta">  _(PrivateUse2, extra)                         \</span></span><br><span class="line"><span class="meta">  _(PrivateUse3, extra)                         \</span></span><br><span class="line"><span class="meta">  _(Meta, extra)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">BackendComponent</span> : <span class="type">uint8_t</span> &#123;</span><br><span class="line">  InvalidBit = <span class="number">0</span>,</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFINE_BACKEND_COMPONENT(n, _) n##Bit,</span></span><br><span class="line">  <span class="built_in">C10_FORALL_BACKEND_COMPONENTS</span>(DEFINE_BACKEND_COMPONENT, unused)</span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> DEFINE_BACKEND_COMPONENT</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Define an alias to represent end of backend dispatch keys.</span></span><br><span class="line">  <span class="comment">// If you add new backend keys after PrivateUse3, please also update it here.</span></span><br><span class="line">  EndOfBackendKeys = MetaBit,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">DispatchKey</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ FIN ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //</span></span><br><span class="line">  EndOfFunctionalityKeys, <span class="comment">// End of functionality keys.</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">static_assert</span>(</span><br><span class="line">    (<span class="built_in">static_cast</span>&lt;<span class="type">uint8_t</span>&gt;(BackendComponent::EndOfBackendKeys) +</span><br><span class="line">     <span class="built_in">static_cast</span>&lt;<span class="type">uint8_t</span>&gt;(DispatchKey::EndOfFunctionalityKeys)) &lt;= <span class="number">64</span>,</span><br><span class="line">    <span class="string">&quot;The BackendComponent and DispatchKey enums (below EndOfFunctionalityKeys)&quot;</span></span><br><span class="line">    <span class="string">&quot; both map to backend and functionality bits&quot;</span></span><br><span class="line">    <span class="string">&quot; into a 64-bit bitmask; you must have less than 64 total entries between them&quot;</span>);</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Part of the code from PyTorch: include/c10/core/DispatchKeySet.h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DispatchKeySet</span> <span class="keyword">final</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">constexpr</span> <span class="keyword">explicit</span> <span class="title">DispatchKeySet</span><span class="params">(BackendComponent k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k == BackendComponent::InvalidBit) &#123;</span><br><span class="line">      repr_ = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      repr_ = <span class="number">1ULL</span> &lt;&lt; (<span class="built_in">static_cast</span>&lt;<span class="type">uint8_t</span>&gt;(k) - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">constexpr</span> <span class="keyword">explicit</span> <span class="title">DispatchKeySet</span><span class="params">(DispatchKey k)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// NOLINTNEXTLINE(bugprone-branch-clone)</span></span><br><span class="line">    <span class="keyword">if</span> (k == DispatchKey::Undefined) &#123;</span><br><span class="line">      <span class="comment">// Case 1: handle Undefined specifically</span></span><br><span class="line">      repr_ = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (k &lt;= DispatchKey::EndOfFunctionalityKeys) &#123;</span><br><span class="line">      <span class="comment">// Case 2: handle &quot;functionality-only&quot; keys</span></span><br><span class="line">      <span class="comment">// These keys have a functionality bit set, but no backend bits</span></span><br><span class="line">      <span class="comment">// These can technically be either:</span></span><br><span class="line">      <span class="comment">// - valid runtime keys (e.g. DispatchKey::AutogradOther,</span></span><br><span class="line">      <span class="comment">// DispatchKey::FuncTorchBatched, etc)</span></span><br><span class="line">      <span class="comment">// - &quot;building block&quot; keys that aren&#x27;t actual runtime keys (e.g.</span></span><br><span class="line">      <span class="comment">// DispatchKey::Dense or Sparse)</span></span><br><span class="line">      <span class="type">uint64_t</span> functionality_val = <span class="number">1ULL</span></span><br><span class="line">          &lt;&lt; (num_backends + <span class="built_in">static_cast</span>&lt;<span class="type">uint8_t</span>&gt;(k) - <span class="number">1</span>);</span><br><span class="line">      repr_ = functionality_val;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (k &lt;= DispatchKey::EndOfRuntimeBackendKeys) &#123;</span><br><span class="line">      <span class="comment">// Case 3: &quot;runtime&quot; keys that have a functionality bit AND a backend bit.</span></span><br><span class="line">      <span class="comment">// First compute which bit to flip for the functionality.</span></span><br><span class="line">      <span class="keyword">auto</span> functionality_k = <span class="built_in">toFunctionalityKey</span>(k);</span><br><span class="line">      <span class="comment">// The - 1 is because Undefined is technically a &quot;functionality&quot; that</span></span><br><span class="line">      <span class="comment">// doesn&#x27;t show up in the bitset. So e.g. Dense is technically the second</span></span><br><span class="line">      <span class="comment">// functionality, but the lowest functionality bit.</span></span><br><span class="line">      <span class="type">uint64_t</span> functionality_val = <span class="number">1ULL</span></span><br><span class="line">          &lt;&lt; (num_backends + <span class="built_in">static_cast</span>&lt;<span class="type">uint8_t</span>&gt;(functionality_k) - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// then compute which bit to flip for the backend</span></span><br><span class="line">      <span class="comment">// Case 4a: handle the runtime instances of &quot;per-backend functionality&quot;</span></span><br><span class="line">      <span class="comment">// keys For example, given DispatchKey::CPU, we should set:</span></span><br><span class="line">      <span class="comment">// - the Dense functionality bit</span></span><br><span class="line">      <span class="comment">// - the CPUBit backend bit</span></span><br><span class="line">      <span class="comment">// first compute which bit to flip for the backend</span></span><br><span class="line">      <span class="keyword">auto</span> backend_k = <span class="built_in">toBackendComponent</span>(k);</span><br><span class="line">      <span class="type">uint64_t</span> backend_val = backend_k == BackendComponent::InvalidBit</span><br><span class="line">          ? <span class="number">0</span></span><br><span class="line">          : <span class="number">1ULL</span> &lt;&lt; (<span class="built_in">static_cast</span>&lt;<span class="type">uint8_t</span>&gt;(backend_k) - <span class="number">1</span>);</span><br><span class="line">      repr_ = functionality_val + backend_val;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// At this point, we should have covered every case except for alias keys.</span></span><br><span class="line">      <span class="comment">// Technically it would be possible to add alias dispatch keys to a</span></span><br><span class="line">      <span class="comment">// DispatchKeySet, but the semantics are a little confusing and this</span></span><br><span class="line">      <span class="comment">// currently isn&#x27;t needed anywhere.</span></span><br><span class="line">      repr_ = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">constexpr</span> <span class="title">DispatchKeySet</span><span class="params">(<span class="type">uint64_t</span> repr)</span> : repr_(repr) &#123;</span>&#125;</span><br><span class="line">  <span class="type">uint64_t</span> repr_ = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当然, 在实践中, torch 还有很多的细节, 比如 DispatchKey enum 并不只有 functional key, 还有 backend + functional 的交叉 key 组合 (比如 SparseCUDA, QuantizedMPS). 在计算 DispatchKeySet 的时候, 对于组合的 key 会手动的拆成 bitset 中的两个 bit. 在实际决定按照哪个 dispatch key 优先的时候, 会把所有的 tensor input 含有的 key 汇集在一起, 加上全局的一些状态量, 最后先调用 DispatchKeySet 中的最高的那个 bit 对应的 kernel.</p><blockquote><p>Remark: 如果仔细看一眼 DispatchKeySet 的构造函数的逻辑, 你会发现 functionality 的 key 的优先级是高于 device 的 key 的. 这很合理, 功能性一般都是 override 在 function 之上的.</p></blockquote><p><img src="https://s3.bmp.ovh/imgs/2025/01/26/6cdc40305760d4f9.png" alt="Which kernel shall i call?"></p><h2 id="实验部分"><a href="#实验部分" class="headerlink" title="实验部分"></a>实验部分</h2><p>说了这么多, 该写代码了. Talk is cheap, show me the code.</p><h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><p>笔者使用的是 <code>nvcc 12.4</code> + <code>PyTorch 2.5.1</code> + <code>gcc 13.2</code> + <code>clangd 19.1.2</code> 的组合. 关于 torch 的安装, 请参考 <a href="https://pytorch.org/get-started/locally/">官网</a>. 笔者选择的是 <code>2.5.1 + Linux + pip + cuda 12.4</code>. 环境管理笔者用的是 conda:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">conda create -n torch python=3.10 -y</span><br><span class="line"><span class="comment"># 这一段请参考官网配置</span></span><br><span class="line">conda activate torch</span><br><span class="line">pip3 install torch torchvision torchaudio</span><br></pre></td></tr></table></figure><p>然后创建一个 <code>test.cu</code> 文件, 作为测试代码用的文件, 后面的改动都将放在这个文件中. 这里参考了 torch 官方给出的 <a href="https://pytorch.org/tutorials/advanced/cpp_extension.html">custom C++ extension</a> 的部分.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;torch/extension.h&gt;</span></span></span><br><span class="line"><span class="built_in">PYBIND11_MODULE</span>(TORCH_EXTENSION_NAME, m) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了 setup 整个项目, 还需要一个 setup.py 文件, 随后只需要 <code>python setup.py install</code> 即可编译并安装 <code>my_test</code> 库.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> setuptools <span class="keyword">import</span> setup</span><br><span class="line"><span class="keyword">from</span> torch.utils <span class="keyword">import</span> cpp_extension</span><br><span class="line"></span><br><span class="line">setup(name=<span class="string">&#x27;my_test&#x27;</span>,</span><br><span class="line">      ext_modules=[cpp_extension.CppExtension(<span class="string">&#x27;my_test&#x27;</span>, [<span class="string">&#x27;test.cu&#x27;</span>],</span><br><span class="line">                                              extra_compile_args=[<span class="string">&#x27;-O3&#x27;</span>])],</span><br><span class="line">      cmdclass=&#123;<span class="string">&#x27;build_ext&#x27;</span>: cpp_extension.BuildExtension&#125;)</span><br></pre></td></tr></table></figure><p>当然, VSCode 默认 C/C++ 插件的代码补全显然是找不到需要的头文件的, 这会使得我们的编程变得极其痛苦. 笔者推荐使用 clangd 插件 + compile_commands.json.</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;directory&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/home/dark/workspace/torch&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;arguments&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="string">&quot;/usr/local/cuda/bin/nvcc&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;-I/home/dark/miniconda3/envs/torch/lib/python3.10/site-packages/torch/include&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;-I/home/dark/miniconda3/envs/torch/lib/python3.10/site-packages/torch/include/torch/csrc/api/include&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;-I/home/dark/miniconda3/envs/torch/lib/python3.10/site-packages/torch/include/TH&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;-I/home/dark/miniconda3/envs/torch/lib/python3.10/site-packages/torch/include/THC&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;-I/home/dark/miniconda3/envs/torch/include/python3.10&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;-c&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;test.cu&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;-o&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;build/temp.linux-x86_64-cpython-310/test.o&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;-D__CUDA_NO_HALF_OPERATORS__&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;-D__CUDA_NO_HALF_CONVERSIONS__&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;-D__CUDA_NO_BFLOAT16_CONVERSIONS__&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;-D__CUDA_NO_HALF2_OPERATORS__&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;-O3&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;-DTORCH_API_INCLUDE_EXTENSION_H&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;-DPYBIND11_COMPILER_TYPE=\&quot;_gcc\&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;-DPYBIND11_STDLIB=\&quot;_libstdcpp\&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;-DPYBIND11_BUILD_ABI=\&quot;_cxxabi1011\&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;-DTORCH_EXTENSION_NAME=my_test&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;-D_GLIBCXX_USE_CXX11_ABI=0&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;-std=c++17&quot;</span></span><br><span class="line">        <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;file&quot;</span><span class="punctuation">:</span> <span class="string">&quot;test.cu&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><p>读者只需修改其中 miniconda, nvcc, 工作目录等路径即可. 当然, 这样可能不是非常具有可拓展性. 笔者获取 compile_commands.json 的方式是, 先直接运行一次 <code>python setup.py install</code>, 他会在命令行输出对应的编译指令. 读者可以复制其给出的编译指令, 然后用以下的 python 脚本拆分:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">msg = <span class="string">&quot;&quot;</span> <span class="comment"># 这里换成你的编译命令</span></span><br><span class="line">seg = msg.split()</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="built_in">print</span>(json.dumps(seg, indent=<span class="number">4</span>))</span><br></pre></td></tr></table></figure><p>至此, 你的 clangd 大概是能工作了, 读者也可以自行删除一些会让 clangd 无法识别的命令行参数.</p><h3 id="年轻人的第一个-pybind"><a href="#年轻人的第一个-pybind" class="headerlink" title="年轻人的第一个 pybind"></a>年轻人的第一个 pybind</h3><p>首先先写一个 Hello World 来熟悉一下 pybind 的流程, 这里暂时不涉及 torch 的内容. pybind 简单来说就是允许你从 python 一侧调用 C++ 的函数, 对于基本类型提供了自动转换的功能 (比如 C++ 的 bool 到 python 的 bool). 我们在 test.cu 中加入一个 <code>hello</code> 函数:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;torch/extension.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">auto</span> <span class="title">hello</span><span class="params">(<span class="type">int</span> n)</span> -&gt; std::string </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello World! &quot;</span> &lt;&lt; n &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">to_string</span>(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">PYBIND11_MODULE</span>(TORCH_EXTENSION_NAME, m) &#123;</span><br><span class="line">    m.<span class="built_in">def</span>(<span class="string">&quot;hello_world&quot;</span>, hello); <span class="comment">// Define hello_world function in python</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后, 使用 <code>python setup.py install</code> 来编译并安装. 在安装好后, 在 python 中运行以下的代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch <span class="comment"># 这是一个小细节, 似乎必须先 import torch 再 import 自己的拓展</span></span><br><span class="line"><span class="keyword">import</span> my_test</span><br><span class="line"></span><br><span class="line">x = my_test.hello_world(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># print(x, type(x))</span></span><br></pre></td></tr></table></figure><p>你应该会得到意料之中的结果, 即输出了 <code>&quot;Hello World! 1&quot;</code>, 并且 x 是字符串 <code>&quot;1&quot;</code>.</p><h3 id="年轻人的第一个-torch-extension"><a href="#年轻人的第一个-torch-extension" class="headerlink" title="年轻人的第一个 torch extension"></a>年轻人的第一个 torch extension</h3><p>当然, 我们写 torch extension 大概率不只是为了用到 pybind 的功能, 我们可能还想要自己定义一些 op. 在 torch 中, 你可以自己注册一个 op, 也可以为已有的 op 按照一定规则绑定 key 和 kernel. 简单来说, 有三种注册模式:</p><ol><li>注册一个新的 op 并且绑定默认的 kernel</li><li>为某一个 key 绑定 kernel (fallback)</li><li>为某个 op + key 绑定 kernel</li></ol><p>这里引用一下原文的图来解释:</p><p><img src="https://s3.bmp.ovh/imgs/2025/01/26/d3a8536f4417a26d.png" alt="new op"><br><img src="https://s3.bmp.ovh/imgs/2025/01/26/36b6a8c526527abf.png" alt="functionality"><br><img src="https://s3.bmp.ovh/imgs/2025/01/26/4777ef735747bbe1.png" alt="op + functionality"><br><img src="https://s3.bmp.ovh/imgs/2025/01/26/059407e79872f76c.png" alt="summary &amp; priority"></p><p>下面, 我们用一些简单的代码来演示这些功能.</p><blockquote><p>Remark: 以下部分和原 blog 稍有出入, 毕竟那篇 blog 都是 5 年前的玩意了</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstddef&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;torch/extension.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">auto</span> <span class="title">hello</span><span class="params">(<span class="type">int</span> n)</span> -&gt; std::string </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello World! &quot;</span> &lt;&lt; n &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">to_string</span>(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">auto</span> <span class="title">add_1_forward</span><span class="params">(at::Tensor x)</span> -&gt; at::Tensor </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> &amp;&amp;op  = c10::Dispatcher::<span class="built_in">singleton</span>().<span class="built_in">findSchemaOrThrow</span>(<span class="string">&quot;aten::add_1&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">auto</span> stack = c10::Stack&#123;&#125;;</span><br><span class="line">    stack.<span class="built_in">push_back</span>(<span class="built_in">static_cast</span>&lt;at::TensorBase&gt;(x));</span><br><span class="line">    <span class="comment">// call boxed kernel</span></span><br><span class="line">    op.<span class="built_in">callBoxed</span>(&amp;stack);</span><br><span class="line">    <span class="keyword">return</span> stack[<span class="number">0</span>].<span class="built_in">toTensor</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">auto</span> <span class="title">add_1_cpu</span><span class="params">(at::Tensor x)</span> -&gt; at::Tensor </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">constexpr</span> <span class="keyword">auto</span> kKeySet = c10::DispatchKeySet&#123;c10::DispatchKey::TESTING_ONLY_GenericMode&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">auto</span> <span class="title">custom_hook</span><span class="params">(<span class="type">const</span> c10::OperatorHandle &amp;op, c10::Stack *stack)</span> -&gt; <span class="type">void</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> kGuard   = c10::impl::ExcludeDispatchKeyGuard&#123;kKeySet&#125;;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">auto</span> counter = std::<span class="type">size_t</span>&#123;&#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Custom hook called &quot;</span> &lt;&lt; counter++ &lt;&lt; <span class="string">&quot; times&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> op.<span class="built_in">callBoxed</span>(stack);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">auto</span> <span class="title">enable_hook</span><span class="params">(<span class="type">bool</span> enable)</span> -&gt; <span class="type">void</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">auto</span> guard = std::optional&lt;c10::impl::IncludeDispatchKeyGuard&gt;&#123;&#125;;</span><br><span class="line">    <span class="keyword">if</span> (enable) &#123;</span><br><span class="line">        guard.<span class="built_in">emplace</span>(kKeySet);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        guard.<span class="built_in">reset</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">PYBIND11_MODULE</span>(TORCH_EXTENSION_NAME, m) &#123;</span><br><span class="line">    m.<span class="built_in">def</span>(<span class="string">&quot;hello_world&quot;</span>, hello); <span class="comment">// Define hello_world function in python</span></span><br><span class="line">    m.<span class="built_in">def</span>(<span class="string">&quot;add_1&quot;</span>, add_1_forward);</span><br><span class="line">    m.<span class="built_in">def</span>(<span class="string">&quot;enable_hook&quot;</span>, enable_hook);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">TORCH_LIBRARY_FRAGMENT</span>(aten, m) &#123;</span><br><span class="line">    <span class="comment">// register add_1 function for aten namespace</span></span><br><span class="line">    m.<span class="built_in">def</span>(<span class="string">&quot;add_1&quot;</span>, [](at::Tensor) -&gt; at::Tensor &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Debug: Not implemented yet!&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">TORCH_LIBRARY_IMPL</span>(aten, CPU, m) &#123;</span><br><span class="line">    <span class="comment">// register add_1 function for aten namespace</span></span><br><span class="line">    m.<span class="built_in">impl</span>(<span class="string">&quot;add_1&quot;</span>, add_1_cpu);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">TORCH_LIBRARY_IMPL</span>(_, TESTING_ONLY_GenericMode, m) &#123;</span><br><span class="line">    m.<span class="built_in">fallback</span>(torch::CppFunction::<span class="built_in">makeFromBoxedFunction</span>&lt;custom_hook&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码很长, 但是核心是最后三个以 TORCH_LIBRARY 开头的东西. 如果你希望在原有的 aten library 里面增加 op, 需要用到 <code>TORCH_LIBRARY_FRAGMENT</code> 这个宏,  <code>TORCH_LIBRARY</code> 代表的是一个新的 library, 这一点和原文略有不同. 在编译完上述代码之后, 可以用以下 python 代码进行测试:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> my_test</span><br><span class="line"></span><br><span class="line">x = torch.tensor([<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>])</span><br><span class="line"><span class="built_in">print</span>(my_test.add_1(x))</span><br><span class="line"></span><br><span class="line">my_test.enable_hook(<span class="literal">True</span>)</span><br><span class="line">y = my_test.add_1(x)</span><br><span class="line">y = y + <span class="number">1</span></span><br><span class="line">my_test.enable_hook(<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(y)</span><br></pre></td></tr></table></figure><p>理论上, 你应该看到以下的输出:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tensor([2., 3., 4.])</span><br><span class="line">Custom hook called 0 times</span><br><span class="line">  Operator: aten::add_1</span><br><span class="line">Custom hook called 1 times</span><br><span class="line">  Operator: aten::add</span><br><span class="line">tensor([3., 4., 5.])</span><br></pre></td></tr></table></figure><p>这里鼓励读者多做一些尝试. 比如尝试 <code>x = x.to(&#39;cuda&#39;)</code>, 看看这时候再调用 <code>my_test.add_1(x)</code> 有何效果. 同时, 读者也可以尝试去除 <code>custom_hook</code> 中的 <code>kGuard</code>, 这个 guard 的作用是在构造的时候临时 disable 指定的 DispatchKeySet, 并且在析构的时候恢复原样 (类似 <code>std::lock_guard</code> 的原理), 看看结果是否和你想的一样. 或者, 读者也可以自行修改 <code>custom_hook</code>, 比如尝试不调用 <code>callBoxed</code> 等等. 同时, 观察一下 <code>custom_hook</code>, 相信读者也能意识到 boxing 的重要性: 如果没有 boxing, 根本无法为不同函数签名的各种 op 注册一个统一的 fallback.</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>没啥好总结的, PyTorch 为解决 kernel 分发问题提出的 Dispatcher 抽象是非常成功的. 其解决了多种功能 key 组合带来的复杂度爆炸的问题, 把 backend 和 functionality 作为 DispatchKeySet 的一部分, Dispatcher 每次调用最高优先级的 key 对应的 kernel, 由被调用的 kernel 决定是否继续 redispatch 调用其他 kernel, 并且提出了 boxing 的抽象, 成功解决了虚函数的静态性的问题, 实现了一套统一的 dispatch 的机制, 避免了满天飞的 <code>if</code> 特判.</p><p>这一套框架乍一看很自然, 但是在你自己写的是很难想到如此多的细节的, 很容易写着写着就多出来一堆 <code>if</code>, 最后代码逻辑复杂到自己都看不懂. 不仅如此, PyTorch 还做了大量工程上的优化, 提供了许多工程上的便利, 这部分非常考验 C++ 的功底. 比如 DispatchKeySet 实际上就是压位压到了 64-bit 以内, 从而可以用一个整数直接表示, 这样避免了用动态 bitset 甚至是 vector 之类的结构, 减少了内存占用. 同时, 通过 <code>DispatchKeyGuard</code> 可以很方便的临时 <code>enable/disable</code> 某些全局 key, 这类 RAII 的思想也使得代码变得非常清晰易读 (这里点名批评 C 的 goto 作为 cleanup). 而 boxing 的核心 <code>IValue</code> 本身也用到了 <code>sso</code> 的思路 (可以参考 <a href="/cpp/#small-size-optimization"> 这一部分 </a>), 从而减少了内存的分配, 增强了数据的局部性, 提升了整体的性能.</p><p>总之, 要多看啊.</p>]]></content>
    
    
    <summary type="html">pytorch 写的是真的好. 本文会简单分析 torch 的 dispatcher, 以及实现在 C++ 侧实现自定义的 torch extension.</summary>
    
    
    
    <category term="C++" scheme="http://darksharpness.github.io/categories/C/"/>
    
    <category term="Framework" scheme="http://darksharpness.github.io/categories/C/Framework/"/>
    
    
    <category term="C++" scheme="http://darksharpness.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>杂七杂八的东西 - 大三上小结</title>
    <link href="http://darksharpness.github.io/misc/"/>
    <id>http://darksharpness.github.io/misc/</id>
    <published>2024-11-04T09:10:49.000Z</published>
    <updated>2025-01-08T08:17:12.598Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>2024-12-25 更新, 打算直接把这学期的总结写这里算了, 懒得开新的帖子了, 之前是某个周末的日记</p></blockquote><p>转眼间学期都要结束了, 遂决定记录一下这学期的时间都浪费在了哪里. 没啥逻辑, 乱序记录 <del>大概率又是流水账</del>.</p><blockquote><p>剧透警告! 本文将涉及 TV 版 《寒蝉鸣泣之时》 和 《魔法少女小圆》 的部分剧情, 在观看前请谨慎!<br>为了读者的健康考虑, 本文不会放出任何血腥暴力图片, 但是可能含有微量恐怖元素.</p></blockquote><h2 id="前言-amp-真-·-总结"><a href="#前言-amp-真-·-总结" class="headerlink" title="前言 &amp; 真 · 总结"></a>前言 &amp; 真 · 总结</h2><p>出于某些原因, 笔者在大二一整年都没有更新自己的学期小结. 事实上, 笔者自认为大二的两学期几乎是虚度过去的, 在那时候, 笔者似乎一点都没有为未来做打算或考虑, 反而困于自己的精神内耗. 感谢 <a href="https://github.com/zsq259">hastin</a>, <a href="https://github.com/jpppppppppppppppppppppppp">jpp</a>, <a href="https://github.com/radioheading">Radioheading</a>, <a href="https://github.com/Wankupi">Wankupi</a> 等好友的陪伴(按字母序), 让我走过了那个迷茫的阶段, 他们都是超级 nice 的人. 那时候无名的痛苦已经不复存在, 笔者或许也应该去寻找自己未来的方向了. 不过在确定自己方向之前, 也该回顾以下自己做了些什么吧.</p><p>平心而论, 这学期我并没有使出 100% 的力气 (这里面有一些令人不悦的客观因素这里暂且不谈), 但是却感到了 200% 的疲惫. 笔者处于一种想要摆烂, 但是却摆不下来, 又卷不上去的状态. 首先是 10 月给开源项目 <a href="https://github.com/sgl-project/sglang">sglang</a> 和 <a href="https://github.com/mlc-ai/xgrammar">xgrammar</a> 打工. 感谢 <a href="https://github.com/hnyls2002">yls</a> 学长的介绍, 让我接触到了最顶尖的一批学者, 只是笔者一开始完全不懂得珍惜 (其实也是见识少, 没有意识到原来我自己也能 have an impact on the whole world), 写代码的时候并没有那么的全心全意的投入, 现在想来感到十分愧疚. 愧疚自然是没有用的, 还是需要靠自己的努力在未来去弥补的.</p><p>除了开源项目, 还有实验室和高年级学长的项目. 笔者在这里又坑了一波学长, 笔者在 9 月及以前对整个 storyline 的理解不够透彻, 导致走了很多的弯路, 一个 7 月开始的项目前三个月几乎就是废了, 这里面确实有我不小的责任. 幸运的是, 10 月份的时候笔者总算找对了方向, 项目代码也在一次次重构中可以跑起来了, 在 11 月末 12 月初经历了一系列紧张刺激的试验后 (e.g. 之前写炸写出了线程炸弹, 直接让集群宕机了一次 xs, 幸好当时没有别人在跑), 也总算是赶上了 OSDI 25 的 ddl. 只能说带我的老板真的吊, 一周时间直接把 paper 肝完了, 而且顾及到了很多笔者完全想不到的点, 笔者之后或许还需要多学学 writing (tell a story!). (小广告, 快来催更这个吧 <a href="/torch/"> dispatcher is all u need </a>)</p><p>在 12 月 OSDI 论文结束后, 笔者又忙着 rush 了 CV 大作业的一些任务以及其他不少之前落下的科目 (不过都不是很认真, 需要反思). 转眼间, 2025 年也到了, 笔者在新年的第一周开启了低功耗模式, 简单来说就彻底开摆, 甚至为此鼓起勇气和家长小吵了一场 (不过能获取家人的理解还是非常重要的). 难得的低压生活, 让笔者甚至有一点不太适应, 不过确实也是时候 take a good rest and prepare for the next leap 了.</p><p>笔者从两年前的寒假之后, 似乎就一直处于高压模式, 动机大概就是高考后遗症, 想要卷过身边的人, 但这是没有意义的. 还是应该寻找生活中 doki doki 的时刻的. 于是乎, 笔者便倾尽自己的全部, 写下了这些.</p><blockquote><p>写于 2025/01/08 16:00 UTC + 08, D19 107 寝室</p></blockquote><h2 id="Minecraft"><a href="#Minecraft" class="headerlink" title="Minecraft"></a>Minecraft</h2><p>在 9 月初暑假的两周, 在家没啥干劲, 每天唯一想做的事情就是和下一届的同学一起玩 mc. 虽然时间很短, 但是还是造了很多有趣的玩意的.</p><p>我主要管了以下这些玩意:</p><ul><li>恶魂塔 - 这玩意也造过 4,5 次了, 简单而有效, 从此火药不是梦想</li><li>岩浆怪/蛙鸣灯刷怪塔 - 这次我没偷懒, 把 5 层都造满了 <del>青蛙开心坏了</del></li><li>凋零玫瑰塔 - 虽然西瓜/南瓜的部分还没实装, 但是黑色染料是再也不缺了 (笑)</li><li>仙人掌农场 - 简单堆叠, 后面还可以再改进? 好看才是第一生产力.</li></ul><p>可以看得出, 笔者<del>就是</del>基本都是在摸鱼, 也没负责什么非常肝的机器. 不过笔者还是有幸见证了 “世界吞噬者” 的建造 &amp; 运行过程, 的确是非常的震撼. 不过最开心的还是能够和同学们一起玩, 共同造有趣的东西. We create!</p><p><img src="https://s3.bmp.ovh/imgs/2024/12/25/281c2d1b197420c5.png" alt="猪人塔 by Hartmann_Psi"></p><p><img src="https://s3.bmp.ovh/imgs/2024/12/25/6c57664fd33fcf1d.png" alt="笔者的蛙鸣灯农村"></p><p><img src="https://s3.bmp.ovh/imgs/2024/12/25/e96e84e273dd8d1f.png" alt="世界吞噬者"></p><p><img src="https://s3.bmp.ovh/imgs/2024/12/25/f63106b6e7efffa1.png" alt="可怜的村民 (x)"></p><p><img src="https://s3.bmp.ovh/imgs/2024/12/25/9f7bafc7b89d7ccc.png" alt="蚌埠住了"></p><p>不过玩到最后还是遇到了每次玩纯生存遇到的巨大难题, 会陷入一种没的东西可造的境地. 虽然创造是无限的, 但是作为学生时间有限 <del>没有那么多肝</del>, 实在是没办法全心全意造非常 fancy 的机器, 而简单 plain 的机器也就那么一点点……</p><p>不过在 mc 中消磨时间虽然是无意义的, 但对我本人来说也是快乐的, 这份快乐贯穿了我的童年, 从小学到现在, 从来没有一个游戏能这样 catch me. 永远无法忘记, 小学每次往返老家的时候, 在车上玩手机玩 mc 的经历. 依稀记得某次从绍兴回来, 见到 mc 中漫天雪舞的场景, 那可能是童年最美的景色. <del>和我玩一辈子的 mc 吧😭</del></p><p>寒假或许还能玩玩服务器, 不过在有限的时间中, 如何创造, 如何给大家带来快乐, 如何避免玩到后来无事可做的困境, 这还是一个难题. 之前搞砸了太多的 mc 计划了, 感觉对自己已经不太有信心了, 不过我或许也没时间再 arrange 一次 mc 计划了, 大一的那些快乐时光看起来永远的离去了.</p><h2 id="寒蝉"><a href="#寒蝉" class="headerlink" title="寒蝉"></a>寒蝉</h2><blockquote><p>以下可能含有剧透内容, 请谨慎阅读.<br>以下内容潜在有血腥描述, 可能会导致阅读时感到不适, 请谨慎阅读!</p></blockquote><p>前情提要, 笔者是一个平时不怎么看番的人, 不过对一些知名的作品还是略有耳闻的. 早在笔者 18 年入坑东方的时候, 就有听过 “同人三大奇迹” 的寒蝉, 也听过 “蝉在叫, 人坏掉” 之类的描述, Foreground Eclipse 制作的二次创作同人曲再次增加了我对这个作品的印象, 不过由于高中忙着学习<del>制作音乐</del> 以及沉迷东方, 所以没有找到一个契机入坑.</p><p>说来也巧, 在 9 月开学前后, 由于 b 站刷到了一个相关的二次创作作品, 再加上开学那段时间实在是过于无聊, 便阴差阳错地开始看寒蝉鸣泣之时, <del>作为猎奇小鬼</del> 这种作品自然是不能错过的. 在观看前, 我简单了解了一下 TV 作品的架构, 分为出题篇和解题篇, 听起来挺像是侦探小说的样子, 然后就愉快的开看了.</p><h3 id="出题篇"><a href="#出题篇" class="headerlink" title="出题篇"></a>出题篇</h3><p><del>不亏是热血番</del> 第一集就给人当头一棒属实难绷, 然而后面的剧情可谓是更加的刀. 出题篇由鬼隐篇, 绵流篇, 祟杀篇, 暇溃篇组成, 不同的篇章有着类似的情节发展. 在看解答篇之前, 整部作品给我一种强烈的不和谐感: 先是<del>后宫番一样</del>惬意的日常校园生活, 每次却从一个人发疯开始, 然后是各种同伴之间的猜疑, 恐怖的人物崩坏, 渐渐开始有人失踪有人死亡, 直到最后整个村子的人全部死亡, 几乎无人幸免. 而且, 人们死的是如此的惨: 男孩拿棒球棒敲碎了同伴的头颅, 随后抓破了自己的喉咙而死; 可爱小女孩惨死神社门口, 甚至还被做了肠流 (慎查, 超级恐怖……).</p><p><img src="https://s3.bmp.ovh/imgs/2025/01/06/6728ce6b6a064324.png" alt="蕾娜可爱"></p><p>在看完出题篇以后, 我的感觉是, 这可能是一个多时间线设定的作品, 而没有尽头的血腥和杀戮不断地紧绷着笔者的神经 (当时看完心里真的超级压抑沉重). 那些人为什么会突然发病? 究竟是谁, 是幕后黑手? 究竟是为何, 要让这些少年少女背上如此沉重的因果? 身边的同伴, 过于热心的警官, <del>少女心</del>医生和每年都会来的摄影师, 似乎每个人都有嫌疑. 带着问题 (是个好习惯 xs), 我继续了解题篇的观看.</p><h3 id="解题篇"><a href="#解题篇" class="headerlink" title="解题篇"></a>解题篇</h3><p>随着剧情发展,我才知道, 原来, 有一个叫做 “雏见泽症候群” 的东西, 似乎是一离开女王携带者的人就会发病, 这也解释了为什么会有人开始发病 (并不是由于什么诅咒). 而发病的背后, 其实是黑心医生在作祟. 所谓的医者仁心, 居然是为了让社会认可自己的研究, 不惜以整个村庄的人的生命作为代价, 制定了所谓的 “终末计划”, 既然自己得不到应有的认可, 那就要拉更多的人下水. 私欲完全盖过了人性, 做人的底线都丢失, 属实恶心. 而各位小伙伴病情恶化的主要因素, 也是互相之间的不信任: K1 怀疑蕾娜的饭里面有针, 魅音 (其实是诗音) 怀疑园崎本家是之前一系列诅咒作祟的元凶, 蕾娜怀疑朋友们不会帮自己保密…… 梨花, 作为时间的穿越者, 逐渐认识了事情的真相. 在大家克服了相互之间的猜疑之后, 终于齐心协力团结一心, 打破了命运的诅咒, 成功在某一条时间线中活过了那个无人生还的六月.</p><p><img src="https://s3.bmp.ovh/imgs/2025/01/06/d226ba2dd4f915bb.png" alt="-"></p><blockquote><p>感觉剧情概括似乎写太多了 x</p></blockquote><p>最后看完还是稍微有点小感动的 <del>(笔者看得少泪点低, 轻喷)</del>, 虽然最后基于奇迹才扳回一城的设定属实有点不太合理 (尤其是一开始我还差点把这个当本格推理番来看, 结果魔法都出来了…), 但是整个故事还是非常耐人寻味的. 解题篇基本很好的回复了前面出题篇的各个疑问, 梨花最后的点睛之笔 “这个世界不需要输家” 也是非常切合我当时的感想.</p><p><img src="https://s3.bmp.ovh/imgs/2025/01/06/5f78e9ce438666a6.png" alt="梨花"></p><h3 id="一些杂七杂八的感想"><a href="#一些杂七杂八的感想" class="headerlink" title="一些杂七杂八的感想"></a>一些杂七杂八的感想</h3><blockquote><p>笔者杂七杂八的想法, 没有任何深度</p></blockquote><p>整个故事其实就是经典的以小见大, 从一个小故事切入去分析背后隐藏的巨大的体制问题. 34 医生虽然是幕后黑手, 但她也是一个受害者, 一个从小苦命的孩子 (经典设定, 反派的苦衷, 笔者对此不做评价). 她努力学期, 渴望自己的研究被认可, 却发现人们认可的不过是自己的导师名气罢了. 人走茶凉的现实让她崩溃, 而一场黑暗的政治斗争又在她最绝望的时候给了她一个证明自己的计划, 只不过代价是一个村子的人的性命…… 从某种角度来看, 她自己也是一个悲惨的, 从来没有被真正认可, 甚至可以说的上是政治斗争的牺牲品的人. 没有人生来就是坏人, 只是被一时甚至一世的黑暗蒙蔽了双眼.</p><p>作品中梨花和其他小伙伴选择原谅了 34, 这大抵是寒蝉想表达的 “爱与信任” 的主题吧. 可能是笔者的觉悟不够, 但无论如何, 笔者始终无法认同、原谅其为此做出泯灭人性的行为.</p><p>除此之外, 作品中的流血表现, 属实是令人稍微有点生理不适. 老实说, 我一直有在质疑该类题材的作品的动机, 不过不得不说, 流血表现是黑暗人性的一种极端的体现, 那种刻在人基因中的恐惧给人带来的冲击力是无法取代的. 对于这个作品, 我认为这种极端的表现带来的效果是非常的好的, 足够发人深省. (虽然但是, 在后续作品 “业” 和 “卒” 中, 某些画面真的把我恶心坏了, 死的是难以形容的惨…… 不推荐看那两个新作)</p><blockquote><p>New Remark: 三个月前看的了, 剧情遗忘的有点厉害, 当初的感触也已经几乎消失殆尽了, 还是应该早点写的哎</p></blockquote><p>以及, 不得不说原作的结尾属实是有点生草, 几个小孩子打赢了”山狗”雇佣兵 (我打雇佣兵, 真的假的?), 这些属实是过于离谱了. 不过, 梨花的能力 “穿越时空” 本身其实就是一种奇迹, 通过作品推测, 所谓的结局不过是无数次轮回中唯一成功的那次, 所谓的 good ending 可能也只是奇迹的产物 (最后 34 近距离子弹射偏也证实了这一点). 虽然但是, 小伙伴齐心协力对抗命运, 成功打破命运的那一刻, 还是非常感人的, 奇迹与宿命.</p><p>根据某位同学的说法, 游戏的剧情描写似乎会更加全面一些, 不会像 TV 一样割掉了很多的内容. 不过笔者不太是一个能玩得来 galgame 类游戏的人, 或许以后有空了可能会去玩玩吧. 龙绘看起来也不错 (笑)</p><h2 id="小圆"><a href="#小圆" class="headerlink" title="小圆"></a>小圆</h2><blockquote><p>以下可能含有剧透内容, 请谨慎阅读.<br>以下内容潜在有血腥描述, 可能会导致阅读时感到不适, 请谨慎阅读!<br>在写这部分的时候, 刚写完前面寒蝉的总结, 笔者发现似乎不应该写那么多剧情相关的, 故后面的内容可能会掠过概括部分, 感兴趣的读者建议去看.</p></blockquote><p>前文也提到, 笔者是一个平时几乎不怎么看番的人, 所以小圆这种经典作品也是没有看过的. 也是不知道出于什么动机, 突然想去看小圆了, 于是乎笔者在两周的时间内看了 TV 和剧场版新/旧篇. 很多时候做一件事情似乎也不需要一个明确的动机. 笔者第一次听说小圆这个名词, 是在 <a href="/CP29/"> CP29 </a>. 依稀记得是在场馆靠近边缘的某家店, 老板娘提到她们是东方和小圆的粉丝, 从此 “小圆” 这个名词就深深地植入了我的脑子里. 大概是名字里面的 “魔法少女” 的缘故, 再加上年末一周实在没有干劲, 于是遂在 12/21 晚上开始看小圆 <del>圆神启动</del></p><p>内容就不过多概括了, 感兴趣的读者强烈建议去看原片 (b 站有, 不过不知道被和谐了多少). 只能说, 笔者确实算是被 “魔法少女” 四个字骗进来杀的臭现充.</p><p>一些小插曲: 在观看的过程中, <a href="https://github.com/Wankupi">Wankupi</a> 同学 突然发现小圆的爸爸和笔者的老板 <a href="https://www.cs.sjtu.edu.cn/~chen-quan/">quan chen</a> 稍微有点像, 仔细一看好像还真的有点, 可能是因为都是和蔼可亲的父亲的形象吧 (笑). 这里留给读者自行评判 x</p><div class="gallery-container" data-type="data" data-button="" data-limit="10" data-first="10">    <div class="gallery-items">[{"url":"https://s3.bmp.ovh/imgs/2025/01/06/dab0d5daa4fb718a.png","alt":"小圆的爸爸","title":""},{"url":"https://www.cs.sjtu.edu.cn/~chen-quan/IMG_0930-edited.jpg","alt":"笔者的老板","title":""}]</div>  </div><h3 id="TV-版本篇"><a href="#TV-版本篇" class="headerlink" title="TV 版本篇"></a>TV 版本篇</h3><blockquote><p>以下内容可能含有大量笔者地主观臆测, 请勿参考<br>写这一部分的时候, 反反复复的看了好几遍原片, 细节确实不少. 我也要成为圆学家了 (笑)</p></blockquote><p>老实说, 一开始看的时候, 我是以一个美少女<del>百合</del>番的心理预期去看的. 虽然第一集的 op 似乎暗示了战斗的大背景, 但是前几集的剧情走向似乎过于平和, 看不出很大的危险. 除了出现了一个叫做 “晓美焰” (又称 “小焰”) 的看起来和主角 “小圆” 敌对的人物, 看起来大家的关系都非常的和善. 资深巴麻美学姐带头消灭魔女 (与魔法少女敌对的物种), <del>老东西</del> QB <del>不是 quantum bit</del> 可以帮你实现成为魔法少女的愿望, 甚至还能额外满足你的一个愿望(原话: 和我签订契约, 成为魔法少女吧!), 魔法少女还有美丽的服装和超帅的变身动画 (笑). 直到这一幕……</p><p><img src="https://s3.bmp.ovh/imgs/2025/01/06/7c22800c1e1ed7d0.png" alt="学姐掉头..."></p><p>说实话, 在音乐骤变的那一刻, 我大概就预料到了这一刻的到来, 但是还是没想到会这么有冲击力. 是啊, 光鲜亮丽的魔法少女背后, 是每天都要冒着生命危险和魔女战斗, 上一刻还在有说有笑的朋友, 下一刻直接就天人永隔. 学姐是一个孤独而脆弱的人, 她成为魔法少女是为了保住自己的性命 (她的家人在车祸中去世…). 在遇到小圆和沙耶香之前, 她是孤身一人在战斗, 可谓是每天走在生死线上. 她拼命锻炼来提升自己的能力, 努力让自己变得坚强. 小圆的到来让她以为自己有了同伴, “带着如此幸福的心情战斗还是第一次” <del>死亡 flag</del> 她丢失了自己的性命. 优雅的学姐就这样结束了自己悲惨的一生.</p><p>后面的故事是小圆、沙耶香、杏子、晓美焰几人支撑起来的. 在一次次与魔女的战斗中, 战斗残酷的一面也逐渐地暴露出来了. 不过最令人揪心的, 还是每个人面对的自己的困境. 沙耶香为了治好爱人的病症, 成为了魔法少女. 虽然嘴上说的是绝对不会为了自己而使用魔法, 但是所做的一切还是为了别人 <del>心上人上条恭介</del>. 她自己给自己设定了一个崇高的目标 (为了其他人而不求回报地奋斗, 代替之前学姐的位置), 内心却还是希望自己能和心上人在一起. 在心上人被自己曾经拯救过的挚友仁美夺舍之后, 她的内心濒临崩溃, 开始走向极端, 完全不顾身边好友的关心, 在战斗中自暴自弃.</p><p><img src="https://s3.bmp.ovh/imgs/2025/01/06/dc40523060784ac7.png" alt="口是心非的沙耶香"></p><p>笔者推测, 沙耶香实质上只是出于对于心上人的爱而许下了愿望, 却以不求回报的守护他人为借口默默地奋斗. 她其实非常希望自己能和恭介在一起, 但是好友的介入以及她自己的退避又让她十分痛苦. 她只能以责任感作为借口、战斗作为逃避, 却始终找不到自己战斗的意义. 在笔者的视角里, 她看起来是抛弃了一切的世俗的欲望, 但又放不下, 因为她根本没有这样的觉悟和动机啊 (她只是一个 14 岁的少女啊). 她的结局也是意料之外情理之中: 身上背负的诅咒太多, 灵魂宝石 soul gem 变得过于浑浊, 最终导致她变成了魔女 (魔法少女的末路是魔女). 为别人而祈愿, 希望能不求回报的奋斗, 但真实的心愿无法实现而感到痛苦. 在剧情中, 她无法忍受无法与爱人在一起、自己的身躯变成灵魂宝石 (设定: 魔法少女本体是 soul gem)、以及自认为守护的一切的肮脏 (最后黑化之前, 电车上听到的几个出生男人的对话), 她也意识到了自己行为与先前所说的 “正义的使者” 格格不入, 最终在价值破灭之后走向毁灭.</p><p>在看到这里的时候, 笔者其实对结局感到极其悲观. 这份绝望远胜于寒蝉, 至少寒蝉里面还看到有一些好转的迹象, 在出题篇结束的时候, 还有蕾娜靠意念正面硬刚 L5 的成功典范. 但在小圆里面, 学姐上来就死了, 沙耶香变成了魔女, <del>和沙耶香相爱相杀的</del>杏子试图唤醒魔女化的沙耶香无果, 最后也和沙耶香变成的人鱼魔女一起暴了. 主线只剩下小圆和晓美焰了. 扑面而来的宿命感, 为什么要让这些美少女背负如此沉重的因果, 我看不到明天的曙光.</p><p>在倒数第三集的时候, 也终于交代了全作中冷静的离谱的局外人 —— 晓美焰 的身世. 意料之中的, 她是一个时间穿越者 <del>怎么又是时间穿越</del>, 前面的剧情也有数不清的伏笔. 具体来说, 她有操控时间的能力, 可以暂停时间, 甚至把时间倒退 (虽然只看到她用来回到与小圆初次见面之前, 没看她用来短时回溯, 可能是防止能力太 bug 导致的). 在最初的时间线, 她只是一个娇弱的、害羞的麻花辫眼睛妹, 而在这个世界里面, 小圆则是一个非常热心开朗的女孩子, 早早的就和 QB 签订了契约成为了魔法少女, 也曾出手拯救了晓美焰.</p><p><img src="https://s3.bmp.ovh/imgs/2025/01/06/6c5c5d863e9b1609.png" alt="害羞 homura 酱, 和开朗的 madoka!"></p><p>在第一个时间线目睹了魔女之夜小圆的死之后, 她于悲痛中许下愿望, 希望能让与小圆的相遇重来, 能够保护小圆而不是让小圆保护她. 拯救小圆, 避免小圆的死, 拯救那个被 QB 欺骗成为魔法少女, 最后变成魔女的 “笨蛋” 小圆, 成为了晓美焰无数次读档重开的动力. “无数次轮回相同的时间, 寻找把你从绝望的命运中拯救出来的到道路”. 这份穿越时空的真挚的友情, 也是让笔者颇为触动.</p><p><img src="https://s3.bmp.ovh/imgs/2025/01/06/c09c21602ec6722a.png" alt="你能不能去救救那个还没被 qb 欺骗的那个笨蛋的我吗"></p><p>到头来, 一切都只是泡影. 在笔者看来, 变身魔法少女就是一个庞氏骗局. 签订契约成为魔法少女, 可以实现一个愿望, 但是带来的是与魔女无尽的战斗. 如果没能及时通过 grief seed (击败魔女的产物) 来恢复, 那么灵魂宝石 soul gem 就会变得污浊. 而最终的阶段就是成为魔女, 变成自己曾经最痛恨的敌人, 丧失作为人的一切理智. 事实上, 这个过程其实也就是魔法少女自己对内心真正愿望逐渐感到绝望的过程. 魔法少女因追求希望而生, 又在无法实现梦想的绝望中, 逐渐变得污浊, 最后沦为魔女. 整个设定其实是细思极恐的, 魔法少女必须击败魔女才能维持状态, 而魔女又是由魔法少女产生的…… QB 在宣传魔法少女的时候刻意隐瞒了这一点, 趁人之危让少女们许下心愿并为之战斗, 却从来没有透露一点关于成为魔法少女之后的改变的信息, 也难怪晓美焰每次轮回都忙着宰了这玩意.</p><p>在最后的这一次轮回中, 不出意外的, 晓美焰还是没能单刷魔女之夜. 历经了无数次轮回的历练, 她早已不再是当初那个羸弱的眼镜妹, 她摘下了眼睛, 收起了双马尾, 用冷酷的外表、干练的行动藏起了脆弱的内心. 但是, 一个人的力量终究是有限的. 更加绝望的是, QB 也指出, 小圆身上如此多的因果, 以至于成为最有潜力的魔法少女, 其实就是因为小焰一次次的轮回导致的. 这似乎在暗示着, 一切悲剧的源头还是晓美焰自身的愿望 (虽然笔者其实并没有看懂原作的这一段, 蹲一个解答). 再最后一次试图逆转时间的时候, 小焰犹豫了. 如果逆转时间, 小圆身上的因果又会增加, 这似乎只会给小圆带来更多的不幸.</p><p>剧情发展到这里, 我完全不知道这场悲剧将如何收尾. 如果小焰就此放弃了, 成为了魔女, 那自然是 bad ending, 唯一的逆转结局的棋子也丢失, 再也没有共命运抗争的武器了. 如果小圆成为魔法少女且最终没有变成魔女, 首先设定上是与之前无数次的结局相悖的, 其次这样会使得小焰无数次穿越时间的努力都将成为徒劳. 西西弗斯式的努力, 这一切似乎注定没有意义.</p><p>在最后的关头, 小圆出场了. 老实说, 虽然番名叫做 《魔法少女小圆》, 但实际上小圆的线非常的隐讳, 可以说整个故事的发展中, 小圆几乎就是一个旁观者. 她目睹了同伴的死亡、魔女化, 但晓美焰的阻拦、魔法少女的悲惨结局又使她没有迈出那一步. 事实上, 也得亏晓美焰一直在阻拦, 在笔者记忆中, 最开始的时间线中, 小圆似乎只是出于一个非常小的心愿就成为了魔法少女. 小圆本人其实并没有成为魔法少女的动机, 她身边有最好的同伴、幸福美满的家庭, 也没有一个突出的需要为之奋斗的目标, 可以想象她在前几个轮回中就是吃了 QB 的忽悠才成为了魔法少女. 直到最后一集之前, 圆的光辉都是被其他几个人盖住的, 剧情中塑造了性格鲜明的学姐、沙耶香、杏子、晓美焰, 让观众看到了她们的希望与绝望. 不过小圆也确实有在暗中发力, 她最早意识到小焰行为背后的苦衷, 也是在目睹了魔法少女的悲惨结局之后, 许下了愿望: “神什么的都好, 至今为止和魔女战斗的大家, 相信希望的魔法少女, 我不想再让她们哭泣, 希望她们都能笑着到最后. 任何妨碍这些的法则, 我会打破它, 重写它. 这就是我的祈愿, 我的愿望! 来! 实现它吧”. 于是小圆就成为了神一样的存在 <del>圆神启动</del>, 成功的改变了宇宙的法则, 重写了世界线, 成为了宇宙法则一样的概念 “圆环之理”. 在新的世界中, 所有的魔法少女不再会因为绝望而变成魔女, 而是在寻求希望的因果给世界带来诅咒之前, 被 “圆环之理” 带走. 而小圆的人生变得和宇宙一样永恒, 没有开始没有终结. 在新的世界里面, 没有人还记得小圆, 只有晓美焰还保有那份和鹿目圆在一起生活的记忆 <del>谁是真正的主角就不用我多说了</del>.</p><p><img src="https://s3.bmp.ovh/imgs/2025/01/08/ede976cd1466320f.png" alt="最后的祈愿"></p><p>笔者在看到这个结局的时候感到非常震撼, 小圆为了那些由希望而生的魔法少女, 做出了如此的牺牲. 正如晓美焰所说的, 这样比死掉还过分啊…… 笔者并不认为自己很好的理解了这个结局背后的意味. 或许在笔者有一些新的思考之后, 会来补全这一部分.</p><p>整体而言, 这是一部打着魔法少女噱头, 把笔者这种臭现充骗进来杀的黑暗番. TV 里面的主角都是青春期的少女, 她们大多有着非常悲惨的身世, 被 QB 诱骗成为了魔法少女. 而行为与最初愿望的开始偏离, 无法达到想要的结局, 便会催生绝望. 而小圆在最后下定了决心挺身而出, 在某种意义上拯救了所有魔法少女.</p><p>笔者看完该作品, 内心感到极其的沉重以及震撼, 遂写了一堆自己的感想. 感觉已经好久没有看到这样的作品了, 上次看到如此致郁系作品, 大概是 19 年的时候看到了恋恋的心跳大冒险, 也是给当时刚入东方的我迎头一击 (当然, 那个作品无论是细节, 还是思考的深度应该都远不及小圆, 毕竟只有一个人在创作), 也同样给读者带来了不少的思考. 我能在沙耶香身上见到自己曾经的影子: 有私欲, 但是没有勇气去实践, 遂转向一个宏大的志向 (不求回报的奋斗) 去逃避, 试图给找到自己存在的意义. 但是内心的情感是不会欺骗自己的, 我希望得到他人的认可 (或者某种形式的回报), 会因为无法得到而痛苦. 沙耶香是笔者很不想走向的结局, 至少现在, 笔者不应该草率做出一些影响终身的决定, 还是应当更加遵从内心. 晓美焰是笔者在剧中最喜欢的一个角色, 她有着明确的目标: 从无数次的轮回中, 找到救出小圆的办法. 她对小圆的那份炽烈的情感, 以及为之奋斗的执着, 真的令笔者不禁落泪 (当时看第十集的时候, 笔者真的被感动坏了).</p><p>无论如何, 魔法少女小圆, 在笔者的大学生活中算是留下了非常浓墨重彩的一笔. 这也是笔者第一次倾尽自己的情感, 记录自己的感受. 只能说这个作品完全对上了笔者的 XP.</p><h3 id="新约剧场版-叛逆的物语"><a href="#新约剧场版-叛逆的物语" class="headerlink" title="新约剧场版 - 叛逆的物语"></a>新约剧场版 - 叛逆的物语</h3><!--> 小圆 = madoka, 小焰 = homura.说实话, 在几乎一口气看完小圆 TV 版本的时候, 我就在感叹, homura 简直是我的神. 这份穿越了时空守护 madoka 的心意与勇气, 一度让我觉得她才应该是主角 ~~魔法少女小焰说~~. 个人感觉在人物的塑造上, homura 的那份炽烈的情感, 那份不变的意志, 贯穿了麻花辫娇弱少女和冷漠黑长直时期的小焰. 而直到最后才做出抉择, 守护世人的 madoka, 似乎总觉得表现力不 如 homura.--><p>To be continued… (主要是看的时候过于迷惑, 文中引用的 DaFort 的意象还没想的太清楚)</p><h3 id="一些其他的感想"><a href="#一些其他的感想" class="headerlink" title="一些其他的感想"></a>一些其他的感想</h3><p>To be continued… 大概会有: 1. 关于人物塑造(虽然笔者没啥鉴赏力). 2. 关于音乐(这个真的可以有!) 3. 作画 (精神污染, 不过有一些有意思的意象) 4. 一些有趣的细节</p><h2 id="live"><a href="#live" class="headerlink" title="live?"></a>live?</h2><p>12 月初狠狠地赶了一波 OSDI25 ddl, 之后又没停直接开冲网络考试. 意料之中的忙碌. 不过在最艰难的时候, 支撑着我的 <del>不仅有莉莉白</del> 一大主要动力大抵是 16 号的 live.</p><p>在 10 月份的时候, 就在 <a href="https://galneryus.jp/">Galneryus 乐队官网</a>上看到了 news 说要来中国公演, 然后几乎一点没犹豫就买了票. 考虑到上次乐队来中国似乎已经是 10 年前, 这次的机会显得额外的珍贵.</p><p>12 月 16 日上海场的 live 在五角场那边举行. 高德地图显示, 从交大出发过去大概需要 2h. live 是 20:00 开始, 所以我稍微提前了一点, 17:20 左右就出发了. 实际到那边的其实要快得多, 19:00 就到了.</p><p>作为一个耳朵尚未经过 livehouse 多次摧残的耳机党, 非常幸运的是我携带了降噪耳机, 这玩意拯救了我的耳膜. 在去之前两天看过有些人评论在广州/深圳场, 前排都要被震聋了, 于是决定携带耳机. 这玩意确实能极大的降低外界的音量 (至少降低到一个比我平时听歌响一点的量级), 坏处是对高频的损失有点严重, 感觉 4000Hz 附近的声音衰减的厉害, 不过所有丢失的部分都能脑补就是了, 专辑还是听过很多遍的 (笑).</p><p>live 上的 band 的表现还是非常不错的. syu 确实和 <del>传说</del> 传言中一样, 现场弹的比录音室还要稳, solo 一点都不拖泥带水的, 弹得非常干净 (要是能弹得像他 20 年前那样稳感觉我也无敌了). syu 人也巨幽默, 表情过于丰富, 经常会做出令人稍微有点难绷的表情, 不过其本人的陶醉其中也是真实的. 也终于知道 yuhki 小可爱这个称号怎么来的了, 一直慈祥(?)的笑着看观众, 中间 Emotions 那首和 syu 的对飙 solo 也是酷爆了. 小野老师终究也是成了老野老师, 声音没有 10 年前刚进 Galneryus 时候那么的有力了, 但是感觉状态似乎比最近在日的几场 live 要好 (之前看到前两个月他们在日的 live, 老野的高音感觉完全崩了……), 一场下来感觉除了上五组没以前那么轻松, 基本没什么问题, 火力全开! 值得一提是, 在某一首曲子开始前, 老野看到某位前排观众在录像, 直接把他的手机拿上台, 对着台下拍了一圈, 感觉那位老哥估计当时激动疯了 (笑). bass 手 TAKA 似乎容易被人忽略, 但是琴是真的帅, 不知道是不是耳机削高频的缘故, 感觉现场 bass 超级很猛的, 中间的一些高速段落也能分辨出其律动. 鼓手小哥 LEA <del>看起来非常年轻小鲜肉</del> 全程感觉底鼓没停过 (轰轰轰),  drum solo 打的是酣畅淋漓, 中间和小野老师的 “好吃” 二人转也是非常好笑的, 可惜笔者最后没捡到扔出去的鼓棒 (x).</p><p>encore 的曲目是 Heartless, Raise My Sword, Ultimate Sacrifice. 乐队 encore 的状态依旧不减, 迫真火力全开. 虽然最后还是没等到 Angel of Salvation 或 Destiny 这两首神曲, 但是还是非常满意的, 毕竟见到了我学琴的偶像 (是的, 学琴的一大 motivation 就是 syu, 高速而流畅的段落 <del>眼泪倒流</del>).</p><p><img src="https://s3.bmp.ovh/imgs/2024/12/25/fd0761073534a3f1.jpg" alt="从水源源友那里偷来的图. 笔者在图中前排偏左方向"></p><p>现场听曲子, 也和耳机听有不一样的感受. 开场 The Reason We Fight 直接炸飞, 全场一起和声直接力量感拉满. 中间的 Emotions 更是绚爆了, 喜闻乐见的键盘和吉他对飙 solo, syu 现场即兴的小三度推弦也别有一番韵味, 紧绷的情绪在尖叫一般的推弦中完全释放了出来, 爽! In Water’s Gaze, 结尾同样味道的推弦, 三拍子的绝美忧伤旋律, 就是那味! 令我印象最深刻的曲子是 Voice In Sadness, 虽然这种听起来比较简单重复的曲子, 感觉和近几年 G 团越来越复杂的节奏型稍微不符, 在耳机听的时候我还觉得稍微有点呆 (日本小灵云), 结果现场才发现是真的又欢乐又炸 <del>果然还是最基本的节奏型好甩起来</del>, 算是意外的收获啦! I Believe, 主打曲, 每张专辑的保留节目, 也没让我失望. 近几年这几张的主题似乎都挺忧伤的, 15 年的 The Force of Courage 给人的是十足力量感 <del>团结就是力量</del>, 即使梦想破灭也要坚持, 17 年的 Ultimate Sacrifice 则是忧伤为主, 拼尽全力追求无法实现的梦想的绝望与坚持, 而今年 (2024) 这张感觉像是两张 mix 在一起, 无尽的宿命感…… <del>力量金属是这样的, 主题高度相似, 不过不得不说笔者就是很吃这一套</del></p><p>笔者最早听 Galneryus 也是从最热门的几首, Angel of Salvation, Raise My Sword, Destiny 听起的. 笔者感觉他们的曲子最有意思 (或者说最吸引笔者) 的一点是曲子中的那份凄凉和宿命感, 以及同命运抗争的力量, 最有意境的当属 17 年的 Ultimate Sacrifice. 这份凄凉不止体现在词, 还有小野老师的那份高昂的唱腔一份功劳, 以及 syu 的凄美 guitar solo, yuhki 的键盘营造的飘渺的、天国般的氛围感, 以及由 bass 和 drum 构建的严实、密不透风的低频音墙. 正如这张专辑封面所描绘的, 骑士们在悬崖末路, 向着宿命举起了他的利剑. 那份明知不可为而为之的勇气, 理想无法达成的绝望, 是笔者认为他们作品最能牵动笔者心弦的一点. (稍微有点中二了 hh)</p><p><img src="https://www.metal-archives.com/images/6/6/6/8/666820.jpg?4326" alt="Ultimate Sacrifice, 图片来自 metal archive"></p><h2 id="老的前言"><a href="#老的前言" class="headerlink" title="老的前言"></a>老的前言</h2><blockquote><p>注: 本部分的时间背景是在 2024/11/04</p></blockquote><p>好久没更新了, 放一点最近的一些游玩经历.</p><p>笔者本人属于半个宅, 平时出去频率不是特别高, 再加上学校的事情也不少, 基本没怎么出去玩, 不过生活中还是有不少 doki doki 的时刻的.</p><p>图片晚点再补. 写的比较乱. 写不动长文了.</p><h2 id="换弦"><a href="#换弦" class="headerlink" title="换弦"></a>换弦</h2><blockquote><p>注: 本部分的时间背景是在 2024/11/04</p></blockquote><p>前情提要: 笔者由于事情比较多, 弹琴频率其实不是非常的高. 不过, 每次回家还是会摸起来练一练基本功啥的.</p><p>之前本来想着买一套防锈的弦, 这样一来可以减少换弦的频率, 虽然最后还是选择 ernie ball 家的弦. 他们家的弦似乎不是那么的防锈 (也可能是我的无情硫酸手导致的 x), 大概在用了一个月后 2 弦就有稍有发黑. 音色方面, 笔者虽然不是 5 年琴龄的老 guitarist, 但是依然能一耳朵听出来与之前廉价的 Alice 琴弦的区别, 个人感觉低音弦低把位 (7 品之前) 会稍微有一点钢筋味, 然后高把位的高音会更加有特色 (加上失真后, 是一种呜呜呜的音色, 没有之前那么刺耳), 总之很戳我.</p><p>虽然但是, 当时由于年轻, 暂时还不清楚如何上弦, 发生了不少意外. 首先, 由于我当时年幼无知, 不知道要预留多少弦, 导致有些弦的余量甚至不足以绕弦栓一圈. 幸运的是, 我的弦有自锁旋钮, 于是我就把自锁拧的特别紧, 来避免弦松动 (常规操作时多绕弦栓几圈).</p><p>然而, 这个操作埋下了一个伏笔. 在拉紧一弦的时候, 它断了, 就断在自锁弦钮的位置, 疑似是自锁弦钮压得太紧, 弦的张力又过大导致的. 虽然没有对我造成人身伤害, 但是给我幼小的心灵带来了巨大的心理阴影 (x). 最后还是拿官方送的备用弦 (不得不说, 很贴心), 小心翼翼地重上了一遍一弦. 这次我讨巧了一点, 所有弦先 drop 了半音 (E A D G B E -&gt; D# G# C# F# A# D#), 即先调整到 Standard D#, 然后再集体往上调了一个半音, 调回正常的 Standard E.</p><p>这大概就是笔者上一次换弦的经历, 至今大概过了半年多了.</p><p>在国庆回家的时候, 笔者不幸的发现, 二三弦已经锈的不成人样了, 因此笔者打算趁双 11 的机会买一套新的弦.</p><p><img src="https://s3.bmp.ovh/imgs/2024/12/25/6b5b6aef57ba1ff8.jpg" alt="锈烂咯"></p><p>这次稍微思考了一下, 选择了达达里奥的不锈钢镀镍的琴弦, 主要是期望它能用的更久. 旧换新, 总是一件令人开心的事情.</p><p>吸取了上次上弦的惨痛教训, 这次笔者给每条弦预留了大概一个品左右的余量 (目测 3cm 多一点?). 参考了若干 bilibili 上的视频, 笔者在每条弦绷直的过程中, 在琴头用力下压琴弦, 使得弦上保证有一定的张力, 从而避免了琴弦绕弦柱绕的不够紧的问题 (虽然但是, best practice 应该是用卷弦器).</p><p>有了上次断弦的经历, 这次笔者一开始就没有把弦拉的特别紧, 只要一条弦能绷直就直接上下一条. 最后调完的时候, 大致调弦大致是 Standard C# 左右, 主要还是上一次断弦的经历过于吓人了, 心理阴影太大了…… 在休息片刻后, 笔者再逐个地把每条弦调整到了正常的 Standard E 调弦的音高. 虽然看很多指导视频有说, 要对称的上弦, 而且要边上边调制之前已经上好的弦, 不然张力不平衡容易断, 但似乎笔者并没有遇到类似的问题 (笔者的思考大致是这样的: 张力越大, 琴体越弯, 会使有效弦长变短, 进而降低张力. 这是一个负反馈过程, 每上完一条弦, 只会让之前的弦张力变小, 所以不按顺序/不随时调整应该不会带来灾难性后果).</p><p>上完了后小玩了一会儿, 不得不说达达里奥的这套新弦的音色确实戳我. 低音弦钢筋味 (嘎吱嘎吱, 当然更有可能是打品的声音) 非常足, 由于时间匆忙没上失真测试, 所以高音弦尚不知道情况. 不过感觉高音弦没有上次的 EB 的新弦那么滑, 上次上完 EB 的新弦后, 感觉自己是滑弦大师 (bushi). 在手感上, 新弦也会更舒服一点, 记得当时 EB 的新弦弹久了以后, 会感觉手上有点扎 (?), 但这一套弦完全没有这样的感觉 (这一点暂时存疑, 可能是当时技术太差了不适应琴弦导致的).</p><p><img src="https://s3.bmp.ovh/imgs/2024/12/25/ed5f8d7b87bd924d.jpg" alt="剪之前"></p><p>最终把多余的琴弦剪掉后, 琴头看起来还是很整齐的, 也是非常的赏心悦目. 最有成就感的一集 <del>(我写代码怎么就没这么有成就感呢)</del></p><p><img src="https://s3.bmp.ovh/imgs/2024/12/25/0325e58b579f07c5.jpg" alt="剪之后"></p><blockquote><p>注: 笔者不是打广告 (也没这实力), 以上纯属个人经历, 仅供参考</p></blockquote><h2 id="团日"><a href="#团日" class="headerlink" title="团日"></a>团日</h2><blockquote><p>注: 本部分的时间背景是在 2024/11/04</p></blockquote><p>在上完弦以后的一天, 就感冒了. 大概率是淋雨. 一天基本没做什么事情, 大概看了一眼 DiT (Diffusion Transformer) 和稍微写了点代码, 睡得很早, 因为第二天要团日, 参观天文馆.</p><p>笔者先前还是非常期待团日的呢, 毕竟这可能是最后一次和同学们一起出游的机会了, 在这之后大家还能再一起玩几次呢…… 离别的时间感觉已经近在咫尺.</p><p>团日是在周日, 早上 7 点半左右起来, 睡前看了眼地图, 说到滴水湖需要大约 2 个小时, 遂在 8 点出发. 天气和预报的一样, 寒冷刺骨 (也可能是穿两件太少). 周末, 地铁上人确实少. 乘坐 7 号线到龙阳路, 然后换乘 16 号线. 虽然笔者是上海人, 早就听闻 16 号线, 但是一直没有动机去坐一次, 这次总算是找到一个理由. 16 号线和普通的地铁线路还稍有不同, 座位的排布更像是火车, 基本上是横着的 (即乘客面向的方向与列车前进的方向相同或相反, 而不是垂直的), 在靠近车厢连接处的座位倒是和普通地铁一样的排布 (参考: 地铁 6 号线).</p><p>16 号线基本上都是在地上的轻轨, 偶尔有两三站是在地下, 所以大部分时间我都在盯着窗外看风景. 城市景致笔者自然是没什么兴趣的, 个人觉得在一片平坦的区域里, 耸立的大楼会显得很突兀, 很丑. 城市也就集群可能看起来有一种现代美, 而在偏郊区甚至农村的地方, 高楼就像是一把利刃无情地刺穿了大地的皮肤. 上海还是太拥挤了, 房价也太高了…… 一路上, 见到不少看起来像是高中甚至初中生的小朋友, 年纪轻轻就要拖着巨大行李箱, 笔者猜测可能是周一到周五(六)在市区上学, 然后周天回家休息一天……</p><p>实际上, 地铁的速度还是非常快的, 实际上大概只花了 1.5 个小时就到了滴水湖(全程有 1 小时左右在 16 号线上). 不得不吐槽一句, 滴水湖的地铁站是真的破…… 4 号出口给人一种废弃的荒地的感觉. 在我的记忆里, 2 号线靠近浦东机场的几站 (比如凌空路) 同样如此, 有时候城市呆久了, 很难想象在不远处就是如此不现代, 但又是如此的现实……</p><p>由于早到了半小时, 所以现在周围简单逛了一圈. 空气非常的清新, 虽然大概率是心理作用, 出去走一走总是好的. 附近基本和我印象中的小城镇差不多, 基本上都是一些底层平房, 没有特别多的高楼, 同样麻雀虽小五脏俱全, 该有的设施应有尽有.</p><p>简单参观了一圈外围后, 同学们也到了, 排队进馆内参观. 一进入天文馆, 过去作为自然科学人的 DNA 立刻被激活了. 有一瞬间确实稍有触动, 大学选择了一个与自然科学无关的学科, 但是心中对于它的热爱从未消失 (<del>和我学一辈子物理吧 😭</del>). 上次大量的接触天文知识可能也是很小的时候, 那时候每天最喜欢的做事情就是看各种科普杂志 (<del>可能也有一堆伪科学</del>), 了解身边世界和宇宙的奥秘. 可惜这份热爱最终还是没能支撑的最后, 甚是遗憾.</p><blockquote><p>突然联想到之前在准备学子讲坛的时候, 看到的一些关于 ZUN (东方 Project 的作者) 关于科学世纪的看法. 或许过于关注科学, 甚至把科学作为生活的唯一准则, 会抑制我们的幻想. 曾经作为一个极端的理科人, 确实很难体会到 ZUN 的秘封作里面想要传达的意思. 可能还是在稍微冷静 (?) 一点之后, 才能意识到其中的深意吧 (<del>ZUN: 我就喝多了乱写的</del> <del>ZUN 就一个酒鬼, 他懂啥东方</del>).</p></blockquote><p>总的来说, 天文馆如同我老板评价的一样, 稍微有一点降智, 不过其中关于天体的小知识还是有很意思的, 无论是 10 岁的 DarkSharpness, 还是 20 岁的, 一样都会沉醉其中. 接下来的环节就是和同学到处逛, 到处骑车 (爽), 然后看风景. 虽然一开始定下的绕湖骑行一圈的目标未能达成, 但是还是如愿摸到了滴水湖的水, 水温刚刚好. 非常美的景色, 可惜不太会拍照, 不过最美的景色已经刻在了回忆里面了.</p><p>虽然但是, 感觉很多时候和同学在一起不会有特别强的, 归属感或者连接感, 哪怕是最亲近的几位, 虽然同样是在一起玩, 但是却没有了往日的那种欢乐. 在线下, 在我冷静的时候, 可能还是需要和其他人保持一个中等距离 (虽然大部分时候我都挺癫的), 也不知道什么时候开始我也变得有点自闭了 (x).</p><p>返程路上, 无聊把最近听一张专辑再从头刷了一遍. 由于学 (mo) 业 (yu) 繁 (tai) 忙 (duo), 已经很久没有放空大脑, 专注地去听一张专辑了, 重听也确实找到了不少有意思的点. 不得不说 G 团 (Galneryus) 风格已经基本上定型, 新专一听就是那味道, syu 的花样感觉玩的也差不多了 (当然, 也可能是最近一年听的太多了). 小野老师终究还是变成了老野 (毕竟一个 57 岁的人了). 键盘 solo 也没啥亮眼的表现了, 只能说没有全程熄火就已经很满意了.</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><del>笔者度过了幸福的一生</del></p>]]></content>
    
    
    <summary type="html">好久没更新了</summary>
    
    
    
    <category term="随笔" scheme="http://darksharpness.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="总结" scheme="http://darksharpness.github.io/categories/%E9%9A%8F%E7%AC%94/%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="随笔" scheme="http://darksharpness.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>我讨厌配环境</title>
    <link href="http://darksharpness.github.io/env/"/>
    <id>http://darksharpness.github.io/env/</id>
    <published>2024-07-25T12:51:42.000Z</published>
    <updated>2024-07-27T13:50:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>你说得对, 但是又到了经典的配环境时刻. 每次配环境都是一个令人头疼的过程, 在没有配好环境写不了代码的时候, 内心总是感到非常焦急, 只能干楞着却做不了事情. 参考了 Conless 的配环境 <a href="https://conless.dev/blog/2024/server-cheatsheet/">cheat sheet</a>, 笔者决定也记录一下万恶的配环境之路.</p><p>以下的所有环境配置默认是在 Linux 进行.</p><h2 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h2><p>在第一次连上远程服务器的时候, 需要配置 shell, 否则连 vscode 都直接通过 ssh 连上去.</p><p>我拿到的服务器集群默认 shell 是 zsh, 笔者由于之前没有使用过 zsh, 因此完全按照的是 <a href="https://www.wankupi.top">Wankupi</a> 同学的建议配置的, 简单来说就是 zsh + oh-my-zsh. 过程几乎完全参考 <a href="https://ohmyz.sh/">https://ohmyz.sh/</a>, 只需要一条指令即可:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot;</span><br></pre></td></tr></table></figure><p>笔者不太熟悉 zsh, 如果想要为 zsh 添加更多更强的插件, 请参考前面 Conless 的 <a href="https://conless.dev/blog/2024/server-cheatsheet/">blog</a></p><p>在配置好最简单的 shell 环境以后, 就可以通过 VSCode remote-SSH 连接到主机, 快乐的 coding &amp; exploring 了!</p><h3 id="一些笔者新学会的小知识"><a href="#一些笔者新学会的小知识" class="headerlink" title="一些笔者新学会的小知识"></a>一些笔者新学会的小知识</h3><blockquote><p>小贴士: 可以试着 <code>chmod 700 .</code>, 保护你的文件, 阻止别人看到你的文件!</p></blockquote><p>我们的集群中, 新开的用户的目录默认权限是 755. 这是很危险的, 因为 5 = 4 | 1, 表示其他人可以读/执行你的文件. chmod 的每一位可以是 0 ~ 7 中的任何一个数, 其中 bit 0 (1) 表示执行权限, bit 1 (2) 表示写权限, bit 2 (4) 表示读权限. 你可以通过 <code>stat .</code> 查看当前目录的权限.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第一行含有 Access: (0755...</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">其中 0755 是当前的权限</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">当然, Linux only</span></span><br><span class="line">stat . | grep Access</span><br></pre></td></tr></table></figure><p>一般有四个数字 (从高到低的第一个貌似经常省略 (?)), 有如下含义:</p><ol><li>第一个数字: 笔者不知道, 貌似不常用.</li><li>第二个数字: 表示文件所有者的权限.</li><li>第三个数字: 表示文件所属组的权限.</li><li>第四个数字: 表示其他用户的权限.</li></ol><p><del>不过貌似集群会定期重置为 0755, 貌似没啥用</del></p><h2 id="miniconda"><a href="#miniconda" class="headerlink" title="miniconda"></a>miniconda</h2><p>笔者需要配 python 环境, 自然是逃不了配 conda. 笔者选择的是 miniconda. 这个东西的安装也是非常的简单, 没有什么技术难度, 直接按照 <a href="https://docs.anaconda.com/miniconda/">miniconda 官网</a>的教程来就行了.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p ~/miniconda3</span><br><span class="line">wget https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh -O ~/miniconda3/miniconda.sh</span><br><span class="line">bash ~/miniconda3/miniconda.sh -b -u -p ~/miniconda3</span><br><span class="line">rm -rf ~/miniconda3/miniconda.sh</span><br></pre></td></tr></table></figure><p>最后, 别忘记了给自己的 shell 注入一下 conda 的初始化 setup :).</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">bash version</span></span><br><span class="line">~/miniconda3/bin/conda init bash</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">zsh version</span></span><br><span class="line">~/miniconda3/bin/conda init zsh</span><br></pre></td></tr></table></figure><p>在这以后, 就可以正常的 conda 初始化了~</p><h2 id="cuda"><a href="#cuda" class="headerlink" title="cuda"></a>cuda</h2><p>幸运的是, 集群是有必要的 cuda 环境的, 这免去了我二次坐牢的体验. 为什么是二次呢, 因为在这之前几天, 我刚刚在本机上配了 cuda 的环境, 简直是一个坐牢. 这里简单讲一讲我在本机 Windows + WSL2 环境下是如何配置 cuda 环境的.</p><p><del>首先, 你必须要有nvidia 显卡和驱动</del> 一般来讲, 一台有 nvidia 的显卡, 安装了驱动后, 可以在命令行输入 nvidia-smi 查看驱动信息. 笔者笔记本上的 cuda 驱动信息大致如下所示:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">+---------------------------------------------------------------------------------------+</span><br><span class="line">| NVIDIA-SMI 546.80                 Driver Version: 546.80       CUDA Version: 12.3     |</span><br><span class="line">|-----------------------------------------+----------------------+----------------------+</span><br><span class="line">| GPU  Name                     TCC/WDDM  | Bus-Id        Disp.A | Volatile Uncorr. ECC |</span><br><span class="line">| Fan  Temp   Perf          Pwr:Usage/Cap |         Memory-Usage | GPU-Util  Compute M. |</span><br><span class="line">|                                         |                      |               MIG M. |</span><br><span class="line">|=========================================+======================+======================|</span><br><span class="line">|   0  NVIDIA GeForce RTX 3050 ...  WDDM  | 00000000:01:00.0  On |                  N/A |</span><br><span class="line">| N/A   47C    P5               8W /  60W |   1796MiB /  4096MiB |     15%      Default |</span><br><span class="line">|                                         |                      |                  N/A |</span><br><span class="line">+-----------------------------------------+----------------------+----------------------+</span><br><span class="line"></span><br><span class="line">+---------------------------------------------------------------------------------------+</span><br><span class="line">| Processes:                                                                            |</span><br><span class="line">|  GPU   GI   CI        PID   Type   Process name                            GPU Memory |</span><br><span class="line">|        ID   ID                                                             Usage      |</span><br><span class="line">|=======================================================================================|</span><br><span class="line">|    0   N/A  N/A      2148    C+G   ...e\VSCode\Microsoft VS Code\Code.exe    N/A      |</span><br><span class="line">+---------------------------------------------------------------------------------------+</span><br></pre></td></tr></table></figure><p>非常的低配, 但是勉强够用了(真生产力还是得靠集群).</p><p>在此之后, 需要安装对应版本的 cuda toolkit. 比如, 笔者在 WSL2 安装的就是 cuda 12.3 toolkit. 安装方法也是非常的简单, 直接在浏览器搜索: cuda toolkit 12.3, 然后跟着教程来. 例如 <a href="https://developer.nvidia.com/cuda-12-3-0-download-archive?target_os=Linux">cuda toolkit 12.3</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">WSL-Ubuntu 的安装方法, 具体请参考本机配置及官网</span></span><br><span class="line">wget https://developer.download.nvidia.com/compute/cuda/repos/wsl-ubuntu/x86_64/cuda-keyring_1.1-1_all.deb</span><br><span class="line">sudo dpkg -i cuda-keyring_1.1-1_all.deb</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get -y install cuda-toolkit-12-3</span><br></pre></td></tr></table></figure><p>在此之前, 笔者曾试图安装和驱动 cuda version 不一致的 cuda toolkit 12.5, 结果在编译的时候喜提链接错误以及头文件缺失, 所以保险起见还是暂时先安装同版本的 toolkit.</p><p>特别注意的是, 对于部分较老的 cuda toolkit, 其不一定支持新版本的 gcc, 这意味着你可能需要把你的 gcc 降级. 笔者用 gcc-13 + nvcc 12.3 编译会提示不支持, 如果强行忽略会出现链接错误, 降低版本到 gcc-12 后解决.</p><p>笔者本地管理版本用的是 update-alternatives, 可以方便的在不同版本的 gcc 中切换 (即, 使得默认的 gcc —version 得到不同的结果,).</p><p>在此, 笔者特别感谢 <a href="https://conless.dev/">Conless Pan</a> 同学在这过程中给予的帮助!</p><h2 id="git-ssh-gpg"><a href="#git-ssh-gpg" class="headerlink" title="git + ssh + gpg"></a>git + ssh + gpg</h2><p>配完 conda, 笔者第一件做的事情就是 <code>git clone</code> 仓库, 然后发现本地并没有 ssh-key :(.</p><p>配置 ssh-key 也不难, 只需要按照 github 的官方指令来就行了, <a href="https://docs.github.com/zh/authentication/connecting-to-github-with-ssh">链接在此</a>, 重点是生成新的 ssh-key 以及添加到 github.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">请把下面字符串中的邮箱替换成你自己的 :(</span></span><br><span class="line">ssh-keygen -t rsa -b 4096 -C &quot;2040703891@qq.com&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">把打出来的东西直接加到 github 的 ssh-key 里面即可</span></span><br><span class="line">cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure><p>当系统提示 “Enter a file in which to save the key” 时，按 Enter 键接受默认文件位置, 简而言之就是一路默认.</p><p>当然, 之前在本机 WSL 环境下配置了 gpg, <del>github 签名 verified 是真的好看</del>, 所以我们也需要在新的设备上配置 gpg. 这一步也不难, 同样是按照 github 的官方教程来, <a href="https://docs.github.com/zh/authentication/managing-commit-signature-verification/generating-a-new-gpg-key">链接在此</a>.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gpg --full-generate-key</span><br><span class="line">gpg --list-secret-keys --keyid-format=long</span><br></pre></td></tr></table></figure><p>执行指令的时候会有一些操作, 反正一切跟随默认原则即可. 在执行完以下两条指令后, 应该会看到类似的输出:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">------------------------------------</span><br><span class="line">sec   4096R/3AA5C34371567BD2 2016-03-10 [expires: 2017-03-10]</span><br><span class="line">uid                          Hubot &lt;hubot@example.com&gt;</span><br><span class="line">ssb   4096R/4BB6D45482678BE3 2016-03-10</span><br></pre></td></tr></table></figure><p>这时, 根据想要的 key 生成密钥, 例如上述例子 (来自前面那个官方例子), 如果选择第一个, 那就是:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpg --armor --export 3AA5C34371567BD2</span><br></pre></td></tr></table></figure><p>此时, 复制以 ——-BEGIN PGP PUBLIC KEY BLOCK——- 开头并以 ——-END PGP PUBLIC KEY BLOCK——- 结尾的 GPG 密钥. 将 GPG 密钥新增到 GitHub 帐户, 即可.</p><p>当然, github 的教程是到此为止了, 但是本地的配置其实还不够. 为了让我们在 git commit 时自动跳出窗口, 并且强制输入密码采用 gpg 签名, 我们还需要一些额外的设置.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">强制每次 commit 都要 gpg 签名</span></span><br><span class="line">git config --global commit.gpgsign true</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改 ~/.zshrc 或者 ~/.bashrc</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这是为了让 gpg 在 git commit 的时候弹出窗口</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">否则会报错, 只能通过命令行签名.</span></span><br><span class="line">export GPG_TTY=$(tty)</span><br></pre></td></tr></table></figure><h2 id="Small-summary"><a href="#Small-summary" class="headerlink" title="Small summary"></a>Small summary</h2><p>一切按照官方教程, 基本不会出错. 遇事不决请选择 default. 前人的试错经验是非常珍贵的, 再次感谢 Conless, Wankupi 等同学给予的莫大的帮助!</p>]]></content>
    
    
    <summary type="html">配环境, 然后破防.</summary>
    
    
    
    <category term="计算机" scheme="http://darksharpness.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    <category term="工具" scheme="http://darksharpness.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="基础知识" scheme="http://darksharpness.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>(Modern) C++ 小技巧汇总</title>
    <link href="http://darksharpness.github.io/cpp/"/>
    <id>http://darksharpness.github.io/cpp/</id>
    <published>2024-06-09T15:01:00.000Z</published>
    <updated>2025-03-18T16:41:16.896Z</updated>
    
    <content type="html"><![CDATA[<p>众所周知, 笔者 (DarkSharpness) 是一个 Modern C++ 的狂热爱好者. 笔者自高中信息竞赛以来, 主力编程语言一直都是 C++, 在大学的学习过程中, 积累了不少的实践经验, 故开一个帖子计划长期维护. 每次更新会在头部显示.</p><h2 id="coroutine"><a href="#coroutine" class="headerlink" title="coroutine"></a>coroutine</h2><p>最近 (2025/03/14) 笔者 python 写的非常多, 大量用到了 asyncio, 遂打算写写 C++ 的 coroutine. 其实本来去年就想 mark 一下的, 奈何事情太多了, 再加上太摆了, 拖了很久.</p><p>一句话概括, user-level 的 thread, 允许函数在执行过程中任意挂起, 或者恢复执行, 由用户来执行多个函数之间的调度. 当然和 os thread 还是有区别的, 不同实现的 coroutine 也完全不一样. 比如 coroutine 可以分为有栈和无栈. 协程的好处是, 可以在等待某些事件的时候, 主动交出控制权, 并且随后可以恢复当前的状态, 继续执行当前的函数.</p><p>由于笔者需要给部分同学讲高级编译器的东西, 所以这里简单讨论一下笔者对两者设计哲学的一些思考.</p><h3 id="stackful-coroutine"><a href="#stackful-coroutine" class="headerlink" title="stackful coroutine"></a>stackful coroutine</h3><p>有栈协程就是堆上 <code>new</code> 一块空间来取代当前的 stack pointer (简称 sp, 在 x86 上是 esp, 在 rv 上就是 sp), 在调用 coroutine 的时候把 sp 切过去. 对下面执行的函数来说, 他们几乎不需要做任何改变, 只需在交出控制权/结束执行的时候, 把 sp 切回原来的 sp 即可.</p><p>这么做有一个明显的坏处: 这个 coroutine 可能会调用递归函数, 而递归函数需要的栈可能很大, 如果一开始开的不够多, 那么存在爆栈的风险. 笔者能想出以下的解决方案:</p><ol><li>一开始开一个 1MB 以上的很大的栈空间, 尽量保证不会爆栈.</li><li>在发现栈空间不够的时候, 主动/被动扩张 (主动: codegen/runtime 插入检查; 被动: 例如在 linux 上, 捕获越界访问的 segfualt)</li></ol><p>但是这些方案都有问题. 对于开一个巨大的栈, 首先是在有海量的协程的时候, 内存的占用会非常夸张. 经常听说用协程 + 线程实现 “百万并发”, 如果百万个协程每个都有一个 1MB 的栈, 那么总共需要的栈空间需要大约 1TB, 非常不现实. 系统栈一般就一个, 开的很大也无所谓, 但协程显然是不能如此. 其次, 就是究竟多大算是够的一个问题, 这个问题也很烦, 会带来巨大的不确定性, 而笔者认为这对于一个 system design 是不好的.</p><p>还有就是动态扩张, 首先主动检查一定会引入运行时开销. 这时候, 被动触发 (类似 page fault 的机制) 一定程度上可以缓解这个 overhead. 同时, 扩张可能会带来栈空间的浪费, 可能在执行完一个递归函数之后, 栈立刻就缩小到很小的值了, 这时候还需要一定的回收机制, 给是实现上带来了不少的挑战. 再次, 扩张还有一个致命的问题: 扩张可能导致 stack 需要迁移到一块新的空间, 因为 stack top 和 stack bottom 附近的空间都已经被申请了, 当前堆段无法扩张, 只能把换一块更大的地方, 这会带来一系列问题:</p><ol><li>大量的拷贝会花费巨量的时间. 而且这个开销很难均摊, 巨大的停顿可能类似 GC stop the world.</li><li>迁移的之后, 指向原先的栈空间的指针全部都失效了. 这是最致命的问题, 尤其是没有 runtime 的语言, 你无法知道到底有哪些对象还持有这个空间的指针, 而且基于地址的比较也会失效. 笔者设想过利用 mmap 把原先的栈和新栈 map 到同一个物理页, 但这又带来了一致性问题: 两个虚拟地址对应同一个物理地址. 笔者怀疑 (但是没有证据) 这会给编译器的 memory aliasing 分析带来巨大的难题 (编译器不会管两个 va -&gt; 同一个 pa, 编译器是 oblivious to page table 的, 在判断 memory 相等的时候用的自然是程序看得到的 va).</li></ol><p>简而言之, 这些问题笔者认为静态语言无法非常优雅的解决, 这可能也是为啥 C++/Python 并没有选择有栈协程.</p><blockquote><p>Remark: 笔者也不喜欢 dirty design</p></blockquote><p>在 go 语言里面, 就是通过 go runtime 来支持了有栈协程, 的确这极大的降低了用户的心智负担, 只要 go 就可以启动一个 coroutine, 但是代价就是潜在的 runtime overhead. 在 io 等待时间 dominate 的时候, 这些 overhead 会被等待 io 的时间 overlap 住. 但是一旦并发量起来之后, 潜在的 cost 就不一定藏得住了.</p><h3 id="stackless-coroutine"><a href="#stackless-coroutine" class="headerlink" title="stackless coroutine"></a>stackless coroutine</h3><p>无栈协程, 就是开一块临时空间 frame, 在交出控制权的时候, 把要恢复的时候还会用到的局部变量, 本来要 spill 到 stack 上的, 现在 spill 到 frame 上. 你可能会说: 这和有栈协程有什么区别, 不是还要 spill 吗? 这个 frame 不就是 stack 吗? 你先别急, 我们还是考虑下面这个最简单的递归函数的例子.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">recursive</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">recursive</span>(x - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">f</span><span class="params">(<span class="type">int</span> x)</span> -&gt; coroutine </span>&#123;</span><br><span class="line">    <span class="type">int</span> y = x * <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">co_return</span> <span class="title">recursive</span><span class="params">(y)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在有栈的例子中, 后面的 recursive 依然是用你新开的 stack. 但在 stackless version 中, 只有局部变量 <code>y</code> 和入参 <code>x</code> 是存在新开的 frame 上, 这时候请注意, 你的 stack pointer 依然是原来的 stack. 因此, 在调用 <code>recursive</code> 的时候, 用到的还是原来的 stack. 注意到区别没有. 在 stackless 的版本, 你只需要把当前函数的局部变量 spill 到 frame (或者说, 新开的空间) 上, 而调用的子函数不会有任何影响.</p><p>这么做自然绕开了 stackful 遇到的几个重大难题, 那么代价呢? 代价就是几乎不能在多层嵌套中随便的交出控制权. 比如还是这个例子, 如果你希望在 <code>recursive</code> 调用到最后一层的时候, 先交出一次控制权, 这对于 stackful 非常简单, 保存一下当前的寄存器状态, 然后切换回老的 sp 就行了. 递归的状态都已经自动保存在了新开的 stack 里面. 然而无栈做不到, 无论是 stackless 还是 stackful, 在交还给调用方的时候, 要保证 sp 恢复到原来的位置, 而无栈复用的是原来的 sp, 所以如果想要从递归深层中退出, 就必须每层开一个 frame, 在退出前先保存到自己的 frame 上. 这个就显得非常麻烦了.</p><h3 id="symmetric-or-asymmetric"><a href="#symmetric-or-asymmetric" class="headerlink" title="symmetric or asymmetric"></a>symmetric or asymmetric</h3><p>笔者最近才知道原来还有对称/非对称协程.</p><p>对称的协程, 简单来说就是任何任何一个协程都是平等的, 调度权可以在任意协程之间转移. 而非对称协程则是, 协程只能把调度权交给它的调用者, 从调用者/被调用者这一个角度来看, 其更像是一个一般的函数调用.</p><h3 id="C-detail"><a href="#C-detail" class="headerlink" title="C++ detail"></a>C++ detail</h3><p>具体还是参考 <a href="https://en.cppreference.com/w/cpp/language/coroutines">cppreference</a>, 感觉写的还是能看. 细节很多.</p><p>首先, 最重要的是搞明白 coroutine 对象的生命周期. 合法 coroutine 的对象首先需要一个 promise_type 类, 用来存储 coroutine 产生的结果 (yield, return). 事实上, coroutine 并不会被直接构造, 而是先拿到编译器生成的 <code>std::coroutine_handle</code> (其实就是一个存了 frame pointer 的值), 然后通过 promise 的 <code>get_return_object</code> 成员函数来返回一个 coroutine, 实际构造的过程发生在这个成员函数内. 只有在拿到了 handle 的情况下, 调用者才能通过 <code>resume</code> 恢复 coroutine 的执行. 具体流程如下 (完全参考 cppreference):</p><ol><li>allocates the coroutine state object using <code>operator new</code>.</li><li>copies all function parameters to the coroutine state: by-value parameters are moved or copied, by-reference parameters remain references (thus, may become dangling, if the coroutine is resumed after the lifetime of referred object ends).</li><li>calls the constructor for the promise object. If the promise type has a constructor that takes all coroutine parameters, that constructor is called, with post-copy coroutine arguments. Otherwise the default constructor is called.</li><li>calls <code>promise.get_return_object()</code> and keeps the result in a local variable. The result of that call will be returned to the caller when the coroutine first suspends. Any exceptions thrown up to and including this step propagate back to the caller, not placed in the promise.</li><li>calls <code>promise.initial_suspend()</code> and co_awaits its result. Typical Promise types may return a <code>std::suspend_always</code>, for lazily-started coroutines, or <code>std::suspend_never</code>, for eagerly-started coroutines.</li><li>when <code>co_await promise.initial_suspend()</code> resumes, starts executing the body of the coroutine.</li></ol><p>主体逻辑就是, 构造一个 frame (即 handle), 构造一个 promise, 把 handle 传给 promise 用来构造一个新的 coroutine 变量, 再这个变量返回给调用方. 需要注意的是类成员返回一个 coroutine (包括 lambda), 这部分可以参考 cppreference 的例子.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;coroutine&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">promise</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">coroutine</span> : std::coroutine_handle&lt;promise&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> promise_type = ::promise;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">promise</span> &#123;</span><br><span class="line">    <span class="function">coroutine <span class="title">get_return_object</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;coroutine::<span class="built_in">from_promise</span>(*<span class="keyword">this</span>)&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">std::suspend_always <span class="title">initial_suspend</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">f</span><span class="params">()</span> -&gt; coroutine </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello\n&quot;</span>;</span><br><span class="line">    <span class="keyword">co_return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">main</span><span class="params">()</span> -&gt; <span class="type">int</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> coro = <span class="built_in">f</span>(); <span class="comment">// a coroutine object.</span></span><br><span class="line">                     <span class="comment">// since the initial suspend is `always`</span></span><br><span class="line">                     <span class="comment">// &quot;Hello&quot; will not be printed here</span></span><br><span class="line">                     <span class="comment">// if `never`, then when we reach here,</span></span><br><span class="line">                     <span class="comment">// &quot;Hello&quot; has been printed.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然, 除了有 initial 时候的设置, 自然还有生命周期结束时候的设置. 当通过 handle 的 <code>resume</code> 到了 coroutine 内部, 并且执行到 <code>co_return</code> 的时候, 首先会通过 promise 的 <code>return_value</code> 或者 <code>return_void</code> 成员函数来存储结果, 并且根据 promise 的 <code>final_suspend</code> 成员函数来决定是否要挂起. 但是结束之后的挂起显然是不能再恢复的, 这里的语义发生了一些细微的改变, 表示是否析构掉 promise object, 即调用 handle 的 <code>destroy</code> 成员函数.</p><ol><li>calls <code>promise.return_void()</code> for <code>co_return; co_return expr;</code> where expr has type void, or calls <code>promise.return_value(expr)</code> for <code>co_return expr</code>; where expr has non-void type</li><li>destroys all variables with automatic storage duration in reverse order they were created.</li><li>calls <code>promise.final_suspend()</code> and co_awaits the result.</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;coroutine&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">promise</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">coroutine</span> : std::coroutine_handle&lt;promise&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> promise_type = ::promise;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">promise</span> &#123;</span><br><span class="line">    <span class="function">coroutine <span class="title">get_return_object</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;coroutine::<span class="built_in">from_promise</span>(*<span class="keyword">this</span>)&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">std::suspend_always <span class="title">initial_suspend</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line">    <span class="function">std::suspend_always <span class="title">final_suspend</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">return_void</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">unhandled_exception</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">f</span><span class="params">()</span> -&gt; coroutine </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello\n&quot;</span>;</span><br><span class="line">    <span class="keyword">co_return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">main</span><span class="params">()</span> -&gt; <span class="type">int</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> coro = <span class="built_in">f</span>(); <span class="comment">// a coroutine object.</span></span><br><span class="line">                     <span class="comment">// since the initial suspend is `always`</span></span><br><span class="line">                     <span class="comment">// &quot;Hello&quot; will not be printed here</span></span><br><span class="line">                     <span class="comment">// if `never`, then when we reach here,</span></span><br><span class="line">                     <span class="comment">// &quot;Hello&quot; has been printed.</span></span><br><span class="line"></span><br><span class="line">    f.<span class="built_in">resume</span>(); <span class="comment">// print &quot;Hello&quot; and reach the end</span></span><br><span class="line">                <span class="comment">// since we choose `suspend_always`</span></span><br><span class="line">                <span class="comment">// the promise object is not destructed</span></span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                <span class="comment">// note that the resume member function is inherited</span></span><br><span class="line">                <span class="comment">// from `std::coroutine_handle&lt;promise&gt;`</span></span><br><span class="line"></span><br><span class="line">    f.<span class="built_in">destroy</span>(); <span class="comment">// since we suspended finally, we need to manually destory</span></span><br><span class="line">                 <span class="comment">// if `suspend_never`, then we can&#x27;t call this function</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>未完待续…</p><!-- 再介绍复杂的 `await` 机制之前, 先讲一讲简单的 --><h2 id="small-size-optimization"><a href="#small-size-optimization" class="headerlink" title="small size optimization"></a>small size optimization</h2><p>C++ 人最喜欢的一点就是优化性能. 既然要优化性能, 少不了的一点就是数据的局部化. 众所周知, 指针间接访问是一件不太好的事情, 一般来说连续的内存访问显然要好于不连续的, 这是体系结构告诉我们的.</p><p>那么, 基于 <code>locality</code>, 我们能做哪些优化呢? 最 naive 的想法就是: 直接把数据存在自己的结构体里面. 这样面临着一个问题: 如果数据的大小是未知的, 比如 <code>std::string</code> 长度是可变的, 那你不可能开一个无穷大的结构体. 但是没关系, small size optimization 的核心就在于, 对于大小比较小, 能在结构体内放得下的, 就尽量放在里面.</p><p>在笔者的 <code>gcc 13.2</code> 中, <code>std::string</code> 的实现就采用了 SSO 的优化, 即对于长度不超过 15 的字符串, 开在自己内部的一个 buffer 里面.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a sample code </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">string</span> &#123;</span><br><span class="line">    <span class="type">char</span> *ptr;</span><br><span class="line">    std::<span class="type">size_t</span> length;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="type">char</span> buffer[<span class="number">16</span>];</span><br><span class="line">        std::<span class="type">size_t</span> capacity;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><del>这就是全部</del> 这当然不是全部. <code>std::any</code> 也采用了类似的优化, 对于不超过 8 byte 的小对象, 就放在自己的结构体内部. 不仅如此, 在工程实践中, SSO 也被广泛运用. 在 llvm 中, 有一个模板类 <code>small_vector</code>, 顾名思义就是一个针对一般大小比较小的 <code>vector</code> 进行了优化. 比如 <code>llvm::small_vector&lt;int, 8&gt;</code> 即表示一个最多可以在内部存储 8 个 int 的小 vector, 如果通过 profiling 发现程序中确实基本上 <code>vector</code> 大小不会超过 8, 那么就可以享受几乎和数组一样的性能 (局部存储, 连续访问). 在 <code>PyTorch 2.5.0</code> 源码中, <code>IValue</code> 类型 (Interpreter Value) 也采用了类似的优化 (类似 std::any). <code>IValue</code> 作为 <code>python</code> 解释器中的动态类型, 具有很强的动态性, 但是 <code>PyTorch</code> 涉及的类型基本上只有 <code>Tensor</code> (一个指针大小), <code>int</code>, <code>float</code>, <code>device</code> 等等, 这些实际都不会超过 <code>8 byte</code>. 因此, 使用 <code>IValue</code> 来表示解释器中的某个值, 可以尽可能地避免间接引用, 并且可以减少潜在的堆内存分配.</p><p>总结一句话: 当数据不大的时候, 尽可能放结构体内的 buffer 里来增强数据局部性.</p><h2 id="bit-field"><a href="#bit-field" class="headerlink" title="bit-field"></a>bit-field</h2><p>这个其实算不上 modern C++ 的部分, 这是 C 继承下来的一个重要 feature.</p><p>在一些偏底层且空间/性能敏感的领域, 我们可能需要把多个数据压缩存储到一起. 举个例子, int4 量化的时候, 我们可能需要把 8 个 4 bit 的数(表示范围是 -8 ~ 7)压缩到一个 int 中 (4 * 8 = 32). 再比如说, 在嵌入式开发中, 某些硬件寄存器每个 bit 可能对应不同的 flag, 我们在读出这个寄存器的值的时候, 可能需要把这些 flag 读出来.</p><p>以上这些需求, 最容易想到的做法是使用位运算, 取出一个数字的特定几位. 然而, 这样的代码难以维护, 各种左右移, 以及掩码操作, 稍微复杂一点代码就会变得难以阅读, 即使设计了对应接口, 其直观性还是一般, 如下所示.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">int4_8</span> &#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取第 i 个 4 bit 数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> which&gt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">const</span> int4_8 &amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x.data &gt;&gt; (which * <span class="number">4</span>)) &amp; <span class="number">0xf</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把第 i 个 4 bit 数设置为 value</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> which&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">(int4_8 &amp;x, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">    x.data &amp;= ~(<span class="number">0xf</span> &lt;&lt; (which * <span class="number">4</span>));</span><br><span class="line">    x.data |= (value &amp; <span class="number">0xf</span>) &lt;&lt; (which * <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们希望我们能想操纵一个普通的变量那样, 操控一些 bit. 遗憾的是, 计算机中的最小寻址单元是 byte, 我们并不存在 bit 的引用. 但是, C++ 提供了一个很好的解决方案: bit-field. 我们可以使用 bit-field 来定义一个结构体, 其中的成员变量可以指定其占用的 bit 数, 如下所示.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">int4_8</span> &#123;</span><br><span class="line">    <span class="type">int</span> x0 : <span class="number">4</span>; <span class="comment">// 0 ~ 3 bit</span></span><br><span class="line">    <span class="type">int</span> x1 : <span class="number">4</span>; <span class="comment">// 4 ~ 7 bit</span></span><br><span class="line">    <span class="type">int</span> x2 : <span class="number">4</span>; <span class="comment">// 8 ~ 11 bit</span></span><br><span class="line">    <span class="type">int</span> x3 : <span class="number">4</span>; <span class="comment">// 12 ~ 15 bit</span></span><br><span class="line">    <span class="type">int</span> x4 : <span class="number">4</span>; <span class="comment">// 16 ~ 19 bit</span></span><br><span class="line">    <span class="type">int</span> x5 : <span class="number">4</span>; <span class="comment">// 20 ~ 23 bit</span></span><br><span class="line">    <span class="type">int</span> x6 : <span class="number">4</span>; <span class="comment">// 24 ~ 27 bit</span></span><br><span class="line">    <span class="type">int</span> x7 : <span class="number">4</span>; <span class="comment">// 28 ~ 31 bit</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    int4_8 x;</span><br><span class="line">    x.x0 = <span class="number">1</span>;</span><br><span class="line">    x.x1 = <span class="number">-3</span>;</span><br><span class="line">    std::cout &lt;&lt; x.x0 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; x.x1 &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这样的方式, 我们可以直接访问到一个 int 中的特定几位, 而不需要手动进行位运算. 我们可以在 <a href="https://en.cppreference.com/w/cpp/language/bit_field#:~:text=The%20type%20of%20a%EE%80%80%20bit-field%EE%80%81">cppreference</a> 上查看到更多关于 bit-field 的细节.</p><p>在笔者的实践中, 一般不会太在意 cppreference 上说到的所有细节, 但是笔者认为以下这些还是比较重要的:</p><p>首先, bit-field 的类型必须是整数类型. 这还是比较好理解的, 因为其本质就是对于整数位运算的某种语法糖.</p><p>其次, 如果希望达到节约空间的目的, 被压缩在同一个 int 中的 bit-field 之和显然不能超过 int 的 bit 数量, 超过的 bit-field 部分一般来说会被放到下一个 int 中. 自然, 这中间可能存在一些 padding, 以保证对齐.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">bit_pack</span> &#123;</span><br><span class="line">    <span class="type">int</span> x : <span class="number">16</span>;</span><br><span class="line">    <span class="type">int</span> y : <span class="number">14</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里有 2 bit 的 padding,</span></span><br><span class="line">    <span class="comment">// 因为下一个 z : 16 放不下了, 第一个 int 只剩下2 bit</span></span><br><span class="line">    <span class="comment">// 请注意, 这是一个实现定义行为, 不同的编译器可能会有不同的行为.</span></span><br><span class="line">    <span class="comment">// 一般的编译器还是会选择不要让 z 跨越两个 int</span></span><br><span class="line">    <span class="comment">// 因为如果跨越 int 存储, 会导致访问效率降低, 性能下降</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> z : <span class="number">16</span>;</span><br><span class="line">    <span class="type">int</span>   : <span class="number">15</span>; <span class="comment">// 手动添加 padding, 不需要名字</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里有 1 bit 的 padding, 因为无论如何都要对齐到 int</span></span><br><span class="line">    <span class="type">int</span> w;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当然, bit-field 也支持类型混用, 即不一定要是同一种整数类型, 但是要求整数的位宽相同, 否则会先把前面的类型 padding 到整数位宽, 然后再放入后面的类型.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">bit_pack_2</span> &#123;</span><br><span class="line">    <span class="type">int</span> x       : <span class="number">16</span>; <span class="comment">// 16 bit</span></span><br><span class="line">    <span class="type">unsigned</span> y  : <span class="number">16</span>; <span class="comment">// OK, 和 x 在同一个 int 中</span></span><br><span class="line">    <span class="type">int</span>      z  : <span class="number">8</span>;</span><br><span class="line">    <span class="comment">// 这里有 24 bit 的 padding,</span></span><br><span class="line">    <span class="comment">// 因为 uint8_t 只有 8 bit, 和 int 不一样</span></span><br><span class="line">    <span class="comment">// 因此, 前一个 int 会先被 padding 到 32 bit</span></span><br><span class="line">    <span class="comment">// 再放入 uint8_t</span></span><br><span class="line">    <span class="type">uint8_t</span> w : <span class="number">3</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>说到这里, 就不得不提 C++ 中的 <code>&lt;bit&gt;</code> 这个头文件了. 这个头文件是 C++ 20 新增的, 其提供了一些 bit 操作的函数, 如 <code>std::bit_cast</code>, <code>std::rotl</code>, <code>std::rotr</code>, <code>std::countr_zero</code>, <code>std::countr_one</code> 等等. 这些函数可以帮助我们更加方便地进行 bit 操作. 基本上, 你能想到的 bit 操作, 这个头文件都有.</p><h2 id="string-switch"><a href="#string-switch" class="headerlink" title="string switch"></a>string switch</h2><p>在 C/C++ 中, 你应该用过 <code>switch</code> 语句, 其可以高效而直观地表示多分支的逻辑. 但是, <code>switch</code> 语句只能接受整数类型的参数, 不能接受字符串类型的参数.</p><p>我们自然是无法从语言层面上改变什么, 但是我们可以基于已有的技术实现一个类似的 <code>string_switch</code>. 注意到 <code>switch</code> 里面只能接受整数或者枚举类型, 我们的思路就是把字符串转换为整数或者枚举类型. 一个非常 naive 的思路是用 <code>std::unordered_map</code> (或者 <code>std::map</code>) 来实现. 但是, 这样可能存在一些问题: 首先 <code>std::unordered_map</code> 并不支持 <code>constexpr</code> 的静态对象, 因为其涉及了动态内存分配. 而且, <code>case</code> 里面的整数也要求是 <code>constexpr</code> 的, 如何在编译器就能得到具体的哈希值, 如何解决哈希冲突, 都是需要考虑的问题.</p><p>虽然 <code>constexpr std::unordered_map</code> 看起来是不行了, 但是这个思路是没问题的. 我们最核心的思路就是把字符串转化为可以枚举的整数类. 因此, 我们可以自己手写一个 <code>hash</code> 函数, 或者调用 <code>std::hash</code> 函数, 来得到一个 <code>constexpr</code> 的整数值, 然后我们只需要存储这些整数值就行了. 如下所示:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;std::<span class="type">size_t</span> _Base = <span class="number">131</span>&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="built_in">my_hash</span>(std::string_view view) -&gt; std::<span class="type">size_t</span> &#123;</span><br><span class="line">    <span class="keyword">auto</span> hash = std::<span class="type">size_t</span>&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> c : view) hash = hash * _Base + c;</span><br><span class="line">    <span class="keyword">return</span> hash;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">example</span><span class="params">(std::string_view input)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (<span class="built_in">my_hash</span>(input)) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">case</span> <span class="title">my_hash</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span>:</span></span><br><span class="line"><span class="function">            std::cout &lt;&lt; <span class="string">&quot;hello&quot;</span> &lt;&lt; std::endl;</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="function"><span class="keyword">case</span> <span class="title">my_hash</span><span class="params">(<span class="string">&quot;world&quot;</span>)</span>:</span></span><br><span class="line"><span class="function">            std::cout &lt;&lt; <span class="string">&quot;world&quot;</span> &lt;&lt; std::endl;</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;default&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是我们的实现的原型了, 事情似乎有点太简单了. 现实中, 可能并没有这么简单. 对于任意输入的字符串, 我们可能需要考虑哈希冲突的问题. 对于要 match 的那些字符串, 如果出现了冲突, 在编译期间就会直接出错, 而我们只需要简单的把模板中的 <code>_Base</code> 替换一下就行了. 比较麻烦的是, 即使我们进入了某个 <code>case</code>, 我们也不能保证输入的字符串和要匹配的一样. 我们需要额外的判等.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">example_1</span><span class="params">(std::string_view input)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (<span class="built_in">my_hash</span>(input)) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">case</span> <span class="title">my_hash</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span>:</span></span><br><span class="line"><span class="function">            if (input =</span>= <span class="string">&quot;hello&quot;</span>) &#123;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;hello&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="function"><span class="keyword">case</span> <span class="title">my_hash</span><span class="params">(<span class="string">&quot;world&quot;</span>)</span>:</span></span><br><span class="line"><span class="function">            if (input =</span>= <span class="string">&quot;world&quot;</span>) &#123;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;world&quot;</span> &lt;&lt; std::endl;                </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;default&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样以后, 其基本就是一个完美的 <code>string switch</code> 了, 有需要的话可以自行修改 <code>my_hash</code> 函数. 但是, 我们还是要手写一遍判等, 这样非常麻烦, 而且容易出错. 这时候, 我们可以请出 C 语言的最终杀器: 宏. 以下是作者自己的实现:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">example2</span><span class="params">(std::string_view input)</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> match(str) \</span></span><br><span class="line"><span class="meta">    case my_hash(str):  <span class="keyword">if</span> (input != str) break; <span class="keyword">else</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (<span class="built_in">my_hash</span>(input)) &#123;</span><br><span class="line">        <span class="built_in">match</span>(<span class="string">&quot;hello&quot;</span>) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;hello&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">match</span>(<span class="string">&quot;world&quot;</span>) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;world&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">match</span>(<span class="string">&quot;return&quot;</span>) <span class="keyword">return</span>; <span class="comment">// Allow one-liner</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;default&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">undef</span> match</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然, 既然都用到宏了, 自然可以再结合 VA_ARGS 来实现更加通用的 <code>string switch</code>, 如果有需求可以自己定制.</p><p>简而言之, 借助 <code>constexpr hash</code> 函数, 以及宏, 我们可以实现一个类似于 <code>string switch</code> 的功能. 如果有需求, 也可以自行修改.</p><h2 id="assert-in-C"><a href="#assert-in-C" class="headerlink" title="assert in C++"></a>assert in C++</h2><p>如果你写过 C, 那你可能用过 <code>assert</code> 这个宏, 用于在运行时检查某个条件是否满足, 如果不满足, 则会终止程序, 并且详细地输出错误信息. 但是, 既然我们都用了 C++ 了, 为什么不用 C++ 的方式来实现呢?</p><p>首先, 我们先看一下 C 的 <code>assert</code> 都输出了些什么. 文件, 行号, 函数名…… 这些在 C++ 里面怎么获取呢? 如果用 <code>__LINE__</code> 这类 C 里面的宏, 那又违背了我们的初衷. 幸运的是, C++ 20 提供了 <code>std::source_location</code> 类, 可以获取到文件名, 行号, 函数名等信息. 以下是一个简单的实现:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">assert</span><span class="params">(_Tp &amp;&amp;condition,</span></span></span><br><span class="line"><span class="params"><span class="function">    std::source_location location = std::source_location::current())</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (condition) <span class="keyword">return</span>;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;Assertion failed: &quot;</span> &lt;&lt; location.<span class="built_in">file_name</span>() &lt;&lt; <span class="string">&quot;:&quot;</span></span><br><span class="line">              &lt;&lt; location.<span class="built_in">line</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; location.<span class="built_in">function_name</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然, 这样的实现可能还有一些不够完美的地方. 用户不能自定义输出信息, 光秃秃的报错信息可能不够友好. 而如果要在运行时生成输出信息字符串, 可能又会映入不小的性能开销. 因此, 我们应该支持 assert 传入多个参数来自定义输出信息. 以下是一个更加完善的实现:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span>... _Args&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">assert</span><span class="params">(_Tp &amp;&amp;condition, _Args &amp;&amp;...args,</span></span></span><br><span class="line"><span class="params"><span class="function">    std::source_location location = std::source_location::current())</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (condition) <span class="keyword">return</span>;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;Assertion failed: &quot;</span> &lt;&lt; location.<span class="built_in">file_name</span>() &lt;&lt; <span class="string">&quot;:&quot;</span></span><br><span class="line">              &lt;&lt; location.<span class="built_in">line</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; location.<span class="built_in">function_name</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(<span class="keyword">sizeof</span>...(args) &gt; <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">        (std::cerr &lt;&lt; ... &lt;&lt; args) &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而, 如果你真的这么写了, 你会发现这种代码无法通过编译. 这是因为在调用 <code>assert</code> 的时候, 类型替换会失败. 你传入的最后一个参数会被尝试与 <code>std::source_location</code> 匹配, 但是显然是不行的. 这听起来非常令人沮丧, 难道我们在每个调用处都必须要手写一个 <code>std::source_location::current()</code> 吗? 当然不是! 除了函数模板, 我们还有类模板. 配合类模板的推导模板, 我们可以实现这个功能. 以下是一个完整的实现:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span>... _Args&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">assert</span> &#123;</span><br><span class="line">    <span class="built_in">assert</span>(_Tp &amp;&amp;condition, _Args &amp;&amp;...args, std::source_location location = std::source_location::<span class="built_in">current</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (condition) <span class="keyword">return</span>;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;assert failed: &quot;</span></span><br><span class="line">            &lt;&lt; location.<span class="built_in">file_name</span>() &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; location.<span class="built_in">line</span>() &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; location.<span class="built_in">function_name</span>() &lt;&lt; <span class="string">&quot;: &quot;</span>;</span><br><span class="line">        <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(<span class="keyword">sizeof</span>...(args) != <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function">            <span class="params">((std::cerr &lt;&lt; args), ...)</span> &lt;&lt; std::endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span>... _Args&gt;</span><br><span class="line"><span class="built_in">assert</span>(_Tp &amp;&amp;, _Args &amp;&amp;...) -&gt; assert&lt;_Tp, _Args...&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="number">0.1</span> + <span class="number">0.2</span> == <span class="number">0.3</span>, <span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了避免使用危险的宏, 我们最后只能选择了这种扭曲的方式实现了我们的 <code>assert</code>. 但是, 这种方式也有一些优点. 首先, 我们可以自定义输出信息, 而且只有在错误时才会生成输出字符串, 而不会有性能开销. 如果你觉得太丑了, 你甚至可以借助 <code>format</code> 来实现更加优雅的格式化输出. 其自由度还是非常高的, 比起 C 原生的 <code>assert</code>. 最后, 附上一个使用了 <code>format</code> 的实现:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span>... _Args&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">assert</span> &#123;</span><br><span class="line">    <span class="built_in">assert</span>(_Tp &amp;&amp;condition, std::format_string &lt;_Args...&gt; fmt = <span class="string">&quot;&quot;</span>, _Args &amp;&amp;...args,</span><br><span class="line">        std::source_location location = std::source_location::<span class="built_in">current</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (condition) <span class="keyword">return</span>;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;assert failed: &quot;</span></span><br><span class="line">            &lt;&lt; location.<span class="built_in">file_name</span>() &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; location.<span class="built_in">line</span>() &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; location.<span class="built_in">function_name</span>() &lt;&lt; <span class="string">&quot;: &quot;</span>;</span><br><span class="line">        std::cerr &lt;&lt; std::format(fmt, std::forward&lt;_Args&gt;(args)...) &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Fmt, <span class="keyword">typename</span>... _Args&gt;</span><br><span class="line"><span class="built_in">assert</span>(_Tp &amp;&amp;, _Fmt &amp;&amp;, _Args &amp;&amp;...) -&gt; assert&lt;_Tp, _Args...&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">assert</span>(<span class="number">1</span> + <span class="number">1</span> == <span class="number">3</span>, <span class="string">&quot;wtf &#123;&#125; &#123;&#125;&quot;</span>, <span class="number">1</span> + <span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">assert</span>(<span class="number">0.1</span> + <span class="number">0.2</span> == <span class="number">0.3</span>, <span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">本文是笔者写 C++ 代码得出的一些实践经验，会长期更新</summary>
    
    
    
    <category term="C++" scheme="http://darksharpness.github.io/categories/C/"/>
    
    <category term="基础知识" scheme="http://darksharpness.github.io/categories/C/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="C++" scheme="http://darksharpness.github.io/tags/C/"/>
    
    <category term="基础知识" scheme="http://darksharpness.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>GDB 使用笔记</title>
    <link href="http://darksharpness.github.io/gdb/"/>
    <id>http://darksharpness.github.io/gdb/</id>
    <published>2024-03-02T04:05:14.000Z</published>
    <updated>2024-05-24T04:05:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>写 Kernel 的时候，需要用到 GDB + QEMU 调试，这里记录一些 GDB 的常用指令，会动态更新。</p><h2 id="简单安装"><a href="#简单安装" class="headerlink" title="简单安装"></a>简单安装</h2><p>首先，需要安装 <code>riscv64-unknown-elf-gdb</code>。作为一个懒狗，笔者参考了 rcore tutorial 的<a href="https://rcore-os.cn/rCore-Tutorial-Book-v3/chapter0/5setup-devel-env.html#gdb">安装教程</a>。需要注意的是，按照该教程下载完 <code>.tar.gz</code> 文件后，需要解压，然后把解压后 /bin 里面的 <code>riscv64-unknown-elf-gdb</code> 移动到 <code>/usr/local/bin</code> 下即可。</p><h2 id="启动指令"><a href="#启动指令" class="headerlink" title="启动指令"></a>启动指令</h2><p>默认是 riscv64-unknown-elf-gdb。QEMU 采用默认端口 1234。其中 xxx 是可执行文件路径。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">riscv64-unknown-elf-gdb \</span><br><span class="line">    -ex <span class="string">&#x27;file xxx&#x27;</span> \</span><br><span class="line">    -ex <span class="string">&#x27;set arch riscv:rv64&#x27;</span> \</span><br><span class="line">    -ex <span class="string">&#x27;target remote localhost:1234&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="调试指令"><a href="#调试指令" class="headerlink" title="调试指令"></a>调试指令</h2><div class="table-container"><table><thead><tr><th>指令</th><th>参数</th><th>作用</th><th>缩写</th></tr></thead><tbody><tr><td>backtrace</td><td>-</td><td>查看函数调用栈</td><td>bt</td></tr><tr><td>breakpoint</td><td>(*addr)</td><td>在地址 addr /当前位置设置断点</td><td>b</td></tr><tr><td>continue</td><td>-</td><td>继续执行程序，直到断点</td><td>c</td></tr><tr><td>delete</td><td>(num)</td><td>删除第 num 个/所有断点</td><td>d</td></tr><tr><td>disable</td><td>(num)</td><td>禁用第 num 个/所有断点</td><td>dis</td></tr><tr><td>enable</td><td>(num)</td><td>启用第 num 个/所有断点</td><td>e</td></tr><tr><td>info</td><td>…</td><td>显示具体信息</td><td>i</td></tr><tr><td>print</td><td>expr</td><td>显示表达式的值</td><td>p</td></tr><tr><td>x</td><td>addr</td><td>显示内存地址 addr 的内容</td><td>x</td></tr><tr><td>list</td><td>-</td><td>显示当前执行的代码是哪个文件</td><td>l</td></tr><tr><td>step</td><td>(num)</td><td>执行 num/单行代码, 会进入函数</td><td>s</td></tr><tr><td>next</td><td>(num)</td><td>执行 num/单行代码, 会跳过函数</td><td>n</td></tr></tbody></table></div><p>需要注意的是, 如果 <code>next</code> 和 <code>step</code> 后添加后缀 <code>i</code>, 即 <code>nexti</code> 和 <code>stepi</code>, 则对应的是汇编指令级别的执行 (即一条汇编指令), 而不是 C 代码级别的执行 (即一行 C 代码), 遇到函数的处理和 <code>next</code> 和 <code>step</code> 是类似的, 缩写对应的是 <code>ni</code> 和 <code>si</code>.</p><p>以下是一些常用指令:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">x/4 0x11451400  <span class="comment"># 显示内存 0x11451400 地址开始的 4 个 word</span></span><br><span class="line">x/5i <span class="variable">$pc</span>        <span class="comment"># 显示当前 pc 往后 5 条指令。i 表示显示汇编指令</span></span><br><span class="line">                <span class="comment"># $pc 这种形式可用于显示寄存器的值</span></span><br><span class="line">x/3i <span class="variable">$pc</span> + 4096 <span class="comment"># 显示 pc + 4096 地址开始的 3 条指令</span></span><br><span class="line">                <span class="comment"># 事实上，参数貌似可以是任意表达式</span></span><br><span class="line">p/d <span class="variable">$t0</span>         <span class="comment"># 显示寄存器 t0 的值, /d 表示以 10 进制显示</span></span><br><span class="line">p/x 114514      <span class="comment"># 显示 114514 的 16 进制表示，不过这么做挺无聊的...</span></span><br><span class="line">p/t 114514      <span class="comment"># 显示 114514 的 2 进制表示</span></span><br><span class="line">p/c 48          <span class="comment"># 显示 48 的字符表示 (这里是&#x27;0&#x27;)</span></span><br></pre></td></tr></table></figure><p>这里简单总结一下显示数值类型的参数:</p><div class="table-container"><table><thead><tr><th>参数</th><th>显示格式</th><th>寻址单位 (byte)</th></tr></thead><tbody><tr><td>/a</td><td>十六进制</td><td>8</td></tr><tr><td>/b</td><td>不变</td><td>1</td></tr><tr><td>/c</td><td>字符</td><td>1</td></tr><tr><td>/d</td><td>十进制</td><td>不变</td></tr><tr><td>/f</td><td>浮点数</td><td>4 或 8</td></tr><tr><td>/h</td><td>不变</td><td>2</td></tr><tr><td>/i</td><td>指令</td><td>4</td></tr><tr><td>/o</td><td>八进制</td><td>不变</td></tr><tr><td>/s</td><td>字符串</td><td>字符串</td></tr><tr><td>/t</td><td>二进制</td><td>不变</td></tr><tr><td>/u</td><td>无符号</td><td>不变</td></tr><tr><td>/w</td><td>不变</td><td>4</td></tr><tr><td>/x</td><td>十六进制</td><td>不变</td></tr></tbody></table></div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;写 Kernel 的时候，需要用到 GDB + QEMU 调试，这里记录一些 GDB 的常用指令，会动态更新。&lt;/p&gt;
&lt;h2 id=&quot;简单安装&quot;&gt;&lt;a href=&quot;#简单安装&quot; class=&quot;headerlink&quot; title=&quot;简单安装&quot;&gt;&lt;/a&gt;简单安装&lt;/h2&gt;&lt;p</summary>
      
    
    
    
    <category term="计算机" scheme="http://darksharpness.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    <category term="工具" scheme="http://darksharpness.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="调试" scheme="http://darksharpness.github.io/tags/%E8%B0%83%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>玄学优化和语言知识 2.0</title>
    <link href="http://darksharpness.github.io/optimize2/"/>
    <id>http://darksharpness.github.io/optimize2/</id>
    <published>2023-11-11T03:11:11.000Z</published>
    <updated>2023-12-22T04:35:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>写了编译器以后，对于 C++ 的理解又进步了不少，看 Compilor Explorer 的汇编也轻松了许多，也对于优化有来些更加深刻的认识。</p><p>下面将会讨论一些有趣的问题，会比较零散。</p><h1 id="移动语义与右值"><a href="#移动语义与右值" class="headerlink" title="移动语义与右值"></a>移动语义与右值</h1><h2 id="为什么要有这玩意"><a href="#为什么要有这玩意" class="headerlink" title="为什么要有这玩意"></a>为什么要有这玩意</h2><p>原因大概是这样的: 对于复杂的对象，其可能本身不大( <code>sizeof</code> 的大小)，但是其本身管理了一些指针，那些指针指向了大量的数据，体积可能是数百倍之于本身。最常见的就是 STL 中的各种容器，比如 <code>std::set</code>,<code>std::vector</code>,<code>std::list</code> 甚至是 <code>std::string</code> 等等。</p><p>以 <code>std::vector</code> 为例，其本质上是保存了指向数据区的三个指针来进行维护。在我们拷贝一份 <code>std::vector</code> 的时候，我们可能会提出这样的问题: 如何高效地拷贝 <code>std::vector</code> 中的数据。一般情况下，我们肯定想的是直接拷贝，用 <code>std::copy</code> 把数据复制一份。</p><p>复制的开销当然是巨大的，这时候，聪明的你可能会发现，我们其实不一定要拷贝数据，我们可以只保存指向那些数据的指针即可。是的，这是一种合理的解决方案，在原来的 <code>std::vector</code> 失效之前，我们的确可以用指针来访问原来的数据。当然，C++ STL 提供了一个不错的包装: 迭代器 (其实大多就是指针的包装…)。不同容器的迭代器提供了一种通用的容器视图，用 <code>begin()</code> 和 <code>end()</code> 两个迭代器表示一个区间。</p><p>当然，迭代器的方案并不是严格意义上的拷贝。那些迭代器只是对于实际容器区间的一个视图，其与实际的数据的生命周期无关。换句话说，原有数据的“掌控权”还是在老的 <code>std::vector</code> 里面，当这个 <code>std::vector</code> 发生改变(比如扩容，析构)时，这个迭代器视图可能会失效。因此，真正的拷贝肯定不能这么写。</p><p>但是，对于那些生命周期步入尾声的容器 <code>std::vector</code>，其该操作之后数据即将被析构，不会再被用到。在这样的情况下，我们可以考虑“接管”这个 <code>std::vector</code>，即让其在析构的时候不去释放数据，而是把数据的掌控权交给新的 <code>std::vector</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">std::vector &lt;<span class="type">int</span>&gt; <span class="built_in">func</span>();</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">(std::vector &lt;<span class="type">int</span>&gt; &amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里的 func() 返回的是一个临时对象</span></span><br><span class="line">    <span class="comment">// 在这个赋值表达式结束后，这个临时对象在析构前不会再被用到</span></span><br><span class="line">    <span class="comment">// 因此，我们可以考虑接管这个临时对象的数据 </span></span><br><span class="line">    std::vector &lt;<span class="type">int</span>&gt; tmp = <span class="built_in">func</span>();</span><br><span class="line">    <span class="built_in">work</span>(tmp);    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>而这，便是移动操作。而那些可以被移动的对象，便是右值，其可以被右值引用绑定。而 C++ 则进一步扩大的程序员自由发挥的空间。除了那些显然生命周期即将结束的临时变量可以被右值引用绑定，我们也可以通过 <code>static_cast</code> 把一个左值引用转化为右值引用，通过类型的不同来调用不同的函数。这样，我们可以统一对于那些在这个函数之后管理的数据不会再被用到的类型进行针对性的优化。</p><p>例如本例 <code>std::vector</code> ，可以直接把新的 <code>std::vector</code> 的指针指向原来的 <code>std::vector</code> 的数据，再把原来的 <code>std::vector</code> 的指针设置为空，使得这个数据完全被新的 <code>std::vector</code> 接管。</p><h2 id="一些性质"><a href="#一些性质" class="headerlink" title="一些性质"></a>一些性质</h2><p>移动操作其实随处可见。例如，正常的一个函数调用会返回一个临时变量，而它显然在这个操作之后，就不会再被用到，因此，其显然是一个右值，可以被右值引用绑定。又比如说，类型转化后(无论是隐式类型转化还是显式的)，其返回的也是一个临时变量，也是一个右值。</p><p>这些天然右值显然可以绑定到右值引用。当然，前面也讲到，我们可以通过 <code>static_cast</code> 把一个左值引用转化为右值引用。当然，<code>static_cast</code> 还是太长了点，所以标准库提供了 <code>std::move</code> 作为一个语法糖，其实现几乎就是 <code>static_cast</code>。</p><p>那右值的意义何在？为什么要强转为右值引用？因为其决定了重载协议！我们可以根据是左值还是右值来决定是否取走的引用对象的数据，从而实现移动语义。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::string str = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果 str 确认不会再被用到了，那么我们可以把 str 的数据移动到 a 中</span></span><br><span class="line"><span class="comment">// 在 move 以后，str 就不再拥有数据了</span></span><br><span class="line"><span class="comment">// 按照 cpprefence 的说法，数据处于一种合法但是未定义的状态，至少可以保证析构不会出错</span></span><br><span class="line">std::string a = std::<span class="built_in">move</span>(str);</span><br></pre></td></tr></table></figure><p>对于那些天然的右值，比如函数返回值(包括类型转化函数)，我们自然是不需要 <code>std::move</code> 来要求移动语义。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">(std::string)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string a = <span class="string">&quot;114514&quot;</span>;</span><br><span class="line">    std::string b = <span class="string">&quot;1919810&quot;</span>;</span><br><span class="line">    <span class="comment">// 这里的 a + b 返回的是一个临时变量，其 work 之后就不会再被用到，是天然的右值</span></span><br><span class="line">    <span class="comment">// 因此，其可以被右值引用绑定，不需要 std::move()</span></span><br><span class="line">    <span class="comment">// 注意到 work 的参数是传值，所以 work 的参数是采用右值版本的构造函数构造的</span></span><br><span class="line">    <span class="built_in">work</span>(a + b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对于那些有名字的变量例如，其都属于左值，我们需要 <code>std::move()</code> 来要强制求移动语义，调用的函数才会选择绑定右值引用的版本，否则，其只会选择绑定左值引用的重载。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">std::string a;</span><br><span class="line">std::string b;</span><br><span class="line">std::string &amp;c = b; <span class="comment">// 正常的左值引用变量，一般来说只能绑定左值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 右值引用变量，可以绑定那些天然的右值，将其生命周期延长至与变量一致</span></span><br><span class="line"><span class="comment">// 其当然可以绑定那些强转的右值引用，但是那些右值引用的生命周期不会延长，这么做也几乎没有意义</span></span><br><span class="line">std::string &amp;&amp;d = <span class="string">&quot;ab&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">std::string x = std::<span class="built_in">move</span>(c); <span class="comment">// 右值引用，调用移动构造，复杂度是 O(1) 的</span></span><br><span class="line">std::string y = c; <span class="comment">// 左值引用，调用拷贝构造，复杂度是 O(n) 的，n 是字符串长度</span></span><br><span class="line"></span><br><span class="line">x = std::<span class="built_in">move</span>(c); <span class="comment">// 右值引用，调用移动赋值，复杂度是 O(1) 的</span></span><br><span class="line"></span><br><span class="line">y = d; <span class="comment">// 即使是右值引用变量本身，其有名字，也是左值，调用拷贝赋值，复杂度是 O(n) 的</span></span><br><span class="line">y = std::<span class="built_in">move</span>(d); <span class="comment">// 右值引用，调用移动赋值，复杂度是 O(1) 的</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当然，这里有一个特例，当一个变量值作为函数的返回值的时候，我们 <strong>不需要甚至不应该</strong> 用 <code>std::move</code> 来把其强制转化为右值，编译器会自动帮我们做这件事情。笔者猜测，这是因为函数中的值(变量)生命周期与函数一致，因此，其可以被看作是一个天然的右值。但是重点不在于此！如果你加了一个 <code>std::move</code> ，其有时候可能会阻止编译器进行 RVO 返回值优化 (具体是 NRVO，具名返回值优化，其优化力度强于移动语义)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">Hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string name = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    <span class="comment">// 这里不应该用 std::move</span></span><br><span class="line">    <span class="comment">// 首先编译器会自动帮我们做这件事情(如果没有进行 NRVO 的话)</span></span><br><span class="line">    <span class="comment">// 其次这可能会阻碍 NRVO 优化</span></span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">Hello</span><span class="params">(std::string &amp;ref)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里需要用 std::move, 是因为 ref 不是值</span></span><br><span class="line">    <span class="comment">// 其在函数结束后生命周期不一定要结束</span></span><br><span class="line">    <span class="comment">// 因此，如果需要移出数据，需要用 std::move</span></span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">move</span>(ref);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/11/11/nScuUXxQ8aLl6vz.png" alt="NRVO 要求返回的是变量值，move 之后无法满足该要求"></p><h2 id="右值引用变量到底延长了啥"><a href="#右值引用变量到底延长了啥" class="headerlink" title="右值引用变量到底延长了啥?"></a>右值引用变量到底延长了啥?</h2><p>前文提及了右值引用变量，这东西其实表现就和一个普通的左值引用变量几乎完全一致，为了移动语义我们还需要用 <code>std::move</code> 来选择重载决议，唯一的特点就在于延长生命周期这一点……</p><p>其本质上并不是延长生命周期，而是赋予了临时变量值了一个名字…… 当其初始化等号右边是一个临时变量值 (也就是前面所说的天然右值，包括调用函数的返回值，类型转化等等) 的时候，其的确可以延长其寿命 (因为临时值的生命周期是确定的，如果没被延长立刻就死了)。但是当初始化等号右边是一个引用时，引用本身与引用的对象的生命周期并不挂钩，引用的对象可能在十万八千里外! 因此，编译器显然无法保证延长那个实际变量的周期，所以并不会有任何作为。</p><p>换句话说，只有当右值引用绑定的对象的生命周期明显确定(编译器可知，其实就是那些临时变量)，其才能延长对象的寿命。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 请把 std::move 看作 static_cast &lt;int &amp;&amp;&gt;</span></span><br><span class="line"><span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> &amp;&amp;tmp1 = <span class="number">0</span>; <span class="comment">// OK! 生命期延长至与 tmp1 一致</span></span><br><span class="line"><span class="type">int</span> &amp;&amp;tmp1 = std::<span class="built_in">move</span>(x); <span class="comment">// OK! 没有生命周期被延长</span></span><br><span class="line"><span class="type">int</span> &amp;&amp;tmp2 = std::<span class="built_in">move</span>(<span class="number">1</span>); <span class="comment">// 未定义行为 Undefined behavior，这是垂悬引用</span></span><br></pre></td></tr></table></figure><h2 id="移动后的对象"><a href="#移动后的对象" class="headerlink" title="移动后的对象"></a>移动后的对象</h2><p>在实际编程中，对于那些被移动的对象，其基本上只会等到自然生命周期然后被析构，我们理论上不会再对其做任何事情。但是，移动只不过说其内部的资源可以被移走，引用的对象依旧处于一个可以被析构的，合法但不确定的状态。</p><p>当我们清楚具体的实现的时候，我们依然可以操作那些被移走的变量。例如对于常见 STL 容器 <code>std::vector</code> ，在 x86_64, gcc 13.2 的标准库实现中，被移走的后 <code>std::vector</code> 为空。事实上，常见实现都是移动后设空，至少笔者遇到的 <code>std::vector</code> 和 <code>std::list</code> 和 <code>std::set</code> 什么的都是这样的。</p><p>当然，以上不是标准规定的内容，其取决于库的实现。就笔者所知，在 C++ 标准中，智能指针 和 std::thread 有特殊指定，被移动后的状态为空。如果你实在不放心，可以调用 clear() 函数后再使用 (理论上如果移动后为空，这干的是重复的事情，在 O2 下几乎肯定会被优化掉，所以不放心的话那就加上吧)。</p><p>简而言之，清楚实现的情况下，怎么玩都行（</p><h2 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h2><p>移动语义和右值是 C++ 搞出来的小 trick。本质上，C++ 添加了右值引用，其类似左值引用，但是其只能绑定右值，和左值引用属于不同的类型。因此，通过其提供的类型信息来选择不同的重载，从而实现了移动语义。</p><p>换句话说，其不存在所谓的修改生命周期，只不过是资源管理权的移交罢了，相关变量析构的生命周期也不会变 (唯一的特例是前面讲到的对于天然的右值，使用右值引用延长生命周期)。</p><p>其好处是在某些时候减少拷贝的开销，充分利用起来那些在析构前不会再被用到的资源，从而提高程序的效率。</p><p>特别地，当对应的函数没有重载对应的右值版本 (按值传递潜在的含有右值构造函数)，或者当前类型没有可以移走的数据(比如基本类型 <code>int</code> ，移动和拷贝开销一致)，那么 <code>std::move</code> 并没有任何意义。同时，对于作为函数返回值的变量值，我们不应该使用 <code>std::move</code></p><p>当然，以上的说法其实并不严谨，真正的右值还分为 xvalue ，prvalue 等等，想了解的可以自行 cppref，这里就不过多介绍了。</p><h1 id="传值还是传引用"><a href="#传值还是传引用" class="headerlink" title="传值还是传引用?"></a>传值还是传引用?</h1><p>在编写 C++ 程序的时候，一个非常头疼的问题是到底应该传值作为函数参数，还是传一个引用，如下所示。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pass_value</span><span class="params">(std::string)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pass_reference</span><span class="params">(<span class="type">const</span> std::string &amp;)</span></span></span><br></pre></td></tr></table></figure><p>下面将会以一个不严谨的视角来解释如何解决这个问题。</p><h2 id="不严谨的直观"><a href="#不严谨的直观" class="headerlink" title="不严谨的直观"></a>不严谨的直观</h2><p>首先，引用的本质是什么? 在写了编译器后，我可以自信的说，在绝大多时候，引用“表现”的就和一个指针几乎完全一致，只不过它本身(即类似指针指向的地址)不能被修改。换句话说，其可以简单视作 const pointer 的语法糖。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ref</span><span class="params">(<span class="type">int</span> &amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ptr</span><span class="params">(<span class="type">int</span> * <span class="type">const</span>)</span></span>; <span class="comment">// 注意，const 修饰的是 * 而不是 int</span></span><br></pre></td></tr></table></figure><p>换句话说，引用类似一种指针的约定。该约定要求该指针指向的对象非空，且该指针绑定的对象(即指针的值，对象的地址)不可切换，这显然很有助于编译器做特定的优化。更重要的是，其被赋予了其他更加强大的功效，结合 C++ 语言特性。</p><p>例如，在 C/C++ 中，引用不仅能够绑定左值，对于 <code>T</code> 类型，<code>const T &amp;</code> 还能绑定右值。而在 C++ 中只有左值可以取地址，<code>const T &amp;</code> 这种绑定右值的特性是 <code>const T * const</code> 所不具有的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> &amp;y = x; <span class="comment">// 正常情况</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// int &amp;z = 0;      报错，因为 0 不是左值</span></span><br><span class="line"><span class="comment">// int &amp;w = func(); 报错，函数返回值不是左值</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;z = <span class="number">0</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;w = <span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// const int *p = &amp;0; 报错，不能取地址</span></span><br><span class="line"><span class="comment">// const int *q = &amp;(func()); 报错，函数返回值不是左值</span></span><br></pre></td></tr></table></figure><p>类似右值引用，const 引用绑定临时变量后，其生命周期会被延长至与引用一致。但是，对于那些强转绑定的右值引用，则不会延长。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;tmp1 = <span class="number">0</span>; <span class="comment">// OK! 生命期延长至与 tmp1 一致</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;tmp1 = std::<span class="built_in">move</span>(x); <span class="comment">// OK! 没有生命周期被延长</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;tmp2 = std::<span class="built_in">move</span>(<span class="number">0</span>); <span class="comment">// 未定义行为 Undefined behavior，这是垂悬引用</span></span><br></pre></td></tr></table></figure><h2 id="开销"><a href="#开销" class="headerlink" title="开销?"></a>开销?</h2><p>既然和指针类似，那么其开销也应该和指针类似，而指针本身在 64 位系统上就占据 8 个字节。显然，比起恐怖、复杂度未知的拷贝，这个开销是可以接受的。这也是为什么很多人都推荐初学者使用引用而不是指针。</p><p>但是，如果拷贝的开销是已知的，那么我们就权衡一下两者的开销比。对于那些短类型例如 <code>int</code> 和 <code>long long</code> 之类，我们完全没必要传引用。拷贝的开销此时和引用一样，还可以避免引用(指针)间接取值的潜在开销 (这需要一次额外的不确定的地址访问，对比之下局部变量可能被优化为寄存器存储，或者是一个确定的栈上地址)。</p><p>因此，笔者的建议是，对于那些拷贝不超过 16 Byte 的类型，也就是不超过<code>sizeof(std::size_t) * 2</code> 大小的类型，我们应该传值而不是传引用，除了基本类型，常见的有 <code>std::complex &lt;double&gt;</code>,<code>std::string_view</code>,<code>std::pair &lt;int, int&gt;</code> ，甚至是 <code>std::unique_ptr</code> 等等 (这是因为 <code>unique_ptr</code> 只支持移动不支持拷贝，移动构造只需要拷贝一个指针的大小)。当然，这个 16 Byte 的界限并不是绝对的，只是一个经验值，可以根据实际情况进行调整。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">good_func</span><span class="params">(<span class="type">const</span> std::string &amp;,<span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">good_iff_you_know_wtf_u_r_doing</span><span class="params">(std::string,<span class="type">const</span> <span class="type">int</span> &amp;)</span></span>;</span><br></pre></td></tr></table></figure><h1 id="new-和-delete-到底干了什么"><a href="#new-和-delete-到底干了什么" class="headerlink" title="new 和 delete 到底干了什么"></a>new 和 delete 到底干了什么</h1><p>大家都知道 <code>C</code> 语言中 <code>malloc</code> 和 <code>free</code> 分别申请内存/释放内存，而 <code>C++</code> 中，我们一般使用 <code>new</code> 和 <code>delete</code> 来申请/释放内存。但是，这两者到底干了什么呢?</p><h2 id="new"><a href="#new" class="headerlink" title="new"></a>new</h2><p>由于 C++ 的特性，在使用 <code>new</code> 的时候不仅分配了内存，还会调用构造函数来构造对象。</p><p>在分配内存的时候，其实 <code>new</code> 差不多就是调用了 <code>malloc</code> 来实现的，但是当空间不够的时候，<code>malloc</code> 会返回空指针，而 <code>new</code> 会抛出异常。如果你不希望抛出异常，可以使用 <code>nothrow</code> 版本的 <code>new</code> ，其会返回空指针。例子来自 <a href="https://en.cppreference.com/w/cpp/memory/new/nothrow">cppreference</a> 。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;new&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="type">int</span>[<span class="number">100000000ul</span>];   <span class="comment">// throwing overload</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::bad_alloc&amp; e) &#123;</span><br><span class="line">        std::cout &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="type">int</span>* p = <span class="built_in">new</span>(std::nothrow) <span class="type">int</span>[<span class="number">100000000ul</span>]; <span class="comment">// non-throwing overload</span></span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Allocation returned nullptr\n&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特别地，对于那些基本的内置类型，比如 <code>int</code> 和 <code>char *</code> 这些，其没有所谓构造函数因此，包括类似地的聚合类，比如 <code>struct &#123; int x,y; &#125;;</code> 。此时，单纯的 <code>new</code> 不会调用构造函数，而是直接分配内存。这种情况下，如果你想要让里面的数据默认初始化(为 0)，你需要用花括号或括号显式初始化。</p><p>事实上，该初始化过程非常类似 <strong>局部变量的初始化</strong> 。对于内置类型，在构造函数未指值的时候 (比如没有构造函数的 <code>int</code>，或者构造函数没为这个 <code>int</code> 成员变量初始化)，其值是不确定的。一般来说，对于聚合类/内置类型，会使用 <code>&#123;&#125;</code> 初始化来保证是 <code>0</code> 。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = <span class="keyword">new</span> <span class="type">int</span>; <span class="comment">// 分配内存，但是不会调用构造函数</span></span><br><span class="line"><span class="type">int</span> *q = <span class="keyword">new</span> <span class="built_in">int</span>(); <span class="comment">// 分配内存，同时调用构造函数，初始化为 0</span></span><br><span class="line"><span class="type">int</span> *r = <span class="keyword">new</span> <span class="type">int</span>&#123;&#125;; <span class="comment">// 同上</span></span><br><span class="line">std::cout &lt;&lt; *p &lt;&lt; std::endl; <span class="comment">// 未定义行为，p 指向的内存未初始化</span></span><br><span class="line">std::cout &lt;&lt; *q &lt;&lt; std::endl; <span class="comment">// 正常输出 0</span></span><br><span class="line">std::cout &lt;&lt; *r &lt;&lt; std::endl; <span class="comment">// 正常输出 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123; <span class="type">void</span> *p; <span class="type">long</span> <span class="type">long</span> x; &#125;;</span><br><span class="line">A *a = <span class="keyword">new</span> A;   <span class="comment">// 分配内存，什么都不干</span></span><br><span class="line">A *b = <span class="keyword">new</span> A&#123;&#125;; <span class="comment">// 分配内存，初始化为 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> &#123; <span class="type">int</span> x; <span class="built_in">B</span>() = <span class="keyword">default</span>; &#125;; <span class="comment">// 没有初始化哦</span></span><br><span class="line"></span><br><span class="line">B *c = <span class="keyword">new</span> B;   <span class="comment">// 分配内存，什么都不干</span></span><br><span class="line">B *d = <span class="keyword">new</span> <span class="built_in">B</span>(); <span class="comment">// 分配内存，调用构造函数，初始化为 0</span></span><br></pre></td></tr></table></figure><p>那为什么不要求基本类型默认初始化为 <code>0</code> 而要求显式写出 <code>&#123;&#125;</code> 或 <code>()</code> 才能呢？这是因为潜在的开销！<code>C++</code> 的核心理念是抽象无开销 (Zero overhead) 。那么，初始化为 <code>0</code> 还是额外的多做了点事情的对吧，这点开销很有可能是能够避免的，特别是对于大数组的初始化。</p><h2 id="其他的-new"><a href="#其他的-new" class="headerlink" title="其他的 new"></a>其他的 new</h2><p>除了常用的 <code>new</code> 加类型来申请内存，还有一些其他的 <code>new</code> ，比如 <code>new[]</code> 和 <code>new (std::nothrow)</code> 等等。当然，这些主题逻辑上是差不多的，都是先分配内存，后尝试调用默认构造函数。真正有意思的是 <code>operator new</code> 和 <code>placement new</code> 。简单来说，常见的 <code>new</code> = <code>operator new</code> + <code>placement new</code> 。</p><p><code>operator new</code> 大致声明如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> * <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure><p>看到 <code>void *</code>，想必很多熟悉 C 语言的高手就明白了。这东西几乎就是一个 C 语言的 <code>malloc</code> ，只不过额外多了一个防止内存不够的异常抛出。当然，这个 <code>operator new</code> 是可以被重载的，我们可以自己实现一个 <code>operator new</code> 来实现自己的内存分配策略。网上教程也很多，这里就不展开了，多看 cppreference 就好。</p><p><code>placement new</code> 其实根本都称不上 <code>new</code> ，其作用是在给定的指针指向的空间上调用构造函数。举例如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *buf = <span class="keyword">operator</span> <span class="built_in">new</span>(<span class="built_in">sizeof</span>(std::string));      <span class="comment">// raw memory</span></span><br><span class="line">std::string *p = ::<span class="built_in">new</span> (buf) std::<span class="built_in">string</span>(<span class="string">&quot;Hello&quot;</span>);  <span class="comment">// placement new</span></span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; *p &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p>事实上，给定的指针指向的空间不一定要是 <code>new</code> 得到的，甚至可以是栈上的空间。比如 <code>char</code> 数组构成的栈上缓冲区之类。</p><h2 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h2><p>与之相对的，<code>delete</code> 也不仅仅是 <code>free</code> 这么简单，其显然还会额外地调用析构函数，这是 <code>C++</code> 面向对象的特点。当然，对于基本类型，或者简单类型 (比如 <code>struct &#123;int x,int y&#125;</code>) ，其只有 <code>trivial destructor</code> ，也就是什么都不干的析构函数，此时 <code>delete</code> 也不会额外多做什么。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line"><span class="keyword">delete</span> p; <span class="comment">// 析构函数什么都不干，直接 free</span></span><br><span class="line"></span><br><span class="line">std::string *q = <span class="keyword">new</span> std::string &#123;&#125;;</span><br><span class="line"><span class="keyword">delete</span> q; <span class="comment">// 析构函数会调用 std::string 的析构函数，然后 free</span></span><br></pre></td></tr></table></figure><p>特别地，如果 <code>delete</code> 或 <code>free</code> 的指针是空指针，那么其什么都不会做!!! 换句话说，这是安全的，你不应该在这之前判断指针是否为空。这是一个常见的习惯，和 <code>new</code> 之后判断是否为空指针一样 (因为前面说了，<code>new</code> 会抛出异常，只有 <code>nothrow</code> 版本的 <code>new</code> 才会返回空指针)，都是多余的。</p><p>如果你是用 <code>placement new</code> 在栈上的空间放置的内存。那么我们肯定不能调用 <code>delete</code> 来释放内存，因为栈上内存不能 <code>free</code> 。对应的，我们必须对指针显式地调用析构函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"><span class="type">char</span> buf[<span class="built_in">sizeof</span>(std::string)];</span><br><span class="line">string *p = ::<span class="built_in">new</span> (buf) <span class="built_in">string</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">p-&gt;~<span class="built_in">string</span>(); <span class="comment">// 显式调用析构函数</span></span><br></pre></td></tr></table></figure><p>这时候，存在一个小小的 bug ，那就是对于基本类型，其没有析构函数，显然我们不能显式调用析构函数，比如 <code>~int()</code> 是错误的。但是当其作为模板参数，在模板实例化的时候被替换，那么此时是合法的 (当然，啥都不会干)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模板类同理，这里就举一个模板函数的例子</span></span><br><span class="line"><span class="comment">// 即使传入参数为 int，其也可以过编译</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(_Tp *p)</span> </span>&#123; p-&gt;~_Tp(); &#125;</span><br></pre></td></tr></table></figure><h2 id="省流"><a href="#省流" class="headerlink" title="省流"></a>省流</h2><p>简单来说，<code>new</code> 和 <code>delete</code> 其实就是对于 <code>malloc</code> 和 <code>free</code> 的包装。由于 C++ 独特的构造函数和析构函数，对于一个对象，其在申请内存之后必须先执行构造函数，而在归还内存前必须执行析构函数。经过 <code>new</code> 和 <code>delete</code> 和的包装，我们就不用手动对于申请的内存调用构造函数 (即 <code>placement new</code>，如果有的话)，以及在归还内存前调用析构函数 (如果有的话)。</p><p>稍微总结一下，<code>new</code> 的行为大致是这样的:</p><ol><li>首先分配内存空间。如果不够就抛出异常，如果使用 <code>nothrow</code> 版本的 <code>new</code> 则返回空指针。</li><li>尝试调用构造函数。如果是没有构造函数的类型，会调用默认的构造函数。对于 (默认) 构造函数没有覆盖的内置类型，需要用 <code>&#123;&#125;</code> 或 <code>()</code> 显式初始化为 <code>0</code> ，否则其值不确定。</li></ol><p>而 <code>delete</code> 的行为大致是这样的:</p><ol><li>首先调用析构函数。如果是空指针或 <code>trivial destructor</code>，什么都不干。</li><li>归还内存空间。如果是空指针，什么都不干。</li></ol><p>这其实也就是 C++ 的内存模型，核心在于构造函数和析构函数在合适的时候调用。</p><p>对于你不清楚的类型实现，请务必保证在一块空间上，只调用一个类型的构造函数。在使用的时候，请务必该对象执行过构造函数。在归还内存前或离开作用域的时候，请务必保证该对象执行过析构函数。只有构造过的对象才是 “存活的” ，而析构前的对象必须是 “存活的” ，析构后对象必须是 “死亡的” ，当然空间也就可以继续使用或者归还了。</p><p>当然，对于大家熟知的简单类型比如 <code>int</code>，自然没那么多讲究。只要清楚原理，理论上怎么玩都可以 (毕竟指定编译器版本和操作系统，给定对象的实现，行为显然是定义的)。</p>]]></content>
    
    
    <summary type="html">编译器写的。</summary>
    
    
    
    <category term="C++" scheme="http://darksharpness.github.io/categories/C/"/>
    
    <category term="优化" scheme="http://darksharpness.github.io/categories/C/%E4%BC%98%E5%8C%96/"/>
    
    
    <category term="优化" scheme="http://darksharpness.github.io/tags/%E4%BC%98%E5%8C%96/"/>
    
    <category term="C++" scheme="http://darksharpness.github.io/tags/C/"/>
    
    <category term="基础知识" scheme="http://darksharpness.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Compiler for Mx* 编译器随笔</title>
    <link href="http://darksharpness.github.io/CompilerMx/"/>
    <id>http://darksharpness.github.io/CompilerMx/</id>
    <published>2023-09-29T04:48:43.000Z</published>
    <updated>2024-03-02T08:11:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>注: 本文于 2024-03-02 更新循环相关优化部分，其他部分稍作修改。</p><p>课程要求，写了一个简单语言 Mx* 的编译器，语法规则<a href="https://github.com/ACMClassCourses/Compiler-Design-Implementation">请点击这里</a> 。笔者写的很烂，而且项目还烂尾了，所以不放自己写的链接了。</p><p>其简单来说是一个残疾版 Java + C ，拥有类似 Java 的对象模型，所有 class 都是引用类型 (笔者汇编实现其实就是指针)，且有最基本的构造函数和成员函数 ，但没有复杂的面向对象特性 (比如继承，虚函数等等) ，甚至连常见关键词如 static 什么的都没有。当然，解决一些简单的问题还是绰绰有余的。</p><p>编译器最后生成汇编代码的目标平台是 RISC-V 32bit, Integer Extended , 测评使用的是 <a href="https://github.com/Engineev/ravel">ravel 模拟器</a> <del>不过bug(feature)还不少</del> 。</p><h1 id="AST"><a href="#AST" class="headerlink" title="AST"></a>AST</h1><p>笔者前端使用的是 antlr ，通过自己编写 g4 实现 Lexer/Parser 的功能 ，基本属于是自动生成。这部分个人感觉难度不高，除了语法检查有很多细枝末节要考虑，其他基本没啥值得讲的。不过其实在这一部分，其实已经有可以优化的空间了，例如对于无副作用的一些恒等表达式，以及无用的数组 new 。当然，由于笔者实在是没空，在 AST 上我没有做任何优化。</p><h1 id="IR"><a href="#IR" class="headerlink" title="IR"></a>IR</h1><p>IR 上的优化可以说是编译器优化的核心。可以说我 90% 的优化都是作用在 IR 上的。</p><p>笔者的 IR 采用的是简化版本的 llvm IR (至少生成的.ll 可以用 clang 编译运行且不会出错)。下面将会简单讲讲笔者在 IR 上具体写了那些玄学优化，以及计划(但实际没写)的那些优化。</p><h2 id="mem2reg-SSA"><a href="#mem2reg-SSA" class="headerlink" title="mem2reg-SSA"></a>mem2reg-SSA</h2><p>前置知识: <a href="https://oi-wiki.org/graph/dominator-tree/">支配树</a> 。</p><p>SSA(Static single assign) 是指满足虚拟寄存器只会被被单一赋值的 IR ，在 SSA 上，许多的优化可以被简化，且时间复杂度会更优。显然，内存是不能也不需要保证 SSA 的。而局部变量，其可能被多次赋值，不一定能满足 SSA 的条件，所以在生成 IR 的时候一般会用 alloc 申请栈空间用于其值的存储。</p><p>但是实际上，很多时候，寄存器是充足的，我们期望可以把局部变量的值放在寄存器(在 IR 中呈现为虚拟寄存器) 里面，从而避免了高开销的内存读写操作。但是前面也说了，局部变量可以被重复赋值，比如在不同分支中有不同的取值，导致不一定能放入虚拟寄存器。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">bool</span> cond)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> z;</span><br><span class="line">    <span class="keyword">if</span>(cond) &#123;</span><br><span class="line">        z = <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        z = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，mem2reg 为我们提供了一种消除 SSA 形式 IR 中部分 alloc 的方法。其思路大致如下:</p><p>我们把每条指令看作图中的一个节点。除了分支指令有两个后继 (即出边)，其他指令有唯一后继。如果一个局部变量 x 在一条指令的位置被赋值，那么在这条指令所支配 (此处指的是支配树的支配关系) 的范围内，在下一次被赋值之前，其值不会改变，这是由支配树的性质所保证的。但是在其支配边界上，到达该位置的 x 可能就不止来自这个方向的赋值。还可能存在其他方向的赋值，这也很符合支配 “边界” 的直观。为了保险起见，我们要根据其来的方向，为这个 “边界” 上的指令进行值合并。在这里，llvm IR 为我们提供了一个工具函数: phi 函数。其不是真正的函数调用(call) 指令，其作用是根据跳转的分支为一个变量赋值。例如，对于上面那段 C++ 代码，其可以生成类似如下的 llvm IR 代码:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">entry:</span><br><span class="line">    br i1 %cond-0, label %if-0-true-0, label %if-0-false-0</span><br><span class="line"></span><br><span class="line">if-0-true-0:</span><br><span class="line">    br label %if-0-end</span><br><span class="line"></span><br><span class="line">if-0-false-0:</span><br><span class="line">    br label %if-0-end</span><br><span class="line"></span><br><span class="line">if-0-end:</span><br><span class="line">    %z-1.mem.0 = phi i32 [ 1 , %if-0-true-0 ] , [ 2 , %if-0-false-0 ]</span><br><span class="line">    ret i32 %z-1.mem.0</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>简而言之，phi 函数可以用来合并来自不同分支的赋值，类似维护了变量的不同版本，从而保证了 SSA 的形式。这也带来了 mem2reg 这一优化，其可以把所有没有被取地址，且不是 volatile 的局部变量转化为虚拟寄存器，进而消除相关的 load/store。由于 Mx* 的语言特性，其天然不存在取地址，因此所有天然的 alloca 理论上都能被消除，</p><p>mem2reg 首先建立一个函数的控制流图，然后对于所有的局部变量 (alloca 产生)，对每个对这个局部变量的赋值 (目前只含 store 指令)，我们在其支配边界标记插入关于该变量的 phi 函数 (注意，phi 函数也是关于这个变量的赋值。我的解决方案是先处理原来的 store，第二遍再处理 phi 产生的赋值)。</p><p>通过扫描，我们容易确定每个块结束后，一个局部变量在当前块结束时候的值。对于每个新插入的 phi 以及其对应的原本的局部变量 x ，我们只需去每个前驱块或许该局部变量的值并且填入 phi 即可。</p><p>当然，既然讲到了 phi 函数，就需要特别地说明一下，phi 函数的赋值是并行进行的，即一个块里面所有 phi 同时赋值，例如下面的 两个 phi 语句会交换 x 和 y 的值 (当从 %BB1 跳过来的时候):</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%x = phi i32 [ 0 , %entry ] , [ %y , %BB1 ]</span><br><span class="line">%y = phi i32 [ 1 , %entry ] , [ %y , %BB1 ]</span><br></pre></td></tr></table></figure><p>在后文的关于 IR 优化讨论中，我们都假定是在 SSA 形式的 IR 上进行。</p><h2 id="DCE-amp-ADCE"><a href="#DCE-amp-ADCE" class="headerlink" title="DCE&amp;ADCE"></a>DCE&amp;ADCE</h2><p>死代码消除是一个非常常见的优化。在程序中，难免会出现一些无效的死代码。事实上，在上一步 mem2reg 之后，由于其保守地在每个支配边界都会插入 phi，这可能会导致出现一些无效的 phi (即结果在后面用不到，但是由于 mem2reg 维护了变量在每个块的不同版本，保证正确性，因此插入了不必要的 phi)。这时候，死代码消除就能很好的简化生成的 IR 。</p><p>死代码消除有很多种，笔者想出的一个最基础的版本大致如下:</p><ul><li>没被标记为副作用的指令都是无用的。</li><li>有副作用的指令用到的变量，其定值(因为 SSA ，所以有且仅有一次定值(即被定义)) 语句是有副作用的。</li><li>内置的 IO 函数 / 存在全局影响的函数 是有副作用的</li><li>store  指令认为是有副作用的</li><li>branch 指令认为是有副作用的</li><li>return 指令认为有副作用的</li></ul><p>通过沿着 def-use 链条前向传播 (依赖 SSA!)，我们可以在线性时间内确定所有的活指令，从而删除死指令。这个死代码消除相当的 naive ，也不能消除空循环这种无效代码，不过好处是其跑的非常快，只需要线性的时间很小的常数就能跑完，且不会修改控制流图，因此被我用来作为其他所有优化结束后顺便跑掉的一个 pass 。</p><p>真正的死代码消除，应该能够识别那些没有副作用的分支，从而把那些无效分支清除干净 (包括死循环) 。事实上，基础版本的死代码优化对于分支估计还是过于保守。ADCE (Aggressive Dead Code Elimination) ，可以通过控制流图分析来确定那些有效的分支，不过需要的是反向流图的支配关系。过程大致如下:</p><ul><li>所有基本块初始认为是死的</li><li>有副作用的指令的块都是活块</li><li>内置的 IO 函数 / 存在全局影响的函数 是有副作用的</li><li>store  指令认为是有副作用的</li><li>return 指令认为是有副作用的</li><li>jump   指令到活块认为是有副作用</li><li>branch 指令，只有当其处于某个活块的反向支配边界上，其才是存活的。</li></ul><p>ADCE 比起 DCE，虽然依赖反向流图的支配关系 (这个东西的建立特别费时) ，但是可以消除那些无效的分支 (例如空循环或无效循环)，的确对的上 “Aggressive” 这个名字。</p><h2 id="SCCP"><a href="#SCCP" class="headerlink" title="SCCP"></a>SCCP</h2><p>常量传播也是非常常见的一个优化。其<del>降低程序员的心智负担，让其大胆写出更多烂代码</del>主要是优化一些表示常数的变量(其实就是临时寄存器)<del>所以为什么不引入 const</del> ，将其在使用处直接替换为对应的常数，这便是最基本的常量传播。</p><p>当然，如果两个 SSA 的变量表示相同的数值 (例如 x = y + 0，显然 x = y)，那么显然我们也可以把 x 在所有使用处替换为 y 。注意，其正确性其实并不 trivial。SSA 要求每个变量只能在其支配的基本块内出现，x 支配的块 y 也一定支配，这并不 trivial 。但是注意到 x = y + 0 ，说明 y 必然支配 x 所在位置，因此 x 所支配的块 y 也必然支配 (看看支配的定义即可)。</p><p>对于分支和 phi 函数，常量传播依然可以进行下去: 我们先从入口出发。如果遇到 phi 函数，我们先按照来的方向给赋值，如果之后从别的方向来并产生了矛盾，那么再标记这个值不是常量 (或者其他固定值) 。如果遇到一个分支，显然，branch 语句的 condition 的值肯定已经确定是常量或者不是常量。如果是常量，我们就根据 condition 走对应的分支。如果不是常量，我们只能假定两个分支都会走。</p><p>因此，常量传播流程大致如下:</p><p>首先标记所有的变量 (临时寄存器) 的状态为未知。变量状态有三种: 未知(Unknown) ， 已知 (Known，必须是常量或者其他固定值)，非常量 (Non-const)。状态合并规则如下:</p><ul><li>Unknown   + any   = any.</li><li>Non-const + any   = Non-const</li><li>Known_i + Known_i = Known_i</li><li>Known_i + Known_j = Non-const (i,j 不同)</li></ul><p>然后，我们从入口出发(把入口加入块的工作列表 work_list_1)。</p><p>对于 work_list_1 的块，我们按顺序遍历当前工作的块。对于 jump 指令，我们将其目标块加入 work_list_1。对于 branch ，按照之前所讲处理即可。对于其他语句，我们正常进行赋值，并且将 赋值结果 与 结果变量的当前状态 进行合并。如果发现合并结果发生改变，那么我们把这个变量所有被使用的地方(指令)加入 work_list_2 (指令工作列表)。</p><p>对于 work_list_2 的指令，我们尝试对其重新计算，并且将 赋值结果 与 结果变量的当前状态 进行合并。如果发生改变，那么类似地，那么我们把这个变量所有被使用的地方(指令)加入 work_list_2 。</p><p>我们一直执行，直到两个 work_list 都被清空。由于状态合并最多改变两次 (Unknown-&gt;known-&gt;non_const 的过程是单向不可逆)，所以不用担心该操作的复杂度爆炸。不过要特别注意的是，我们沿着某一条边进入一个块，遍历一个块的所有语句，这个操作只会执行至多一次，因为后面如果产生了更新，那么肯定会通过 work_list_2 更新过来，所以不用再 visit 一遍。而同时，一个块除了 phi 语句之外的其他语句至多只需要 visit 一遍，在第二次从 work_list_1 取出的时候，只需要重新 visit 那些 phi 函数就行了。如果存在依赖的改变，那么自然会从 work_list_2 更新过来；如果不存在依赖 (比如两个常数的和) ，那么第一次 visit 的时候的结果就自然是正确的了。</p><p>这部分的证明还是不难但也不 trivial 的，建议读者自行思考各种 corner case 下的正确性。如果有任何疑问，可以参考<a href="https://dl.acm.org/doi/pdf/10.1145/103135.103136">原始论文</a>。(不过主体部分还是很好想到的，事实上笔者一开始基本就是按照自己的理解搓了一个几乎差不多的 SCCP，不过论文还考虑了各种优化，包括哪些只 visit 一次，的确人类智慧)。</p><h2 id="CFG"><a href="#CFG" class="headerlink" title="CFG"></a>CFG</h2><p>流图化简，即 CFG 上的化简，是一个完全由我自己构思的优化 (其实是没看到类似的论文 <del>其实还是懒得找</del> )。其可以尽可能地消除无效的 jump ，同时消除部分 phi 语句 (不过笔者还没 100% 实现)。</p><h3 id="Jump-Elimination"><a href="#Jump-Elimination" class="headerlink" title="Jump-Elimination"></a>Jump-Elimination</h3><p>在前面这几个不痛不痒的小优化之后，我们会发现出现了很多基本块的体积减少了一点，很多甚至只剩下一个 jump 语句。在极端的情况下，我们可以看到一堆由连续重复 jump 指令，例如:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">BB0:</span><br><span class="line">    br label BB4</span><br><span class="line">BB1:</span><br><span class="line">    br label BB2</span><br><span class="line">BB2:</span><br><span class="line">    br label BB3</span><br><span class="line">BB3:</span><br><span class="line">    br label BB4</span><br><span class="line">BB4:</span><br><span class="line">    br label exit</span><br><span class="line">exit:</span><br><span class="line">    ret void</span><br></pre></td></tr></table></figure><p>事实上，这些无效的 jump 都可以被直接压缩为一条语句: <code>ret void</code> 。你可能觉得这不过是常数级别的优化。的确，jump 的确太快了，这些优化显得略有点没用。但是如果 jump 多达几百个呢，这好像就不仅仅是常数了吧。</p><h3 id="Condition-Phi-Elimination"><a href="#Condition-Phi-Elimination" class="headerlink" title="Condition-Phi-Elimination"></a>Condition-Phi-Elimination</h3><p>考虑如下语句:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BB2:</span><br><span class="line">    %cond = phi i1 [ false , %BB0 ] , [ true , %BB1 ]</span><br><span class="line">    br i1 %cond BB2, label %BB3, label %BB4</span><br></pre></td></tr></table></figure><p>如果从 %BB0 过来，那么显然只会跳到 %BB4 。如果 %cond 只在当前条件语句被使用到，那么我们甚至可以直接消除这个 %cond 变量，将这个条件分支直接压缩没了。要知道条件分支对于现代 CPU 的流水线可是一个很糟糕的东西，分支预测错误可是会带来流水线的中断等一系列后果，其速度很慢。因此，我们可以考虑把条件分支顺便也压缩了。</p><h3 id="Tail-Phi-Elimination"><a href="#Tail-Phi-Elimination" class="headerlink" title="Tail-Phi-Elimination"></a>Tail-Phi-Elimination</h3><p>特别地，如果一个 phi 语句后面紧跟 ret 语句，那么显然其与 ret 的返回值相关(否则，之前的死代码消除将会干碎这个无效 phi)。那么，我们可以把当前块拆开，不同块跳过来的时候直接 return 不同的值。这个操作几乎无法消除多少 phi ，看起来没啥大用处，但是其可以为尾递归优化留下空间。考虑以下的 C++ 代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">tail</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n &lt; <span class="number">0</span> ? n : <span class="built_in">tail</span>(n - <span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在正常的 IR 生成中，我们会用 phi 来合并三目运算符的结果。但是这并不利于尾递归优化。当我们手动拆开 phi，相当于将原来的 C++ 代码拆成如下形式:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">tail</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">tail</span>(n - <span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然，这种形式的代码看起来就可以尾递归优化 (甚至是再把尾递归优化为循环)。这也是这个优化的另一个好处。</p><h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>以上就是我个人想到的 CFG 上几处小优化。Jump-Elimination 可用于清除并简化其他优化之后复杂的流图，Condition-Phi-Elimination 则对于 复杂短路逻辑表达式 的优化有奇效，Tail-Phi-Elimination 则能帮助尾递归优化。</p><h2 id="Local-optimization"><a href="#Local-optimization" class="headerlink" title="Local-optimization"></a>Local-optimization</h2><p>这里面涉及了很多块内的优化。这些优化不需要复杂的控制流图，只需要逐块分析即可，不过全是人类智慧。当然，该优化其实可以 global 化，但是由于笔者实在是太累了，所以暂时只写了局部的版本。</p><h3 id="Arithmetic-Simplification"><a href="#Arithmetic-Simplification" class="headerlink" title="Arithmetic-Simplification"></a>Arithmetic-Simplification</h3><p>算术化简是最常见的一个优化了。在 IR 层级，能做的算术化简其实已经所剩无几了。换句话说，该优化其实本应该在 AST 就做掉不少，至少笔者是这么认为的。</p><p>尽管 IR 上处处受限，但是我们依然可以发现以下这些比较 trivial 的表达式优化 (以下摘自笔者的破烂代码的注释):</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Swap operands if the left one is a constant</span></span><br><span class="line"><span class="comment"> * for those symmetric operators: + * &amp; | ^ </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Strength reduction and replacement:</span></span><br><span class="line"><span class="comment"> * X - C        --&gt; X + (-C)</span></span><br><span class="line"><span class="comment"> * X + X        --&gt; X &lt;&lt; 1</span></span><br><span class="line"><span class="comment"> * X * pow(2,n) --&gt; X &lt;&lt; n</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Negative elimination rule:</span></span><br><span class="line"><span class="comment"> * 0 - Y        --&gt; (-Y)</span></span><br><span class="line"><span class="comment"> * X + (-Y)     --&gt; X - Y</span></span><br><span class="line"><span class="comment"> * (-Y) + X     --&gt; X - Y</span></span><br><span class="line"><span class="comment"> * X - (-Y)     --&gt; X + Y</span></span><br><span class="line"><span class="comment"> * (-X) * C     --&gt; X * (-C)    // iff non-power-of-2 C</span></span><br><span class="line"><span class="comment"> * (-X) * (-Y)  --&gt; X * Y</span></span><br><span class="line"><span class="comment"> * (-X) / C     --&gt; X / (-C)</span></span><br><span class="line"><span class="comment"> * C / (-X)     --&gt; (-C) / X</span></span><br><span class="line"><span class="comment"> * (-X) / (-Y)  --&gt; X / Y</span></span><br><span class="line"><span class="comment"> * X % (-Y)     --&gt; X % Y</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Merge operators to try generate deadcode (to be removed~):</span></span><br><span class="line"><span class="comment"> *  Bitwise:</span></span><br><span class="line"><span class="comment"> * (X &amp; C1) &amp; C2    --&gt; X &amp; (C1 &amp; C2)</span></span><br><span class="line"><span class="comment"> * (X | C1) | C2    --&gt; X | (C1 | C2)</span></span><br><span class="line"><span class="comment"> * (X ^ C1) ^ C2    --&gt; X ^ (C1 ^ C2)</span></span><br><span class="line"><span class="comment"> *  Add or Sub:</span></span><br><span class="line"><span class="comment"> * (X + C1) + C2    --&gt; X + (C1 + C2)</span></span><br><span class="line"><span class="comment"> * (X - C1) + C2    --&gt; X + (C2 - C1)</span></span><br><span class="line"><span class="comment"> *  Mult or Div:</span></span><br><span class="line"><span class="comment"> * (X &lt;&lt; C1) * C2   --&gt; X * (C2 &lt;&lt; C1)</span></span><br><span class="line"><span class="comment"> * (X *  C1) * C2   --&gt; X * (C1 * C2)</span></span><br><span class="line"><span class="comment"> * (X *  C1) / C2   --&gt; X * (C1 / C2)        // iff C2 divides C1</span></span><br><span class="line"><span class="comment"> * (X *  C1) % C2   --&gt; 0 + 0 = 0            // iff C2 divides C1</span></span><br><span class="line"><span class="comment"> * (X &lt;&lt; C1) % C2   --&gt; 0 + 0 = 0            // iff C2 divides pow(2,C1)</span></span><br><span class="line"><span class="comment"> *  Shift:</span></span><br><span class="line"><span class="comment"> * (X &lt;&lt; C1) &lt;&lt; C2  --&gt; X &lt;&lt; (C1 + C2)</span></span><br><span class="line"><span class="comment"> * (X &gt;&gt; C1) &gt;&gt; C2  --&gt; X &gt;&gt; (C1 + C2)</span></span><br><span class="line"><span class="comment"> * (X &lt;&lt; C1) &gt;&gt; C2  --&gt; X &lt;&lt; (C1 - C2) or X &gt;&gt; (C2 - C1)</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Special case in merging operators.</span></span><br><span class="line"><span class="comment"> * (C1 - X) + C2    --&gt; (C1 + C2) - X</span></span><br><span class="line"><span class="comment"> * C1 - (X + C2)    --&gt; (C1 - C2) - X</span></span><br><span class="line"><span class="comment"> * C1 - (C2 - X)    --&gt; (C1 - C2) + X</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Maybe I will write this: (Actually not).</span></span><br><span class="line"><span class="comment"> * (0 - X) / X      --&gt; 0 + -1 = -1</span></span><br><span class="line"><span class="comment"> * (0 - X) % X      --&gt; 0 + 0 = 0</span></span><br><span class="line"><span class="comment"> * X / (0 - X)      --&gt; 0 + -1 = -1</span></span><br><span class="line"><span class="comment"> * X % (0 - X)      --&gt; 0 + 0 = 0</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Special case for non-constant test:</span></span><br><span class="line"><span class="comment"> * (X ^ Y) ^ X      --&gt; Y + 0 = Y</span></span><br><span class="line"><span class="comment"> * (X | Y) &amp; X      --&gt; X + 0 = X</span></span><br><span class="line"><span class="comment"> * (X &amp; Y) | X      --&gt; X + 0 = X</span></span><br><span class="line"><span class="comment"> * (X | Y) | X      --&gt; X | Y</span></span><br><span class="line"><span class="comment"> * (X &amp; Y) &amp; X      --&gt; X &amp; Y</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * (X - Y) + Y      --&gt; X + 0 = X</span></span><br><span class="line"><span class="comment"> * (X + Y) - X      --&gt; Y + 0 = Y</span></span><br><span class="line"><span class="comment"> * (X * Y) / X      --&gt; Y + 0 = Y</span></span><br><span class="line"><span class="comment"> * (X * Y) % X      --&gt; 0 + 0 = 0</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Negative generation rule:</span></span><br><span class="line"><span class="comment"> * 0 - X        --&gt; (-X)</span></span><br><span class="line"><span class="comment"> * X * (-1)     --&gt; (-X)</span></span><br><span class="line"><span class="comment"> * X / (-1)     --&gt; (-X)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>这些优化单独来看几乎没啥用，但是结合其他的会有奇效。</p><h3 id="CSE"><a href="#CSE" class="headerlink" title="CSE"></a>CSE</h3><p>公共子表达式消除是一个常见的优化。对于公共子表达式，我们可以用前者在后者使用处替换。但是，这并不一定是好事情。因为如果这个计算过程是非常廉价的，且计算结果的寿命并不长，那么你重复使用第一次的计算结果，可能会导致一个无效的寄存器占用，甚至不如每次都重新计算。不过由于是在块内，所以一般来说还是 ok 的，不会带来过多的副作用。</p><h3 id="UB-elimination"><a href="#UB-elimination" class="headerlink" title="UB-elimination"></a>UB-elimination</h3><p>在代码优化的过程中，我们可能会遇到一些含有未定义行为的语句。例如: 整数除以 0 ，一个没有控制流的基本块 (常见于函数无返回值)，读写空指针…… 由于我们可以假定程序是正确的，因此我们可以直接消除这些未定义行为的语句，但这是远远不够的。事实上，到达这些基本块的途径都应当是非法的 (因为假定没有未定义行为)，因此，我们可以把这个基本块从控制流图中直接移除。</p><p>具体流程大致如下: 首先标记所有含 UB 的块为不可达。然后直接分析控制流图，其中入口为第一个基本块，出口为所有含 return 的基本块。我们分别从出口/入口进行 bfs/dfs 。只有当一个块可以从入口到达，并且可以从出口到达，我们才认为这个块是可达的。最后，我们把所有不可达的块从控制流图中移除。</p><p>特别地，对于那些跳往不可达块的分支，需要把分支转化为无条件跳转。同时，对于 phi 节点中不可达块跳过来的那个格子，其也需要被清空。简而言之，注意下细节即可。</p><h3 id="Load-Store-tracing"><a href="#Load-Store-tracing" class="headerlink" title="Load/Store tracing"></a>Load/Store tracing</h3><p>这个技术其实理论上需要用到更加复杂内存追踪技术，例如 equalSet 什么的，但是笔者实在是太忙了，所以没写这么多。笔者实现的简单版本如下:</p><p>核心思路是维护同一个地址的 load 和 store ，同一个地址后面的 load 一定是上一次 store 的结果。只有当出现了地址可能重叠的 store ，我们才认为这个位置的 load 是不安全。当然，由于 Mx<em> 里面不存在 reinterpret_cast, void </em> 等危险指针操作，所有类型都是可以追溯的，因此我们可以根据 load/store 的类型来判断是否安全。同时，如果 load/store 的是一个类的成员，那么同一个类的不同成员的地址也是不会重叠的。如果不能保证不会重叠，那么我们只能做最坏假设: 认为已经重叠，该值可能失效。当然，全局变量之间肯定不会重叠。因为没有取地址操作，这也使得整个优化可以变得更加激进一些，不用考虑各种阴间 corner cases.</p><h2 id="Inlining"><a href="#Inlining" class="headerlink" title="Inlining"></a>Inlining</h2><p>inline 是老熟人了，这里也就不多说啥了，简单来说就是把部分函数代码内嵌到当前位置。不过，inline 还是有不少细节的 (花了我整整6个小时的说) 。首先是要跑函数调用图。由于函数之间可能会互相调用，因此我们需要先用 tarjan 算法缩点，把那些环形的调用关系缩成一个点。在此之后，函数调用图 call-graph 满足 DAG 。我们可以在 DAG 上按照拓扑序逐一 inline 各个函数。当然，每次 inline 完，我们也需要跑一遍优化 pass，因为 inline 完往往能产生新的优化点。例如:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123; <span class="keyword">return</span> x + y; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">100</span>;</span><br><span class="line">    <span class="type">int</span> y = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">add</span>(x,-y); <span class="comment">// inline + 常量传播直接变成 90</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="loop-related"><a href="#loop-related" class="headerlink" title="loop-related"></a>loop-related</h2><p>由于 Dark 有空了,这一部分又出来了。</p><p>在寒假中，笔者重构了自己的编译器。</p><h3 id="loop-nest-tree"><a href="#loop-nest-tree" class="headerlink" title="loop-nest-tree"></a>loop-nest-tree</h3><p>首先，需要获得循环信息。<del>一个简单可行的方法是直接在 build IR 的时候往标准块上记录一些 metadata</del> 对于一个 general 的 natural loop (换句话说，没有 goto 带来一些奇怪的控制流)，其有这些显著特征:</p><ul><li>循环的入口唯一存在，称作 loop header。其支配了所有循环内的块。</li><li>循环必定存在至少一个 back-edge，即从循环体的某个块跳到 loop header。</li><li>循环之间要么嵌套，要么完全不相交。</li></ul><p>因此，我们可以简单的寻找所有的 back-edge (即从一个块 A ，跳到一个支配块 A 的块 B) ，记录所有的 B ，即为所有的 loop header，同时把 A 记录为 loop body 的一部分。然后，对于所有的 loop header ，我们从目前 loop body 开始，沿着 <strong>反向流图</strong> bfs/dfs ，直到遇到 loop header ，这样我们就找到了这个循环所有的 loop body 块。</p><p>循环之间可能存在嵌套关系，我们可以用一个树形结构来表征这种关系。注意到，两个循环只可能嵌套或完全不相交，不存在其他的情况。因此，我们之前得到的 loop body 两两之间，要么一个完全被另一个包含，要么完全不相交。通过简单的枚举 (但实际笔者的实践借助了支配关系稍稍优化) 即可构建出嵌套关系的树，即为 loop-nest-tree 。</p><h3 id="loop-invariant-code-motion"><a href="#loop-invariant-code-motion" class="headerlink" title="loop-invariant-code-motion"></a>loop-invariant-code-motion</h3><p>事实上，笔者并没有写这个，而是实现了一个更加 general 的 pass: global code motion。具体细节可参考那篇经典的 GCM/GVN 的论文。</p><p>回想一下所谓的 LICM ，其所做的不过是把一些语句移动到了其他的地方。而之所以可以这么做，是因为在 SSA 形式上，只要一个语句 use 在到达这个语句之前都已经被定义了，其即为合法。除了内存操作/函数调用/输入输出 等含有副作用的语句，其他语句都是可以安全的交换顺序，只要满足了合法性。因此，我们可以考虑激进地移动部分语句。</p><p>具体而言，我们先固定那些含副作用的语句 (load/store/call/控制流相关)，然后根据 use-&gt;def 关系后序去遍历所有的指令，确定每个语句可以被定义的最早的位置 (以基本块为单位)。对于任意基本块 A 中某一语句，我们只需保证该语句所有的 use，其所被定义时所在的块支配了块 A 即可。这个过程被称作 scheduleEarly，伪代码如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">scheduleEarly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">markFixed</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> block : blocks)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> inst : block-&gt;insts)</span><br><span class="line">            <span class="built_in">dfs</span>(inst);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">markFixed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> block : blocks)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> inst : block-&gt;insts)</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isFixed</span>(inst))</span><br><span class="line">                first[inst] = block;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                first[inst] = entry;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Post-order dfs.</span></span><br><span class="line"><span class="comment"> * First work out all uses of an inst.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(instruction *inst)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isFixed</span>(inst)) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (visited[inst]) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    visited[inst] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">auto</span> block = entry;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> use : inst-&gt;uses) &#123; </span><br><span class="line">        <span class="built_in">dfs</span>(use);</span><br><span class="line">        <span class="comment">// Choose the deepest one in the dominator tree.</span></span><br><span class="line">        <span class="keyword">if</span> (first[use]-&gt;depth &gt; block-&gt;depth)</span><br><span class="line">            block = first[use];</span><br><span class="line">    &#125;</span><br><span class="line">    first[inst] = block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同理，我们也可以对应的 scheduleLate，即为确定每个语句可以被定义的最晚的位置。我们只需根据 def-&gt;use 关系，保证 def 被用到的地方都被 def 所在的块所支配即可。换言之，def 所在块是其所有 use 可以处于的最晚的块的 LCA (最近公共祖先) 即可，代码几乎完全一致，这里就不再赘述。</p><p>在上面 scheduleLate 的 dfs 函数返回之前，我们得到了每条指令可以位于的最早的块 first 和最晚的块 last (事实上，其是支配树上连续的一段树链，沿着 last 往上跳可以跳到 first)。因此，我们可以尝试规划每条指令所处于的位置。首先，我们显然会让其 loop-nest 的深度尽可能地浅。我们挑选 first 到 last 中最浅地一个块即可。这样的块可能有很多，我们选择就近原则，即尽可能晚地放置这条指令。最后，选择这个循环嵌套深度最浅，且在这个深度上最晚的块，作为真正的 last 返回并记录。</p><p>具体细节建议参考论文，当然论文里面貌似伪代码是错的，建议结合支配关系好好想明白后再动手。</p><h3 id="loop-induction-variable"><a href="#loop-induction-variable" class="headerlink" title="loop-induction-variable"></a>loop-induction-variable</h3><p>很多循环都存在归纳变量，即在一次循环过程中，仅仅加或乘一个常数。而对于常量加上循环变量，其很容易带来一些强度下降，并且给我们带来更多的循环信息(比如循环的次数等等)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">(<span class="type">int</span> *x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i) x[i] = i % <span class="number">32</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> *x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, *y = x; i &lt; <span class="number">100</span>; ++i) *(y++) = i % <span class="number">32</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上例，两个函数是完全一样的，但是后者在循环内会少一次左移操作 (用来求数组的偏移量)，这便是因为 IR 中 getelementpr 指令的基地址是循环不变量，而偏移量又是归纳变量，我们知道其改变规律。因此我们可以不用借助归纳变量，直接操纵基地址，这样可以减少一次左移操作，而每次循环少一次操作，这个优化力度是很大的。</p><p>同时，由于我们知道了 i 的范围，i 一定是非负的，因此 i % 32 可以进一步的被优化为 i &amp; 31 ，这样可以减少一次取模操作，这个优化力度也是很大的，而且非常常见、通用。</p><p>以上是归纳变量优化的基本运用。进阶优化还有很多，例如循环展开、把循环连续拷贝改为 memcpy/memmove 等等。极端的优化甚至可以直接把循环求和优化为等差数列求和公式，但是针对性较强，且比较复杂，笔者暂时没有实现。</p><h2 id="Scalar-replacement"><a href="#Scalar-replacement" class="headerlink" title="Scalar-replacement"></a>Scalar-replacement</h2><p>标量替换指的是把一个没有用到取地址操作的类直接拆成几个标量。例如把一个含有两个 int 的类拆成两个 int 局部变量。</p><p>然而，由于 Mx * 类似 Java 的语法，这导致所有类都是引用类型，而且成员函数 (包括构造函数) 都是需要用到地址(指针)的，标量替换的前提看似很难满足。但是，我们可以一步一步来。</p><p>首先，我们可以通过分析函数调用关系，我们容易得到哪些 new 出来的类 (其实就是 malloc 的空间) 是已经泄露的。泄露指的是这个分配的空间被存到了其他的地方，导致其离开当前函数作用域之后依然可能被访问到，直接泄露的形式有 ret 和 store ，其也可能通过函数调用，phi 函数传播。</p><p>对于那些没有泄露的变量，有一个非常显然的小优化: 我们可以把 malloc 优化为 alloca 。是的，因为其在函数作用域结束后不再会被访问，所以我们可以用更加紧密的栈空间代替堆空间，其可以增加缓存命中率，防止污染缓存，效果还是很好的，尤其是对于那些不是特别大的中小类型。</p><p>然后，再注意到我们其实有 inline 优化，因此很多时候我们会把短的成员函数直接内联了，从而实际上最后我们对于一个类指针的操作仅限于 getelementptr 。在这样的情况下，我们便可以把这个类标量替换，拆为其各个成员。显然，聪明的您肯定也发现了，那些可能被潜在标量替换的变量，一定也是 malloc 优化成为的 alloca 变量。</p><p>以上便是本人标量替换的主体思路。由于时间限制，笔者只完成了标量替换的第一步: 把未泄露的小类型的 malloc 语句替换为了 alloca 。在特定的测试函数中，其性能能提升 10 倍甚至是 9 倍，当然核心原因还是因为其对缓存友好，且避免了费时的 malloc。</p><h2 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h2><p>其他小优化还有一大堆，但是时间限制暂时不详细写了。包括但不限于:</p><ul><li>尾递归优化</li><li>Mx *语言特性优化</li><li>buitlin 函数内联</li><li>UB 信息利用</li></ul><h1 id="ASM"><a href="#ASM" class="headerlink" title="ASM"></a>ASM</h1><p>暂时先摸了。计划讲讲线性染色 Linear scan register allocation 。事实上，笔者写的超级烂，现在还在改，之前写的 Linear scan 可以说是完美结合了 Linear scan 质量低的缺点和 Graph coloring 非线性的缺点。</p><p>计划改为 SSA 上寄存器分配，其不仅线性而且质量不低。不过前提是我的有空啊啊啊</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p><del>没人会看到这里的吧</del>我也不知道为什么，但是这次编译器写的我很累，可能是因为自己真的去证明了很多优化的正确性以及复杂度，同时还自己构思了很多优化(虽然基本都是论文里面的弱化版)，或许以后不应该浪费这么多时间自己瞎想。写的真的挺烂的，烂的不能再烂了，收集了一堆信息却几乎没用上多少，最后榜一还是偷上来的……唯一的好处，或许是对于 C++ 工程代码的经验积攒了不少。</p>]]></content>
    
    
    <summary type="html">一个简单语言的编译器的实现</summary>
    
    
    
    <category term="计算机" scheme="http://darksharpness.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    <category term="编译器" scheme="http://darksharpness.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BC%96%E8%AF%91%E5%99%A8/"/>
    
    
    <category term="编译器" scheme="http://darksharpness.github.io/tags/%E7%BC%96%E8%AF%91%E5%99%A8/"/>
    
    <category term="优化" scheme="http://darksharpness.github.io/tags/%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>第十一届上海 THO · 东方露明境 游记</title>
    <link href="http://darksharpness.github.io/SHTHO11/"/>
    <id>http://darksharpness.github.io/SHTHO11/</id>
    <published>2023-08-23T17:01:49.000Z</published>
    <updated>2023-08-23T18:01:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>警告，本文含有大量图片，可能会比较卡顿。国内用户可尝试挂加速器加速。图总大小约为 85.5 MB，使用流量的用户请慎重点开 !</p><p>第一次参加 THO ，心里还是非常激动的。感谢 <a href="https://github.com/zsq259">Hastin</a> 同学的陪伴，玩的很开心。</p><p>先开个文章占个位吧。会更新的~</p><p>相信我~</p><p>由于某些奇怪的原因，我摆了。但是图片还是会放出来的。</p><h1 id="无分类"><a href="#无分类" class="headerlink" title="无分类"></a>无分类</h1><p><img src="https://s2.loli.net/2023/10/02/N7dyJExAUoa2bGP.jpg" alt="会场外围"></p><p><img src="https://s2.loli.net/2023/10/02/oKTviEgHD28OeUR.jpg" alt="入口"></p><p><img src="https://s2.loli.net/2023/10/02/l8NqJAUEexogsvk.jpg" alt="mc 幻想乡"></p><p><img src="https://s2.loli.net/2023/10/02/qHlhnyiuMemR3JL.jpg" alt="惊现群友"></p><p><img src="https://s2.loli.net/2023/10/02/y4urRaAiqUsvCNh.jpg" alt="琪露诺可爱捏"></p><p><img src="https://s2.loli.net/2023/10/02/yzoB7YRUvDqg8Cb.jpg" alt="东方红红蓝(指星莲船最劣开碟)"></p><p><img src="https://s2.loli.net/2023/10/02/a2AyJdX4DNTilfc.jpg" alt=""></p><p><img src="https://s2.loli.net/2023/10/02/CZXGHIejyqtmcu2.jpg" alt="一些帅气的立牌"></p><p><img src="https://s2.loli.net/2023/10/02/Tc14h9nsSOjEH6e.jpg" alt="fumo!FUMO!!"></p><p><img src="https://s2.loli.net/2023/10/02/VCYPtr9v2QB5zsm.jpg" alt="森萝的队伍真的离谱"></p><h1 id="摊位照片"><a href="#摊位照片" class="headerlink" title="摊位照片"></a>摊位照片</h1><p>以下是本人去逛过并且买过东西或者留下了很深的印象的一些摊位: (还有很多忘记拍照片了())</p><p><img src="https://s2.loli.net/2023/10/02/Q2ZHkCgTjU39v76.jpg" alt="森罗万象 (不过不能拍歌姬和编曲(悲),但 aya 可爱捏)"></p><p><img src="https://s2.loli.net/2023/10/02/OeCF6EYh2IKZxUJ.jpg" alt="Liz Triangle (算是前一个的姐妹社团了,有点意思)"></p><p><img src="https://s2.loli.net/2023/10/02/tMY4vG2cTSJzVeP.jpg" alt="SHI 之境界"></p><p><img src="https://s2.loli.net/2023/10/02/ocv9W4bDmAHUsG6.jpg" alt="上海大学 东方文化研讨(你交怎么没这玩意)"></p><p><img src="https://s2.loli.net/2023/10/02/6mHvuKFLTiIrgPU.jpg" alt="Minecraft 幻想乡(不过此类主题的服务器应该不少)"></p><p><img src="https://s2.loli.net/2023/10/02/qACzFbLoxV9TDYU.jpg" alt="Static world(封面很好看!)"></p><p><img src="https://s2.loli.net/2023/10/02/BpJ4gqSZPGXlD9T.jpg" alt="二重不眠症 (老熟人了, CP29 刚见过面 , 可惜太累了去不了 live)"></p><p><img src="https://s2.loli.net/2023/10/02/IgGZywkFiplb8n6.jpg" alt="少女分形 &amp; 幽闭星光 (曾经的信仰社团,可惜歌姬和编曲没来)"></p><p><img src="https://s2.loli.net/2023/10/02/1USjFagPfH8osEe.jpg" alt="FUMO only (但是不卖 fumo 差评(bushi))"></p><p><img src="https://s2.loli.net/2023/10/02/FspOLqDmctXl8jZ.jpg" alt="妖精的冰屋 (没错就是前面可爱的琪露诺给吸引来的)"></p><p><img src="https://s2.loli.net/2023/10/02/vouXFaGyQ2bpLMH.jpg" alt="绯春研究会 (原来你也喜欢莉莉白小可爱~)"></p>]]></content>
    
    
    <summary type="html">新人，第一次参加 THO~</summary>
    
    
    
    <category term="随笔" scheme="http://darksharpness.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="随笔" scheme="http://darksharpness.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>C++ 20 部分特性尝鲜</title>
    <link href="http://darksharpness.github.io/cpp20/"/>
    <id>http://darksharpness.github.io/cpp20/</id>
    <published>2023-07-06T08:00:37.000Z</published>
    <updated>2023-07-28T08:00:37.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>2023 年了，C++ 23 都要出了，各大编译器厂家对 C++ 20 的支持终于有点进展了。在 GCC 最近(截止 2023-07-06) 的一次版本更新中，终于添加了对于 std::format 的支持。作为一个坚定的 GCC 追随者，笔者自然是选择 g++ 13.1 作为自己的编译器。(笑)</p><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>CPU: 12th Gen Intel(R) Core(TM) i7-12700H</p><p>操作系统: Microsoft Windows 版本22H2<br>(OS内部版本22621.1848)</p><p>GCC version 13.1.0 (x86_64-posix-seh-rev1, Built by MinGW-Builds project)</p><h2 id="其他的话"><a href="#其他的话" class="headerlink" title="其他的话"></a>其他的话</h2><p>笔者希望读者在正式阅读之前，能够记住以下几个要点:</p><p><img src="https://s2.loli.net/2023/07/07/pljTPKDe12JAmxt.png" alt="Codemate? Codegpt!"></p><p>当然，不排除以上是 Codemate 瞎扯的，但是笔者自己的确能很强烈地体会到，C++ 这门语言讲究的就是高效性和包装性。它既要求能拥有和 C 一样的性能，接近底层，也希望能在此基础上提供尽可能多的包装，从而降低方便程序员更好高效的写代码。</p><p>简而言之，性能优先，在此基础上提供尽可能多的便利。这大概就是笔者经历了这一年的 coding 后对于 C++ 的理解罢。欢迎各位讨论~</p><h1 id="concept-amp-requires"><a href="#concept-amp-requires" class="headerlink" title="concept&amp;requires"></a>concept&amp;requires</h1><p>说是话，这可能是我最期待的一个功能了，要想真的想要深入了解，请参考 <a href="https://en.cppreference.com/w/cpp/language/constraints">cpprefence</a></p><h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><p>可能的前置知识: <a href="https://en.cppreference.com/w/cpp/language/sfinae">SFINAE</a></p><p>在 concept 出现之前，设想一下，你需要设计一个 sort 函数。一般情况下，你期望用户传入的是一个连续的序列，即数组之类的。很不幸的是，你的用户不一定有这样的觉悟。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::list &lt;<span class="type">int</span>&gt; l &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    std::<span class="built_in">sort</span>(l.<span class="built_in">begin</span>(),l.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对于标准库的 sort 函数，当用户试图传入不支持随机访问的迭代器，就会出现类似下面的报错信息。</p><p><img src="https://s2.loli.net/2023/07/07/eGMABEJKSi7ahZT.png" alt="超过 100 行了哦~~~"></p><p>这看起来就令人十分的恼火，<del>太长不看!</del>。而更加令人恼火的是，如果代码补全是 VScode 默认的 C/C++ intellisense ，这破玩意甚至不会提示有错! 原因很简单，因为用户传入的参数匹配上了这个函数模板，而这个模板出错是在编译的时候才发现的，因此你的代码补全机器很多时候不会察觉到这个问题。这时候，聪明的你可能想要对其做出一些针对性的优化。于是，你想到了 SFINAE ，这个 C++ 14 就出现的特性。你把 sort 函数进行了巧妙的包装:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>,std::<span class="type">enable_if_t</span> &lt;std::__is_random_access_iter &lt;T&gt;::value,<span class="type">int</span> *&gt; = <span class="literal">nullptr</span>&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">my_sort</span>(T __beg,T __end) &#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">sort</span>(__beg,__end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::list &lt;<span class="type">int</span>&gt; l &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    std::vector &lt;<span class="type">int</span>&gt; a &#123;<span class="number">1</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">my_sort</span>(l.<span class="built_in">begin</span>(),l.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">my_sort</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这下好了，对于传入非随机访问迭代器的参数，其在匹配函数的时候就完全匹配不上这个函数模板，因此在编译之前，你的代码补全工具应该就会告诉你: 没有与参数列表匹配的 函数模板 “my_sort” 实例。而编译后的报错信息也会短不少。不仅如此，有了 SFINAE，你可以为其他不满足的类型提供特定的重载。</p><p><img src="https://s2.loli.net/2023/07/07/zPJtmoSVXwpZbi9.png" alt="短了不少"></p><p>但是这样的问题也是很明显的。对于每个需要验证传入参数时随机访问迭代器的类，你都要写一个又臭又长的 std::enable_if_t…… 这真的太蠢了！完全不符合代码复用和简洁性！</p><p>不仅如此，SFINAE 还存在自己的问题: SFINAE 必须占据函数签名/函数返回值的一部分参数，例如模板参数，函数参数，函数返回值等等。而 SFINAE 占据的参数不能是在函数内部的，本质上还是因为它是在模板进行替换(substitution)操作的时候才检查模板是否可以的。如下是三种常见的 SFINAE 实现方式。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>,std::<span class="type">enable_if_t</span> &lt;std::__is_random_access_iter &lt;T&gt;::value,<span class="type">int</span> *&gt; = <span class="literal">nullptr</span>&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">my_sort1</span>(T __beg,T __end) &#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">sort</span>(__beg,__end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">my_sort2</span><span class="params">(T __beg,T __end,std::<span class="type">enable_if_t</span> &lt;std::__is_random_access_iter &lt;T&gt;::value,<span class="type">int</span> *&gt; = <span class="literal">nullptr</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">sort</span>(__beg,__end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">std::<span class="type">enable_if_t</span> &lt;std::__is_random_access_iter &lt;T&gt;::value,<span class="type">void</span>&gt;</span><br><span class="line"><span class="built_in">my_sort3</span>(T __beg,T __end) &#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">sort</span>(__beg,__end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更加 modern 的写法</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">my_sort3_1</span><span class="params">(T __beg,T __end)</span> -&gt;std::<span class="type">enable_if_t</span> &lt;std::__is_random_access_iter &lt;T&gt;::value,<span class="type">void</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">sort</span>(__beg,__end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当然，你可以用 void_t 等方式来解决此类问题。但这样的模式还是太麻烦了点，特别是当这个东西耦合入代码，就会使得代码的可读性大大下降，直观性也不足，尽管解决了编译报错信息过长的问题。</p><p>最后呢，SFINAE 必须结合模板食用，而很多函数是不能模板化的(例如构造函数等等)。</p><p>这时候，concept 和 requires 作为一个替代方案，它出现了。其把函数的约束条件抽象出来，从而极大地增加了代码的可读性直观性，也让重复的工作得以极大的减少。</p><h2 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h2><p>concept 最基本的形式如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;...&gt;</span><br><span class="line"><span class="keyword">concept</span> ... = constraints......</span><br></pre></td></tr></table></figure><p>其中，等号右边 concept 是一个可以在编译期就能被估值为 bool 类的一系列函数或表达式，其非常像 constexpr bool 变量。举例:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断是不是原生浮点类型,即是不是 float/double</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">concept</span> is_floating_type = std::is_same_v &lt;T,<span class="type">float</span>&gt; || std::is_same_v &lt;T,<span class="type">double</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出 true false */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; std::boolalpha;</span><br><span class="line">    std::cout &lt;&lt; is_floating_type &lt;<span class="type">float</span>&gt; &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; is_floating_type &lt;<span class="type">long</span>&gt; &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">bool_true</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="comment">// 注意，这个 constexpr 是必须的!</span></span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">concept</span> always_true = <span class="built_in">bool</span>(bool_true&#123;<span class="number">3</span>&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>而使用一个 concept 有很多种方法。虽然这有点像茴香豆的四种写法，但我觉得还是有必要都了解一下的，当然平时只要会用就行了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">concept</span> signed_integer = std::is_integral_v &lt;T&gt; &amp;&amp; std::is_signed_v &lt;T&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;signed_integer T&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">lowbit1</span><span class="params">(T x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="comment">// 这里可以 requires 很多个 constexpr bool/concept 哦</span></span><br><span class="line"><span class="keyword">requires</span> signed_integer &lt;T&gt; &amp;&amp; <span class="function"><span class="literal">true</span> </span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">lowbit2</span><span class="params">(T x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">lowbit3</span><span class="params">(T x)</span> <span class="keyword">requires</span> signed_integer &lt;T&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">lowbit4</span><span class="params">(signed_integer <span class="keyword">auto</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果你把下面这些整数变为 10f(float 类)/ 10u(unsigned)，</span></span><br><span class="line"><span class="comment"> * 你的 intellisense 应该会报错，编译也不会通过。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout </span><br><span class="line">        &lt;&lt; <span class="built_in">lowbit1</span>(<span class="number">10</span>) &lt;&lt; <span class="string">&#x27; &#x27;</span></span><br><span class="line">        &lt;&lt; <span class="built_in">lowbit2</span>(<span class="number">12</span>) &lt;&lt; <span class="string">&#x27; &#x27;</span></span><br><span class="line">        &lt;&lt; <span class="built_in">lowbit3</span>(<span class="number">14</span>) &lt;&lt; <span class="string">&#x27; &#x27;</span></span><br><span class="line">        &lt;&lt; <span class="built_in">lowbit4</span>(<span class="number">16</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>而 requires ，顾名思义就是 要求 (require) 对于函数模板产生一定的约束(误)。确实是这么一回事，但 requires 不只是这些，其不仅可以后接 constexpr 变量和定义好的 concept (正如前面 lowbit2 函数演示的那样)，作为标识符检查值是否为 true，其还可以添加任意的表达式，检验内部表达式是否存在，自身充当一个 constexpr bool 变量。下为伪代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">requires</span> <span class="comment">//含 concept 和 constexpr bool 逻辑表达式，相当于一个完整的语句</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下两种 requires 则更像是一个表达式</span></span><br><span class="line"><span class="keyword">requires</span> &#123; <span class="comment">/* 具体约束,只会判断能否过编译，不会真实执行。 */</span> &#125;</span><br><span class="line"><span class="built_in">requires</span> (<span class="comment">/* 参数表，类似函数参数 */</span>) &#123; <span class="comment">/* 具体约束 */</span> &#125;</span><br></pre></td></tr></table></figure><p>当然，这么说还是太抽象了点，下面举一些简单的例子:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 注意，concept 也可以有默认参数，虽然一般没啥用</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span> = <span class="type">void</span>&gt;</span><br><span class="line"><span class="keyword">concept</span> A = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// requires 最基础的用法，检测后面表达式是否为 constexpr true</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="built_in">requires</span> (<span class="literal">true</span> &amp;&amp; A &lt;T&gt;) || <span class="function"><span class="literal">false</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">(T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span>;</span><br><span class="line">    <span class="built_in">static_assert</span>(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意区分下面两个 requires 的区别</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">requires</span> <span class="keyword">requires</span> &#123;</span><br><span class="line">    <span class="built_in">func1</span>(<span class="number">114514</span>);</span><br><span class="line">&#125; &amp;&amp; (<span class="built_in">sizeof</span>(T) == <span class="number">4</span>)</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">tester</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">concept</span> arithable = A &lt;&gt; &amp;&amp; A &lt;T&gt; &amp;&amp; <span class="built_in">requires</span>(T x,T y) &#123;</span><br><span class="line">    x + y;</span><br><span class="line">    x - y;</span><br><span class="line">    x * y;</span><br><span class="line">    x / y;</span><br><span class="line">    <span class="keyword">typename</span> tester &lt;T&gt;; <span class="comment">// 检测类型是否存在</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">concept</span> is_container = <span class="built_in">requires</span> (T x) &#123;</span><br><span class="line">    x.<span class="built_in">size</span>();  <span class="comment">// 检测成员函数/成员变量</span></span><br><span class="line">    x.<span class="built_in">empty</span>();</span><br><span class="line">    x.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">typename</span> T::iterator; <span class="comment">// 检测类型是否存在</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意区分下面的两个 requires</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">concept</span> is_custom = <span class="built_in">requires</span> (T x) &#123;</span><br><span class="line">    <span class="comment">// 这里的 requires 是 requires 语句</span></span><br><span class="line">    <span class="keyword">requires</span> is_container &lt;<span class="keyword">decltype</span>(x.x)&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">custom_t</span> &#123; std::vector &lt;<span class="type">int</span>&gt; x; &#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>简而言之，存在两类 requires: 第一种 requires 是 requires 语句， 它检测其后的表达式是否为 constexpr bool true ，如果不满足则直接<del>原地爆炸</del>认为是匹配失败，可以继续尝试匹配其他的模板。第二种 requires 则是 requires 表达式，带有约束列表(以及可能带有参数)，其本身会在编译时被替换为 constexpr bool 变量。</p><p>什么，你不信? 看看输出的是啥类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span> = <span class="type">void</span>&gt;</span><br><span class="line"><span class="keyword">concept</span> nothing = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_type</span><span class="params">(T)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;others\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="type">void</span> print_type &lt;<span class="type">bool</span>&gt; (<span class="type">bool</span>) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;bool\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> __r = <span class="keyword">requires</span> &#123; <span class="built_in">sizeof</span>(<span class="type">int</span>); &#125;;</span><br><span class="line">    <span class="built_in">print_type</span>(__r);</span><br><span class="line">    <span class="built_in">print_type</span>(nothing &lt;&gt;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>需要注意的是，concept 不能递归其本身，而 concept 也不能被约束。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">concept</span> A = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不可以递归!</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> <span class="title class_">V</span>&gt;</span><br><span class="line"><span class="keyword">concept</span> Recursive = std::is_same_v &lt;T,V&gt; ||</span><br><span class="line"><span class="built_in">requires</span> (T x) &#123;</span><br><span class="line">    <span class="keyword">requires</span> Recursive &lt;<span class="keyword">decltype</span>(x.x),V&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;A T&gt;</span><br><span class="line"><span class="keyword">concept</span> Error1 = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="keyword">requires</span> A &lt;T&gt;</span><br><span class="line"><span class="keyword">concept</span> Error2 = <span class="literal">true</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看出，concept 和 requires 表达式本质上就是一个 constexpr bool 模板变量，而 requires 语句则是用来辅助 SFINAE 来约束模板类型。在用了 concept 和 requires 之后，代码逻辑变得更加清晰了，SFINAE 不会再和模板逻辑耦合了，再也不用在模板里面放一个又臭又长的 SFINAE 专用参数了(笑)。</p><h1 id="Threeway-Comparision"><a href="#Threeway-Comparision" class="headerlink" title="Threeway_Comparision"></a>Threeway_Comparision</h1><p>在看这个之前，简单回顾下笔者所认为的 C++ 的核心: 性能优先，包装性其次。OK，那我们来考虑一下以下的情景作为引入:</p><h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><p>现在，假设你实现了一个简单的、支持动态扩容的字符串类，如下所示:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> dark &#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">string</span> &#123;</span><br><span class="line">    <span class="comment">/* 具体实现...... */</span></span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作为一个字符串类，除了常见的如 size(),下标访问等接口，自然也是需要支持比较的，而比较的运算符有 &gt;,&lt;,&le;,&ge;,&ne;,== 这些，于是 string 类型直接的比较就需要重载 6 个函数。当然，字符串比较非常简单，你可以直接调用 strcmp 函数进行比较。看到这里，比较仔细且特别关注性能的读者这里可能已经察觉到了一丝异常，你先别急，后面会分析的。</p><p>然而，最麻烦的还不是这个。作为字符串类型，自然要为原生的字符数组类型 char <em> 提供支持，具体体现在可以由原生的 char </em> 数组构造 string，且 string 必须支持和 char <em>进行比较等操作。然而，重载 string 和 char </em> 的比较有两种情况，string (比较运算符) char <em>，以及 char </em> (比较运算符) string 。在 C++ 中，你必须为这两种情况都分别提供特殊的重载，否则，string 和 char <em> 在比较的时候，char </em> 可能会调用隐式构造函数，转化为 string 类型，而这多了一层不必要的开销!</p><p>这样的话，不出意外，你需要写 6 <em> 3 个比较函数。这也太重复了吧! 事实上，对于任意两个字符串的比较，其总是可以归结为两个 const char </em> 进行比较，因此我们可以借助 strcmp 函数来实现，代码类似如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Compare_Less</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *x,<span class="type">const</span> <span class="type">char</span> *y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(x,y) &lt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事实上，这背后还有不少的小麻烦。当你将两个字符串绑在一起，作为一个 pair 的时候，你的比较函数的重载将会非常麻烦。如果按照传统的写法，那可能是这样。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> pair = std::pair &lt;std::string,std::string&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Compare_Less</span><span class="params">(<span class="type">const</span> pair &amp;lhs,<span class="type">const</span> pair &amp;rhs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(lhs.first &lt; rhs.first) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(rhs.first &lt; lhs.first) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> lhs.second &lt; rhs.second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此类写法有一个巨大的问题，那就是前两次比较其实可以一次完成: 如果某个比较操作可以直接明确地返回两个数的相对大小关系，并且开销和一次比较差不多，那么我们用这个比较的结果就可以直接代替前两次比较，将开销较大的两次 string 类转化为一次 string 类比较加上开销较小的若干次 int 值比较，如下所示:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> pair = std::pair &lt;<span class="type">char</span> *,<span class="type">char</span> *&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Compare_Less</span><span class="params">(<span class="type">const</span> pair &amp;lhs,<span class="type">const</span> pair &amp;rhs)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> cmp = <span class="built_in">strcmp</span>(lhs.first,rhs.first);</span><br><span class="line">    <span class="keyword">if</span>(cmp != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> cmp &lt; <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">strcmp</span>(lhs.second,rhs.second) &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，这种写法对于数据的要求略高，不是所有类型都像 string 那样，有一个统一的比较函数接口。</p><p>究其根本，其实是语言上缺少一种一个通用的接口，可以直接返回两个类的明确的相对大小 (即一次性不花费额外开销，得到究竟是小于，还是等于，还是大于的大小关系) 。小插曲，DarkSharpness 在写 map 的时候就意识到了这个问题，只可惜大部分的 map 要求的是 &lt; 重载。为此，Dark 在后续 B+ 树作业中就要求传入的类自带 Compare 函数，可以返回确定的大小关系，当然这么写很不自然也很丑陋……</p><p>总之，过去的 C++ 比较存在如下问题: 需要重载很多的运算符，且不存在统一的可以一次比较出两个数相对大小的方法。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>在 C++ 20 里面，终于推出了<del>宇宙飞船</del>三路比较运算符，作为比较相对大小的统一接口吗，可以说是一个最为优雅的解决方案。</p><p>当然，标准库在此基础上还加强了这一比较运算符。其返回的不是 int 参数，而是返回特殊的比较类别: std::strong_ordering / std::weak_ordering / std::partial_ordering ，对应的是强序关系，弱序关系 和 偏序关系。</p><p><strong>强序关系</strong>表示任何两个该类的对象都可以比较得出相对大小，且等价(equivalent)的两个对象完全相等(equal)，即<strong>这两个对象的值是不可辨别的</strong>。整数类型便是典型的强序关系。</p><p><strong>弱序关系</strong>表示任何两个该类的对象都可以比较得出相对大小，但等价的两个对象<strong>不一定是不可辨认的</strong>。例如，将整数按照二进制位中 1 的个数排序，其满足的就是弱序关系。</p><p><strong>偏序关系</strong>表示两个该类的对象不一定可以比较得出相对大小。例如浮点类型，因为 NaN(not a number) 不能和其他任何东西比较。</p><p>需要注意的是，<strong>等价</strong>(equivalent)和<strong>相等</strong>(equal)往往会被混淆，这可能是因为各位平时都习惯了强序结构……偶尔看看英文还是有好处的，有助于区分某些概念(好吧当年学英语的时候，这两个词也搞了 Dark 一段时间)。</p><p>在使用三目运算符的时候，可以简单的将三目运算符的返回结果和 0 进行比较。如果 &lt; 0 ，那就是小于关系。如果 = 0 ，那就是等价(或相等)关系。否则，就是大于关系。其用法类似 strcmp 函数，这里就不多阐释了。代码如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">custom</span> &#123;</span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line">    std::strong_ordering <span class="keyword">operator</span> &lt;=&gt; (<span class="type">const</span> custom &amp;rhs) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x == rhs.x ? y &lt;=&gt; rhs.y : x &lt;=&gt; rhs.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Bonus"><a href="#Bonus" class="headerlink" title="Bonus"></a>Bonus</h2><p>如果只有三目运算符，并不能称得上什么大革新，只能说为了性能做出的一个统一接口罢了。C++ 20 在三目运算符的基础上，还推出了自动生成运算符的方法。</p><p>是的，只要类里面实现了三目运算符，C++ 就会自动为我们生成包括 &gt;,&lt;,&le;,&ge; 这四个常见的 operator 。同时，C++ 也提供了默认的三目运算符的方法，其讲按照变量定义的顺序，数组的下标从小到大，逐一去比较两个类的成员，类似字典序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">conless</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    std::string y;</span><br><span class="line">    <span class="type">double</span> z[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> <span class="keyword">operator</span> &lt;=&gt; (<span class="type">const</span> conless &amp;,<span class="type">const</span> conless &amp;) = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>需要注意的是，当你使用 default 三目运算符的时候，最好将返回参数设置为 auto ，编译器会自动地决定其返回类型。返回类型当然取得是比较类型中最弱的那个，比如上面例子中 conless 类中，最弱的是 double 数组的 double 变量，是 std::partial_ordering ，因此 auto 推导的类型就是 std::partial_ordering 。特别地，如果存在一个成员类型，其是不可比较的，那么 default 生成的该函数返回类型是 void，因此编译器不会自动生成其他的几个比较函数。</p><p>讲到这里，细心的你肯定已经发现了: 为什么不会帮我们自动生成 == 和 &ne; ? 这背后其实隐藏着一个性能问题:</p><p>在你比较两个 std::string 类型变量是否相等的时候，思考一下你会怎么做? 你会先比较长度! 是的。你不会统一的按照字典序的方法去比较，你当然会先比较长度，如果长度不同那么其显然不会相等。这是一个非常显著的优化。</p><p>因此为了性能，C++ 不会让默认的三目运算符生成 == 和 &ne; ，即使你依然可以通过 <code>(x &lt;=&gt; y) &lt; 0</code> 来判断两个变量是否相等。当然，为了便利性，C++ 也提供了 == 的默认生成方式来生成默认的 == 和 &ne; 运算符。</p><h2 id="Implement"><a href="#Implement" class="headerlink" title="Implement"></a>Implement</h2><p>不得不说 gcc 对于三目运算符的实现还是非常有意思的。首先，要使用三目运算符，需要一个 &lt;compare &gt; 头文件，这个头文件里面有关于 std::strong_ordering 等序结构类的定义。</p><p>通过查看头文件，我们不难发现，其实所谓的大于小于等于的关系，都是用一个 char 变量来表示，其值可以是 -1 (less) 或 0 (equal/equivalent) 或 1 (greater) 或 2 (unordered)。</p><p>不过问题出现了: 你要支持序结构和整数 0 之间比较的操作，例如 <code>(x &lt;=&gt; y) == 0</code> 。但是，如果为序结构提供一个转化为整数的接口，或者为整数提供一个转化为序结构的接口，都会带来各种不安全。那么，如何不依赖编译器，只借用库文件就能实现一个好的序比较呢? 这里就用到了一个 C 语言的 trick:</p><p>字面量 0 ， 其在语言中可以被隐式的转换为空指针类型，类似于 nullptr 。事实上，这一设计存在某些问题，经常被人诟病，这也是为什么我们有了 nullptr。但是，在这里，比较的实现用到了这个 trick。标准库实现了一个虚空代理类 __unspec ，其没有任何成员，唯一的构造函数是传入自己的指针:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">__unspec</span> &#123;</span><br><span class="line">    <span class="keyword">constexpr</span> __unspec(__unspec*) <span class="keyword">noexcept</span> &#123; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>而众所周知，0 可以隐式的转换为空指针类型……因此，事实上，你在比较的不是 0 ， 而是一个 __unspec 对象，通过这个对象和序对象的比较，我们间接的得到了内部的大小关系信息。</p><p>当然，你可能觉得这样太过奇怪。没有关系，标准库也提供了其他的接口来提取出大小关系，如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> cmp = <span class="number">1</span> &lt;=&gt; <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">std::<span class="built_in">is_eq</span>(cmp);    <span class="comment">// == </span></span><br><span class="line">std::<span class="built_in">is_neq</span>(cmp);   <span class="comment">// !=</span></span><br><span class="line">std::<span class="built_in">is_lt</span>(cmp);    <span class="comment">// &lt;</span></span><br><span class="line">std::<span class="built_in">is_gt</span>(cmp);    <span class="comment">// &gt;</span></span><br><span class="line">std::<span class="built_in">is_lteq</span>(cmp);  <span class="comment">// &lt;=</span></span><br><span class="line">std::<span class="built_in">is_gteq</span>(cmp);  <span class="comment">// &gt;=</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="format"><a href="#format" class="headerlink" title="format"></a>format</h1><p>感谢 g++ 13.1 提供的对于 format 的支持，终于可以用了!</p><h2 id="Past"><a href="#Past" class="headerlink" title="Past"></a>Past</h2><p>在过去，标准的输入输出一般有两种途径，一种是 C 语言风格的 scanf/printf ，另一种是 C++ 风格的 std::cin 和 std::cout 。前者可以根据格式串输入输出，后者则是通过类的重载进行输入输出。</p><p>但是，两者都存在一定的问题。相信大家在作为初学者的时候，肯定有遇到 scanf/printf 格式串写错，参数写错等一系列的问题吧。比如:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">long</span> x;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,x); <span class="comment">// 应该是 &amp;x</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,x);  <span class="comment">// 应该是 &quot;%lld&quot;</span></span><br></pre></td></tr></table></figure><p>这样的错误并不会有任何报错，甚至可能不会在运行时有任何的异常出现，直到遇到一些极端情况，出现莫名其妙的错误……</p><p>此类错误 debug 起来并不是非常容易，特别是当程序非常庞大的时候，由于编译器没有报错信息，定位到输入输出出错需要相当长的时间。</p><p>然后是 std::cin 和 std::cout 。尽管其做到了 typesafe，但其性能问题被诟病已久，即使在关闭了流同步以后，表现依然不是非常好。</p><p>然后是可读性，很难理解为了给输出表达式加括号，你需要在两边单独输出两个字符……</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::string str = <span class="string">&quot;Hello World!&quot;</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&#x27;&#123;&#x27;</span> &lt;&lt; str &lt;&lt; <span class="string">&#x27;&#125;&#x27;</span>;</span><br></pre></td></tr></table></figure><p>因此，长久以来，C++ 社区就存在呼声，要有 scanf/printf, std::cin/std::cout 之外的标准 inout 手段，不仅要高效，而且要 typesafe。</p><p>事实上，对于 OIer，他们中的很大一部分，甚至都手写了快速读写函数，而不屑用标准库的输入输出，这就已经足以说明一部分问题了。</p><h2 id="fmtlib"><a href="#fmtlib" class="headerlink" title="fmtlib"></a>fmtlib</h2><p><a href="https://github.com/fmtlib/fmt">fmtlib</a>，一个现代的第三方 C++ 库，其提供了格式化输出字符串更加高效的写法。由于其完美兼顾了 typesafe 和高效的两方面特点，其也因此被部分的并入了 C++ 20 的标准库中。</p><p>由于功能过于繁多，这里挑取其部分特点进行介绍。</p><h3 id="Basic-Usage"><a href="#Basic-Usage" class="headerlink" title="Basic-Usage"></a>Basic-Usage</h3><p>首先，我们来讲讲他怎么用吧。非常简单，他和 printf 非常像，要提供一个格式串和参数列表。但是格式串，其远简单于 printf ， 其没有必要加上 %d %f 之类的参数 ，只需要用 {} 即可。输出的则是 std::string，又有点像是 sprintf。如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// str = &quot;1 2&quot; </span></span><br><span class="line">std::string str = std::format(<span class="string">&quot;&#123;&#125; &#123;&#125;&quot;</span>,<span class="number">1</span>,<span class="string">&quot;2&quot;</span>);</span><br></pre></td></tr></table></figure><p>特别地，当你要输出一个字符 { 或 } 的时候，只要重复一遍即可，如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// str = &quot;&#123;1 2&#125;&quot; </span></span><br><span class="line">std::string str = std::format(<span class="string">&quot;&#123;&#123;&#123;&#125; &#123;&#125;&#125;&#125;&quot;</span>,<span class="number">1</span>,<span class="string">&quot;2&quot;</span>);</span><br></pre></td></tr></table></figure><p>当然，其功能不止如此。如果你想要进一步的操纵输出的变量，你可以在 {} 内部添加新的参数。形如: {index : rule} 。第一个 index 表示输出的变量所在的下标。当默认括弧内无参数的时候，其输出顺序就是从左往右。当括弧内存在 index 参数的时候，所有括弧必须都有 index 参数，且输出顺序按照 index 顺序。当只有 index，冒号可写可不写。特别地，这玩意甚至支持复用! 如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// str = &quot;1919810&quot;</span></span><br><span class="line">std::string str = std::format(<span class="string">&quot;&#123;1&#125;&#123;1:&#125;&#123;0&#125;&quot;</span>,<span class="number">810</span>,<span class="string">&quot;19&quot;</span>);</span><br></pre></td></tr></table></figure><p>而冒号后面的内容，则是具体格式串的要求。如下:</p><p>整数:</p><div class="table-container"><table><thead><tr><th>格式</th><th>含义</th></tr></thead><tbody><tr><td>d</td><td>十进制整数</td></tr><tr><td>x</td><td>小写十六进制整数</td></tr><tr><td>o</td><td>八进制整数</td></tr><tr><td>b</td><td>二进制整数</td></tr></tbody></table></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; std::format(<span class="string">&quot;&#123;0:d&#125; &#123;0:x&#125; &#123;0:X&#125; &#123;0:o&#125; &#123;0:b&#125;\n&quot;</span>, <span class="number">114514</span>);</span><br></pre></td></tr></table></figure><p>浮点数:</p><div class="table-container"><table><thead><tr><th>格式</th><th>含义</th></tr></thead><tbody><tr><td>f</td><td>固定点表示法</td></tr><tr><td>e</td><td>小写科学计数法</td></tr><tr><td>E</td><td>大写科学计数法</td></tr><tr><td>g</td><td>选择最简表示法(f/e)</td></tr><tr><td>G</td><td>选择最简表示法(f/E)</td></tr></tbody></table></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; std::format(<span class="string">&quot;&#123;0:f&#125; &#123;0:e&#125; &#123;0:E&#125; &#123;0:g&#125; &#123;0:G&#125;\n&quot;</span>, <span class="number">1919.810</span>);</span><br></pre></td></tr></table></figure><p>字符串:<br>s   表示字符串……  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; std::format(<span class="string">&quot;&#123;:s&#125; &#123;:s&#125;\n&quot;</span>,std::<span class="built_in">string</span>(<span class="string">&quot;yyu&quot;</span>),<span class="string">&quot;yyu&quot;</span>);</span><br></pre></td></tr></table></figure><p>其他输出设置:</p><div class="table-container"><table><thead><tr><th>格式</th><th>含义</th></tr></thead><tbody><tr><td>&lt;</td><td>左对齐</td></tr><tr><td>&gt;</td><td>右对齐</td></tr><tr><td>^</td><td>居中对齐</td></tr><tr><td>数字</td><td>指定输出宽度</td></tr><tr><td>字符</td><td>指定填充字符(用来填充到指定宽度)</td></tr><tr><td>.数字</td><td>设置输出精度/最大字符串长度</td></tr><tr><td>+</td><td>正数输出 + 号</td></tr></tbody></table></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; std::format(<span class="string">&quot;&#123;0:_^10s&#125;\n&#123;0:_&lt;10s&#125;\n&#123;0:_&gt;10s&#125;\n&quot;</span>,<span class="string">&quot;yyu&quot;</span>);</span><br><span class="line">std::cout &lt;&lt; std::format(<span class="string">&quot;&#123;:.3s&#125;\n&#123;:.3f&#125;\n&quot;</span>,<span class="string">&quot;yyuyyu&quot;</span>,<span class="number">1.0</span>);</span><br></pre></td></tr></table></figure><p>除了 format，标准库还提供了 format_to 函数，其可以把格式化的结果输出到一个 char 数组当中。其功能类似 sprintf，但是性能更优，且支持自定义解析，而且类型安全。</p><h3 id="Compile-Time-Parse"><a href="#Compile-Time-Parse" class="headerlink" title="Compile-Time-Parse"></a>Compile-Time-Parse</h3><p>format 库最大的特点是它支持的是编译期解析，也就是其解析格式串的过程是 0 运行时开销的!</p><p>这是因为其传入的参数必须是 constexpr 的，或者说 consteval 的字符串，即必须在编译期间确定值的字符串。因此，其可以借助 constexpr 函数以及模板，</p><p>由于 Dark 实在是太<del>菜</del>懒了，所以具体的实现咕咕了。感兴趣的可以去看看 std::basic_format_string 这个类 qwq。</p><p>当然，你可能会想: 我们如何为自定义的类型使用自己的 format 格式呢? 这就需要用到自定义的 formatter 类。</p><p>由于时间问题，这里留给读者自行研究 qwq。</p><h1 id="const"><a href="#const" class="headerlink" title="const"></a>const</h1><p>这部分是关于 constexpr,consteval 和 constinit 的。由于 DarkSharpness 太咕咕了，于是这部分就没了。<del>v 我 50现在就写</del></p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>想看啥直接发评论区，有啥讲的不好的欢迎来喷 Dark 教授，真的都可以说的，Dark 教授非常欢迎您指出错误 Orz!</p><p>当前计划列表: std::span , consteval/constinit ……</p><p>参考资料: <a href="https://www.bilibili.com/video/BV1r8411N75b/">C++20 STL Cookbook 2023</a> , <a href="https://en.cppreference.com/w/">cppreference</a></p>]]></content>
    
    
    <summary type="html">C++17 都没学明白，C++20 就来了。</summary>
    
    
    
    <category term="C++" scheme="http://darksharpness.github.io/categories/C/"/>
    
    <category term="基础知识" scheme="http://darksharpness.github.io/categories/C/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="C++" scheme="http://darksharpness.github.io/tags/C/"/>
    
    <category term="基础知识" scheme="http://darksharpness.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>2022学年下半学期总结</title>
    <link href="http://darksharpness.github.io/summary2/"/>
    <id>http://darksharpness.github.io/summary2/</id>
    <published>2023-06-18T14:24:44.000Z</published>
    <updated>2023-10-02T02:14:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>大量图片警告! 本文后半段存在大量图片，使用流量的读者慎点! 图片加载缓慢，国内用户建议使用加速器。</p><p>没想到我这个破烂还能坚持写 blog 到今天……或许 tomorrow we die alive ?</p><p>这次不写 <a href="/summary/"> 上次 </a> 那种流水账了，看着就恶心。</p><p>说实话，这学期真的没啥好总结的，开学就基本决定好要好好摆烂一学期了，结果连摆烂都没坚持下去，中间死活放不下。最后摆烂也没摆成，卷也没卷成，学习一事无成，身体每况愈下。只能说，自己选择的破路，走到底。</p><p>这次呢，我想聊聊我这学期为数不多的，特别投入的项目。当然，我只会讲我想讲的那部分。</p><h1 id="学子讲坛"><a href="#学子讲坛" class="headerlink" title="学子讲坛"></a>学子讲坛</h1><p>这学期，我学子讲坛一开始也没啥想法。但是，鉴于上学期学子讲坛彻底摆烂，分数实在是太逆天，害怕这学期再摆烂 yyu 要不高兴，所以打算认真搞一个。而且呢，我本人是很希望做一个非常有深度，而且能够内容充实，有很多论据的演讲。</p><p>凡是总是要一个动机的吗。我学子讲坛的动机呢，很简单，就是上次那片破烂流水账文章的一段。</p><p><img src="https://s2.loli.net/2023/06/18/RMQgJy9n412VWqf.png" alt="真的很简单"></p><p>而在后续与友人 <a href="https://github.com/zsq259">Hastin</a> 同学交谈的过程中，我也逐渐确立了在学子讲坛中讲好 “东方” 的想法。说实话，我也不是啥资深车万人，对于东方的了解，也很表层很不本质。但是呢，出于一种对于 “东方” 的喜爱，以及一种 “整活” 的心理，最后还是选择了这个话题。</p><p>事实上，我是打算好好讲好它的，毕竟 “东方” 在我心中还是一个非常神圣而 “美好” 的存在。我的确希望能通过这个机会，能让更多的人了解到东方，或许能挽救其下滑的趋势。当然，这样努力的效力是微弱的，即使全班人都能了解东方，那又如何。如果不能成为内容创作者，为社区出力，那么努力几乎就是白费。而我，作为所谓的 “东方爱好者” ，可以说几乎从来没为社区做出什么贡献。我不会创作作品，我也没有财力去支持自己喜欢的社团，听了那么多同人音乐，手头甚至就不到五张东方 CD……我，或许什么都没做，完全没有那种同人精神。我，最差劲了呢……</p><p>准备的过程也是非常曲折的。整个<a href="https://github.com/DarkSharpness/Touhou_Project_Forum">项目</a>全程在 github 上开源开发，进度都有记录。在开学的几周，我和 Hastin 同学其实就已经有在商讨思路。我们甚至计划能在 3 月前规划完主体，然后开学一个月内准备完 PPT。当然，这样的要求显然没有达到。我们大致确定了思路，但是由于各种原因，摆了很久。当然，我们还是都想认真讲好这个话题的，我特地每次学子讲坛都有在认真去听，甚至还会和 Hastin 一起总结，前面的人演讲哪里做的好，哪里做的不好。然后呢，我们也请到了 hjb 同学来帮我们分析，他也提供了许多非常棒的素材!</p><p><img src="https://s2.loli.net/2023/06/18/WOkUB6A9Fvu1T4K.jpg" alt="只是在吹毛求疵,请不要太较真,大家都很认真的~"></p><p>一路拖拖拖，终于拖到了四月末，距离正式开讲只有三周了。这时候，我才意识到，这样巨大的工作量不能再拖下去了。于是最后两周，我们几乎是全身心地投入其中。在这段时间里，我查了许多关于东方的资料和文章，也加入了许多严肃的东方讨论群，逐渐对于东方的过去有了一个更加全面，更加深刻的理解。作为一个文科 + 艺术属性 = 0 的人，我其实很不擅长这方面的破玩意，但是通过查阅文章，我真的接触到了很多不同人的思考，也第一次感受到这种人文方面的魅力(我也不知道该称作什么了)。</p><p>终于拖到了演讲。说实话，一上台，我就已经完全忘记了时间的存在。尽管试讲了很多次，每次都说要控制好时间，然后要控制在哪里停顿，保证效果，最后还是忘得一干二净。不过主体结构倒是没出错，细节的内容貌似也没拉下什么，不过最后强行加戏有点愚蠢，以后可不会再为了讨好 yyu 这么说了(笑)。对于最后 yyu 的点评呢，我只能说…….借题发挥(?)，总之很迷惑就对了，暂时保留意见。</p><p>总之，整个学子讲坛可能是我本学期准备的最久的一个项目了，以后也肯定不会有这样的项目了，至少在学子讲坛这门课上。说实话，我也不知道为什么我要在这样一门只有 2 学分的非核心课上浪费这么多时间。或许是东方给我带来的那一份微不足道的创作欲罢了。</p><p>说了这么多，顺便谈谈我自己的一些旧事吧。在很久以前，Dark 还是很希望能创作东方同人作品的(笑)，但是由于水平不够，在尝试制作同人音乐和绘画无果后放弃。说实话，很少有东西能让我这么想要表现自我，想要加入社区成为一份，也几乎没有东西能让我沉迷其中如此久。或许，这就是东方的魅力所在，这就所谓的同人精神吧，这就是幻想与浪漫吧。管他呢。</p><h1 id="Impart"><a href="#Impart" class="headerlink" title="Impart"></a>Impart</h1><p><a href="/mcImpart/"> Impart </a> ，一个 Minecraft 游戏企划。这里就不多介绍了，想必能看到这里的小朋友肯定是有所耳闻的啦。</p><p>这个计划呢，其实是我童年回忆的一部分…… Impart 最初的活动 EHC，几乎完全就是仿照我初中和高中时(主要是初中)看的那些台湾实况主的 UHC 活动而设定的。在以前，我看到了他们的视频，真的很想自己也能参加这样的活动，但是身边的条件并不允许这一点。到了大学，终于有机会能够补上童年的这块碎片了……</p><p>Minecraft，真的是最喜欢的一款游戏。具体是什么时候也忘记了，大概是小学二三年级的时候，我从同学那里接触到了 Minecraft 这款游戏。当时 MC 还是风靡于我们这里的中小学生的，就像后来的吃鸡和王者荣耀那样。但是，这款游戏不同于当时的赛尔号什么的其他游戏，他是真的抓住了我。在这款游戏中间，我切身的感受到了一种自由，那种创造一切的自由。</p><p>当然，真正变成死忠粉，还多亏了那些游戏实况主。我最早有印象认识的实况主是奇怪君。当时我刚玩手机版 MC 大概一两年，看到了他的实况视频。作为一个新手玩家，他的游戏解说很快吸引了我，指引我学会了许多 MC 的基本操作，也进而认识了 MC 的 Java 版，从此走上了 MC 的不归路。现在看来那时候的实况视频真的是无比简陋，但小时候的我，最享受的就是放学后，能够从家长那里要到手机，然后看那些 MC 视频。</p><p>小学 4 年级以后，大概是 2014 年(?)，我开始高强度玩 Java 版 MC，并且活跃于各个服务器。这时候，我在优酷上，认识了舞秋风这位台湾的实况主。他的那些经典的长视频，牢牢地抓住了我，我特别喜欢那种慢节奏(当然当时的人好像都那样)的生存实况解说，那种轻松而幽默的氛围真的是令人无比愉悦。当然，现在恐怕是再也找不回来了。而没有他，我恐怕当时也不会在众多游戏中，坚持只玩 MC。</p><p>上初中后，我 MC 水平基本过关，可以勉强称得上一个 “入门玩家”，我也开始尝试玩纯生存之外的游戏，毕竟人总不能一成不变吧。这时候，多玩我的世界盒子，提供了绝佳的平台，我可以轻松在上面联机，并且和朋友一起玩耍。直到现在，我还是非常怀念这个启动器的。虽然他的确是盗版，但他也承载了我童年无数美好的回忆，无数个父母不在家的夜晚，在方块世界创造的无数奇迹。只能说，rip吧! 谢谢您给我带来的美好!</p><p>后来的我呢，在多玩没了后，开始转向 BakaXL 和 PCL 两款启动器，也对 MC 有了深刻的多的理解，不过最美好的回忆，还是最初最懵懂无知，和朋友们一起探索时候留下的。当然，如果在看的你，不是一个中度以上 Minecraft 玩家，可能也不会有这么多的感悟。</p><p>所以说，Impart 中的 EHC 活动，完全只是本人童年回忆的衍生，只是在去弥补那块缺失的拼图。(不知道为啥讲了那么多……)</p><p>然后是 Impart 的管理。说实话，我是一个非常不合格的管理员，我没能有力地号召所有玩家能同时上线，其中也有很多次活动因为人数太少而被取消，对此我还是深表愧疚的。当然，Impart 采用的是民主投票，要玩啥由大家自己决定，时间也是大家自己定，我们除了 EHC，也玩了 manhunt , bingo 等诸多项目。</p><p>总之，希望大家开心就好。</p><p>目前 Dark 已经不再是 Impart 的群管理了，只能算得上半个策划罢了。不过这个企划，我还是会坚持下去的。</p><h1 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续?"></a>未完待续?</h1><p>算了，实在是憋不住了，某些老师的某些课程分数还没出来，但是我还是等不及了。直接端上来罢 !</p><p>由于一些奇怪的原因，下半学期的 DLC 从 6 周延长到了 10 周，这多少令人会有点恼火。说实话，我是不喜欢暑假的时候做正事的。我希望能给自己的内心留下一个思考的时间，能让自己无拘无束的幻想…… 当然，我也能大致能猜到 yyu 这么做的原因啦 : 把编译器这个项目迁移到暑假，能让我们下学期的课业压力减轻，然后顺理成章的把之后的课程前移，这样可以大大加快整体进度，培养加速。当然，只是一个猜测罢了。</p><p>首先是长达 6 周的 PPCA。在前两周的时候，写了一个 Risc-V 的 CPU 模拟器。作为一个<del>毒瘤</del>coder，我的想法是迫真去模拟这个 CPU，因此用到了大量的 bit field (C 语言特性)，用来压位，进而更加逼真地模拟 CPU 内部信息传输。包括指令等一系列的存储解析，我也是使用了结构体 + bit field 的方法来实现。虽然这么写的确废了我不少时间，差点还没写完，不过也的确让我能对其有一个更加深入的理解。不得不说，tomasulo 的设计确实精妙，乱序执行的正确性搞了我好久……现在真的觉得 CPU 流水真的是顶尖人类智慧。</p><p>然后是有趣的自选主题。Dark 选的是 Networking ，因为这是今年新出的项目，然后感觉非常有趣，于是就选了。通过这玩意，我接触了非常有意思的 go 语言 ，也接触了携程(goroutines)这个概念。go 写携程真的方便 ! 这简直就是为了携程而设计的语言 ! 在将近一个月的时间内呢，写了一些有趣的东西，比如 TCP 代理客户端，支持 UDP 的 DLC ，TLS 劫持以及 HTTP 的各种处理解析。确实，学到了很多我完全不会的东西，也真的让我觉得网络是一个非常有意思的东西，也见识到了网络的人类智慧之处。感觉现代科技真的处处是人类智慧啊……</p><p>不过要说令我印象最深刻的，那莫过于在 PPCA 的时候打过了《东方星莲船》的 Easy (是的，这是一款非常”简单“的游戏~) 。作为一个 STG 手残党，在某天偶然的摸鱼中掌握了开碟的技巧，然后瞬间打的无比通畅…… 不过这或许也和我的心态有点关系，在正常学期内的时候，我电动可没有现在这种悠闲的心态。总之，也不知道为什么，7 月 20 日下午，我就莫名过了星莲船 Easy 。这是值得纪念的一天，因为这意味着我打通了从永夜抄到鬼形兽(除花映冢)之间所有的正作 Easy 了 ! 或许，以后可以挑战挑战 Normal 了吧。</p><h1 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h1><p>编译器是个有意思的东西，写的是一个类 C 的 Mx 语言的 Compiler 。花了大概三周，完成了从 MX 到 AST 到类 llvm IR 到 ASM(on Risc-V 32bit) 的过程。</p><p>不过这几周，除了 Compiler 的实现，我倒是也干了不少其他的事情了。比如说混入某 <a href="https://github.com/Mq-b/Loser-HomeWork">Modern C++ Loser 群</a>，开始学 Modern C++ 了。这的确是一个有意思的群，我也的确从中学到了不少的 tricks。然后，我也的确有把部分所学用到 Compiler 代码里面啦，比如有趣的 intellisense-friendly 的字符串拼接函数:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">constexpr</span> <span class="type">size_t</span> __string_length(std::string_view __view)</span><br><span class="line">&#123; <span class="keyword">return</span> __view.<span class="built_in">size</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">constexpr</span> <span class="type">size_t</span> __string_length(<span class="type">const</span> <span class="type">char</span> *__str) &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *__tmp = __str;</span><br><span class="line">    <span class="keyword">while</span>(*__tmp) ++__tmp;</span><br><span class="line">    <span class="keyword">return</span> __tmp - __str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">size_t</span> __string_length(<span class="type">const</span> std::string &amp;__str) &#123;</span><br><span class="line">    <span class="keyword">return</span> __str.<span class="built_in">length</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">size_t</span> __string_length(<span class="type">char</span>) &#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> ...T&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">size_t</span> __string_length_sum(<span class="type">const</span> T &amp;...__args) &#123;</span><br><span class="line">    <span class="keyword">return</span> (__string_length(__args) + ...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Empty join will be invalid. */</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> std::string <span class="title">string_join</span><span class="params">()</span> </span>= <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Check whether this type is string or char type. */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> ...T&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">constexpr</span> <span class="type">bool</span> __is_string_v = (</span><br><span class="line">    (std::is_convertible_v &lt;T,std::string_view&gt; </span><br><span class="line">    || std::__is_char &lt;T&gt; ::__value) &amp;&amp; ...</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Join strings together , safe and fast ! */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> ...T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">auto</span> <span class="title">string_join</span><span class="params">(T &amp;&amp;...__args)</span></span></span><br><span class="line"><span class="function">-&gt; std::<span class="type">enable_if_t</span> &lt;__is_string_v &lt;T...&gt;,std::string&gt; </span>&#123;</span><br><span class="line">    std::string __ans;</span><br><span class="line">    __ans.<span class="built_in">reserve</span>(__string_length_sum(__args...));</span><br><span class="line">    (__ans += ... += std::forward &lt;T&gt; (__args));</span><br><span class="line">    <span class="keyword">return</span> __ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Join strings together , safe and fast ! */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">auto</span> <span class="title">string_join_array</span><span class="params">(T __beg,T __end)</span></span></span><br><span class="line"><span class="function">-&gt; std::<span class="type">enable_if_t</span> &lt;__is_string_v &lt;<span class="title">decltype</span> <span class="params">(*__beg)</span>&gt;,std::string&gt; </span>&#123;</span><br><span class="line">    <span class="type">size_t</span> __cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> __cur = __beg ; __cur != __end ; ++__cur)</span><br><span class="line">        __cnt += __string_length(*__cur);</span><br><span class="line">    std::string __ans;</span><br><span class="line">    __ans.<span class="built_in">reserve</span>(__cnt);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> __cur = __beg ; __cur != __end ; ++__cur)</span><br><span class="line">        __ans += *__cur;</span><br><span class="line">    <span class="keyword">return</span> __ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>不得不感慨，真的处处是人类智慧。</p><p>当然，这段时间里，我也干了超级多 Compiler 之外的事情，这很不符合我 <del>致远卷王</del> 的一贯作风。其实也不是我不想学~卷不动了~，只是我不觉得这么内卷很有意义，而且我已经一个学期 + 6 周没有好好休息过了，我精神上也有点受不了。有的时候，特别是深夜 EMO 的时候，我也真的会怀疑自己是不是太菜了，是不是不适合这个班，就这点破意志力。但我还是坚信，还有更多有意义的事情等着我去做，如果找不到自己的本心所在，一昧地像以前那样不知道为啥去学，那我地内心最终也会麻木吧。而我，真的很不想，也很害怕自己变得麻木。如果现在都不能坚持自己的本心去做自己想做的事情，那么我有何理由去相信未来的自己能坚持自己所选的道路。</p><p>在这段时间里呢，我刷了不少东方相关的经典作品，主要以手书为主。在重新审视这些作品的时候呢，我也产生了不少新的感触，思考了许多第一次看的时候没去思考的东西。这种感觉在我两年前刚接触音频处理后，重新去听我曾经喜欢的音乐时也出现过，那种从熟悉事物中收获更多，如同从一个被榨干的柠檬中挤出更多的汁水的复杂情感(奇怪的比喻)。</p><p>这四周，压轴戏想必是 8 月 19 号和 20 号两天的 THO 了! 作为一个入坑将近 5 年的车万人，第一次去 THO ，自然是非常激动。而这短短的两天，也让我有了许多感触，打算单独开一篇文章来写。</p><a href="/SHTHO11/" title="第十一届上海 THO · 东方露明境 游记">第十一届上海 THO · 东方露明境 游记</a><h1 id="摸了"><a href="#摸了" class="headerlink" title="摸了?"></a>摸了?</h1><p><del>摸了，正在等学子讲坛 &amp;&amp; PPCA 评分 ，不过说实话，时至今日，结果貌似对我没有那么重要，至少我感觉如此。不知道是我是真的不再期待当初那份努力的回报，还是我真的太过疲倦而麻木了。管他呢</del></p><p>一眨眼都摸到开学了，这就很尴尬了，已经没啥好评价的了，编译器也终于告一段落了，感兴趣的可以去看文章 <a href="/CompilerMx/"> 关于 Compiler Mx* 的随笔 </a> 。</p><p>不过在最后的最后呢，还是放送一些小故事和图片吧(笑)，主要是之前 3 月份团日去参观了一大会址。那次活动结束后本来要乘大巴回学校，不过我突发奇想想要自己逛一逛，于是就开始了长达两个多小时的骑行之旅~</p><h1 id="回忆杀"><a href="#回忆杀" class="headerlink" title="回忆杀"></a>回忆杀</h1><p>大量图片警告!</p><p>出发点是交大医学院。</p><p><img src="https://s2.loli.net/2023/10/02/t3xjZhq2Ts7z6EW.jpg" alt="启动!"></p><h2 id="卢湾体育场-——-童年，理想，梦"><a href="#卢湾体育场-——-童年，理想，梦" class="headerlink" title="卢湾体育场 —— 童年，理想，梦"></a>卢湾体育场 —— 童年，理想，梦</h2><p>第一站卢湾体育场。不得不说变化还是有点的，塑胶跑道从红色变成了蓝色。这是笔者梦开始的地方，笔者从小学就一直在这里玩耍，也是笔者梦结束的地方，上了高中以后，我就很少去那里了，在搬家以后就再也没去过。梦，终有一天还是要结束的呐。</p><p><img src="https://s2.loli.net/2023/10/02/y7R3GJBqDirdvNY.jpg" alt="感慨万千，可惜童年玩伴大多再也联系不上了......"></p><p>第二站嘉善路地铁站，是我以前的家附近最近的地铁站。依稀记得在我小学五年级到初一的那几年，门口的嘉善路地铁站正在修新的地铁线路 12 号线，周围路基本被围起来了，出现略不方便。后来修好了以后，12 号线由于其贯穿市中心，能够直接换乘大部分线路，它一下子成为了上海地铁里面的 “原神” (奇怪的比喻)，在一年的时间内变成了拥挤程度不亚于一号线的存在。</p><p>总之，在我生命的浪漫的前 16 年里面，我见证了这条地铁线路的诞生。在我搬家之前，嘉善路地铁站还是一个平平无奇的小站。我还记得我正常是从东边那个出口出来，然后往南走回家。或者从西边那个出口出来，那边有全家可以去买饮料。然后在 12 号线修好了以后，我也会从西南的那个出口出去，不过当时那边还没啥建筑，非常的空旷(从前貌似是一个古玩市场(?)，大概有点回忆)。</p><p><img src="https://s2.loli.net/2023/10/02/iBmFbUvojH1K5T8.jpg" alt="以前还没有这个大楼，这几年一下子建起来了，甚至还多了个麦当当"></p><p><img src="https://s2.loli.net/2023/10/02/89i6VvLJPswaDlz.jpg" alt="好吧记错了，古玩城还在"></p><h2 id="回家-大木小区"><a href="#回家-大木小区" class="headerlink" title="回家! 大木小区!"></a>回家! 大木小区!</h2><p>下一站就是回 “家” 了 ! 对，就是回到那个我居住时间最长的家，从 2008 年到 2020 年，整整 12 年的时间，我都居住在那个安静的坐落于市中心的老旧小区里面。那个小区 —— 大木小区。其前身就有不少的故事，只可惜年代久远，这部分的记忆早已淡忘，可惜。目前，我只记得其有 3 个进出口，由看起来完全无关的 3 个部分构成了一个融合的 “中型” 居民区。</p><h3 id="正阳路"><a href="#正阳路" class="headerlink" title="正阳路"></a>正阳路</h3><p>从后街的那个门进入小区，简单逛了一下，暂时没找到什么大变化。除了墙皮刷新了以外，以前的电瓶车车棚什么的依然都在，那家坐落于角落的小卖部也健在(可惜忘记拍照了)。</p><p><img src="https://s2.loli.net/2023/10/02/174Plf9Vt3MhFIU.jpg" alt="后街正阳路，依然是这么的充满年代感"></p><p><img src="https://s2.loli.net/2023/10/02/u7RLMlWAz18HsEU.jpg" alt="后街的门，感觉重制以后门牌好看了不少"></p><h3 id="大木桥路"><a href="#大木桥路" class="headerlink" title="大木桥路"></a>大木桥路</h3><p>然后是偏向大木桥路的那一侧居民区，那边看起来变化也不是特别的大，也不知道曾经住在那边的几个童年玩伴，现在还在不在那里……不过那个小区内幼儿园居然还在，这是我没想到的(话说门口垃圾站这种逆天设计还没换吗qwq)</p><p><img src="https://s2.loli.net/2023/10/02/rXUDhj9B6Lm8TaI.jpg" alt="居民健身器材换了一套，不过还是在老位置"></p><p><img src="https://s2.loli.net/2023/10/02/QxG6dlV487qSJpc.jpg" alt="那个 inline 于小区的幼儿园还在哦，几乎没啥变化"></p><p><img src="https://s2.loli.net/2023/10/02/3Wm1HrlqO9t5e7i.jpg" alt="大木桥路的门"></p><h3 id="斜土路"><a href="#斜土路" class="headerlink" title="斜土路"></a>斜土路</h3><p>最后是偏向于斜土路的那一侧了! 那便是我以前居住的地方。依稀记得以前家对面就是橘子酒店，没想到现在居然还在。橘子酒店貌似就是在我小学五年级或者是预初初一时开的，我对其的印象时每天晚上都要开到很晚，灯还特别亮，直到 11 点后才关灯。然后隔壁的小巷子偶尔也会有人大喊大叫的，不过我睡得倒是很死……</p><p>这一块比起另外两个区域倒是有些明显的变化，许多区块都装电梯了。可以看到电梯井凸出来一块在外面，略影响外观，不过对于老年人来说，电梯还是能方便不少，特别是这种老小区有很多的老年人 (不过我当时见过的大部分老年人都非常健康的说，好多人手脚可能比我还利索，这下我变成老年人了(悲))。</p><p>令我非常吃惊的一点是，那个裁缝店，居然还在。印象里那个店老板娘的女儿还是儿子在南洋模范中学读高中，貌似考上了一个不错的大学，然后我妈和老板娘关系还不错，两人经常见面会聊聊天什么的。能够再次见到熟悉的人，心里还是又激动又欣慰的，只可惜我还是没能鼓起勇气上前打招呼，转眼间 3 年过去了，想必她也早已忘记了我了罢。</p><p><img src="https://s2.loli.net/2023/10/02/982ozv7mXAink43.jpg" alt="晾衣杆和桔子酒店"></p><p><img src="https://s2.loli.net/2023/10/02/Faw3nLP981tWqMR.jpg" alt="楼下视角，猜猜我住在几楼"></p><p><img src="https://s2.loli.net/2023/10/02/rjcVMqKO5BD1Isx.jpg" alt="裁缝店"></p><p><img src="https://s2.loli.net/2023/10/02/lfJGbZ2TajwEgVR.jpg" alt="店门上贴的，还是非常有深度的，但小朋友看不看得懂就不好说了"></p><p><img src="https://s2.loli.net/2023/10/02/fFMdHv4EpDo8hsJ.jpg" alt="斜土路的门"></p><h2 id="小插曲"><a href="#小插曲" class="headerlink" title="小插曲"></a>小插曲</h2><p>小插曲，当时我在朋友圈发了卢湾体育场的照片，结果发现 “丁枪” (某同学的“爱称”) 正好在附近买书，于是我与他在 12 号线大木桥路地铁站见面了，然后两人一起(其实是我拉着他)开始了 Dark 的重温童年之旅。</p><h3 id="小学-——-梦的种子"><a href="#小学-——-梦的种子" class="headerlink" title="小学 —— 梦的种子"></a>小学 —— 梦的种子</h3><p>笔者就读于建襄小学，一个笔者经常写错名字的小学。在这个小学里，笔者度过了充满波折但是无比快乐的 5 年。笔者永远不会忘记曾经和小伙伴们一起在里面捉迷藏的经历，也忘不了当年把排球打到了隔壁楼里面然后被老师痛骂的经历。笔者也记得曾经学校的南边的架子下面有一个马蜂窝(可能只是普通的蜂窝，但是当时看熊出没看多了就这么叫了)，后来不知道怎么就没了。笔者也记得每次春游秋游和小伙伴们一起玩 mc 的经历。美好的回忆的碎片几乎是内嵌进了我的脑子里，即使是现在我也无法忘记，仿佛那一幕幕就在我的面前。</p><p>不得不说，我小学班主任 (或者是初中班主任) 有一句话说的很对: “珍惜当前的时光，当你回过头来看这一段时间，你会发现这是你人生中最快乐、轻松的一段的时光。” 现在看来，的确是这样的。时至今日，我依然保有一颗玩耍的心，但是却再也没有玩耍的时间和精力了，即使真的让我去玩，长大的我也一定会因为尴尬而拘谨，完全做不到无拘无束吧。童年的美好回忆大多来自于此。这颗十年前的子弹，飞了这么多年，终于打到了我自己的身上。</p><p>总是要亲自体验过了，才会懂得珍惜。可惜当时的我只知道玩，不过这样反而为我自己留下了一个几乎没被污染的童年，比起那些经常在外补课的人，我觉得我还是非常幸运的。</p><p><img src="https://s2.loli.net/2023/10/02/tm6Iai7QML2Pv8K.jpg" alt="校区变化不大,不过这里本来是给 3 ~ 5 年级的，现在貌似是 1 ~ 2 年级了"></p><h3 id="幼儿园-——-梦的温床"><a href="#幼儿园-——-梦的温床" class="headerlink" title="幼儿园 —— 梦的温床"></a>幼儿园 —— 梦的温床</h3><p>第二站是幼儿园。老实说，我已经完全快忘记关于这些东西了 …… 不过，不可否认的是，在早年接收到的关于爱、关于为人处事的那些教诲，其成为了我初中乃至是高中之前的“人生”信条。那些早年受到的传统教育，也在一定程度上塑造了我这个人的内在人格。说实话，幼年教育真的对我来讲影响深远。每当我反思自己，向内窥探自己的内心，我总是能发现一些曾经的自己的影子，即使在初中高中的时候我曾经无数次的推翻过去的那个自己，尝试走向反向的极端，但到头来，早年的教育还是给我留下了深深的，不可磨灭的烙印，在内心的深处的无意识部分，他们依然会出现 <del>(幻视一个共产主义的幽灵)</del> 。</p><p>在这里，我不会去评价这些教育的好坏，但是可以肯定地一点是，它真的可以说在很大程度上决定了我的人生轨迹。</p><p><img src="https://s2.loli.net/2023/10/02/DPTX3Bn4gJadFvA.jpg" alt="印象真的已经无比模糊了"></p><h3 id="初中-——-梦的启航"><a href="#初中-——-梦的启航" class="headerlink" title="初中 —— 梦的启航"></a>初中 —— 梦的启航</h3><p>初中，可以说是我真正起飞并且转型的地方。在初中之前，我从来都没想过我是怎么样子的一个人。我几乎没有什么竞争的意识，思想上也只是一个孩童罢了，只知道玩。即使家长逼着我去上课，但由于我一直强烈抵抗，所以最后基本都是不了了之了。</p><p>上了初中，我才第一次感受到了压力。那是来自升学的压力: 要考上一个好的高中，才能读一个好的大学，才能有一个好的人生。这大概就是我当时所想的，就是这么的简单朴素。至于为什么，我可从来没有去思考过。但是秉持着这样的信念，我开始了初中的学习生活。有的时候，生活进行下去或许只需要一个信念，对吧……</p><p>初中，我真的学了好多，也接触并深入了解了好多有趣的人，也真正的结交了不少的朋友 (天哪，上次同学聚会居然还有一位记得我当年的 Minecraft ID: DarkSharpness ，我真的差点哭出来)。说到初中，最骄傲的事情就是和某同学 LD 一起 “发明” 并且推广了一个手指游戏 “Finger Glory” ，当时因为一个契机手指游戏 + 职业的玩法火了起来，然后在大家的共同努力下，这个叫做 “Finger Glory” 的手指游戏便火了起来，并且在“良好”的运营下达到了动态的平衡。</p><p>当然 “Finger Glory” 主要是在初二初三的时候流行。在这之前两年，我可能还在某桥牌俱乐部打桥牌，以此作为我平时的消遣。当然，消遣，自然也少不了电脑上的 Minecraft。当时多玩我的世界盒子还没被干掉，我经常和一两位同学一起玩服务器。仍记得当时我在初一的时候每天回家第一件事情，就是趁着家长没回来，赶紧打开电脑，输入早已被我偷看到的密码，然后上服务器玩。当时受到大量台湾实况主的影响，特别喜欢原版生存(当然也会偶尔玩玩 mod ，比如暮色森林，工业 2 之类的比较热门的)，和 jessy5610 (没错，我也记得你的游戏!) 一起在天籁服务器 (我记得是 tl.minemc.cn) 玩原版。虽然玩的真的很一般 (远不如高中的水平) ，但是真的也很开心。快乐就是简单而朴素的。</p><p>初三的时候，时间少了，但是消遣不能少。除了正常的 “Finger Glory”，我开始迷上了化学。说实话，我根本不是一个认真学化学的人，从现在的角度来看，我不过是喜欢化学实验那种直观而震撼的效果罢了，高中以后我的选择也证明了这一点。当然，迷上化学除了化学反应的新奇性，这背后也少不了两位化学老师的帮助。一位是课内的老师，另外一位是外面补课班的老师。我不知道怎么去形容，但是这两位老师成功给我打开了化学的大门，让我对其真的产生了浓厚的兴趣，也成为我喜欢化学试验的导火索。回到正题。初三的时候，我开始做一些化学试验，虽然基本以安全的为主，但偶尔也有危险的，比如电解制氯气(当时一晚上没关电没把我毒死真的是奇迹)，以及学校里混合开水生石灰氯化铵(那次炸的很厉害，氨气直接冲的我眼睛都睁不开，幸好旁边就是厕所赶紧处理掉了，没出大事)。当时我可真的是不怕死，天真可爱。</p><p>所以简单的回顾了以下自己的初中，尽管我遇到了人生路上的第一道坎 —— 中考，它让我真正意义上有了学习的概念，也开始有了明确的奋斗目标(虽然我甚至不知道其意义何在)，但它并没有让我改变太多，我依然如同孩童一样去观察这个世界与世界交互。当然，我也不后悔。这是我自己选择的，我也的确度过了一个快乐而完整的童年 (事实上升学的压力直到初二下我才真正有感受到)，也真的第一次结交到了一些一辈子的知心朋友。</p><p><img src="https://s2.loli.net/2023/10/02/cJOgbtwz52o9RFy.jpg" alt="顺路拍的，以前一位初中好友 LD 就住在这里"></p><p><img src="https://s2.loli.net/2023/10/02/or1OxsFguvdH8zf.jpg" alt="徐家汇附近还是热闹啊"></p><p><img src="https://s2.loli.net/2023/10/02/YkTKXySlZ25UFDP.jpg" alt=""></p><p><img src="https://s2.loli.net/2023/10/02/ZirOYzS7m4R3gjw.jpg" alt=""></p><p><img src="https://s2.loli.net/2023/10/02/ESi2xo1jnNAML7F.jpg" alt=""></p><p><img src="https://s2.loli.net/2023/10/02/CB41YhL3VMsWUyA.jpg" alt="到达! 徐汇中学!"></p><h2 id="Ending"><a href="#Ending" class="headerlink" title="Ending"></a>Ending</h2><p>最后和 “丁枪” 同学在漕宝路地铁站告别了，然后我就独自骑回了上中附近(当时还住在那边)。感谢一路陪伴 !</p><p>距离这次的旅途，其实也过去半年多了。其实我也早就想要写了，奈何自己还是太摆了，加上大大小小的事情确实也不少，所以拖到了现在。只能说，这的确是一次非常有意义的旅途，不过当时我没想那么多的说，光顾着重温当年的那些美好回忆去了 (即使现在，坐在电脑前的我看到这些照片，心中依然会涌起一阵情绪) 。</p><h1 id="Ending-1"><a href="#Ending-1" class="headerlink" title="Ending"></a>Ending</h1><p>好了差不多该结束了，写到这里语言逻辑都已经错乱了。挑了几个比较有感触的活动写了写，自己写完也是非常激动的哈，希望不要只是单纯的自我感动，有机会还是多思考思考吧。</p><p>最后的最后，感谢您能阅读到这里! 如果你有什么想说的，欢迎在下面评论区留言，也算是支持一下我了，给我更多的动力。感谢!</p>]]></content>
    
    
    <summary type="html">不知道该说啥，又是胡言乱语的一天</summary>
    
    
    
    <category term="随笔" scheme="http://darksharpness.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="总结" scheme="http://darksharpness.github.io/categories/%E9%9A%8F%E7%AC%94/%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="随笔" scheme="http://darksharpness.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>CP29 Day1 一日游</title>
    <link href="http://darksharpness.github.io/CP29/"/>
    <id>http://darksharpness.github.io/CP29/</id>
    <published>2023-05-02T12:22:36.000Z</published>
    <updated>2023-05-02T13:42:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>文笔不好，仅作个人游记，希望在互联网能有点存在感罢了。</p><p>多图预警! 有能力挂个梯子/加速器 qwq.</p><h1 id="入场"><a href="#入场" class="headerlink" title="入场"></a>入场</h1><p>前一天晚上就已经听闻了 CP29 的游客数量特别恐怖，于是一大早(其实 6:30 很晚了) 就起床从你交打车去了国家会展中心。</p><p>老实说，在进去之前，我都没想过会有这么多的人，少见的能在这么狭小的空间内见到这么多灵长类动物(笑)。</p><p><img src="https://s2.loli.net/2023/05/02/kiJ8hdAnarqWSeo.jpg" alt="下车等红绿灯ing"></p><p><img src="https://s2.loli.net/2023/05/02/yaBjAs3GT8zD9xO.jpg" alt="刚见到队伍"></p><p><img src="https://s2.loli.net/2023/05/02/Dm2ZdVPrej1pIou.jpg" alt="7:31,第一次到3,4区,记住!后面要考"></p><p><img src="https://s2.loli.net/2023/05/02/F3Yzm4MWrVePRSL.jpg" alt="开始发现不对劲的 DarkSharpness 和 abelcat"></p><p>小插曲: Dark 和 smarthehe 前后几乎只差了 2min ，但是最后 Dark 却比 smarthehe 晚进场了半个小时多。高中的大哥 (hjh同学) 比我晚到了 10 min，结果比我晚进场了快 2.5 h。所以合理推测: 早期排队 1min 人流量 = 15min 过安检人流量。难怪后面安检直接破防了，干脆不查了直接放人进去了。</p><p><img src="https://s2.loli.net/2023/05/02/ARgG3LXDdY5Tm19.jpg" alt="8:23,此时刚排队20min,问就是排错了一次,队尾太不明显了"></p><p><img src="https://s2.loli.net/2023/05/02/Sz8wL1ojHDR9mbA.jpg" alt="8:51,才刚到天桥下"></p><p><img src="https://s2.loli.net/2023/05/02/8LJfUnYmubkK2CP.jpg" alt="9:04,回到了开始的地方"></p><p>小插曲: 在一路上见到了许多的东方爱好者和 coser，感觉都好可爱捏。作为一个前莉莉厨，特地拍下了这一只令人印象深刻的，大只莉莉白!</p><p><img src="https://s2.loli.net/2023/05/02/i8DC5OGUMLoSHc1.jpg" alt="9:15,大只莉莉白"></p><p><img src="https://s2.loli.net/2023/05/02/XtIPQopSzbefalk.jpg" alt="9:24,希望人没事,身体第一(虽然Dark也是嗑药硬撑)"></p><p><img src="https://s2.loli.net/2023/05/02/ofENDUQiAuTBICV.jpg" alt="9:28,过转角,发现内侧道路显著快于中外"></p><p><img src="https://s2.loli.net/2023/05/02/9CAOnwh1LpM683g.jpg" alt="10:20,终于到一楼缓冲区了,death rush(错乱)!"></p><p><img src="https://s2.loli.net/2023/05/02/FWJR4NDz5yliYtP.jpg" alt="10:21,我测,这么密集,玉玉了"></p><p>接下来是 Dark 最破防的一段时间，smarthehe 已经进去了，而我面前还有一个漫长的队伍，甚至没见动弹。雪上加霜的是，旁边的保安放人规则很抽象，导致我们后面有些人反而跑到前面去了。说实话，在来之前，我已经预料到了会有此类小小的不公平的现象，我也已经打好预防针绝对不会急。然而实际利益受损，加上各种别人比你更优，我还是 pdf (破大防) <del>(泼大粪,指模拟野兽先辈发出怒吼)(下次可以试试看cos 先辈)</del> 了。</p><p>好在后面队伍移动还是很快的，心态马上平衡了。在经过了体感一亿年的等待后，终于上坡了(从一楼缓冲区走向二楼)。看着坡下的人，还是感慨万千捏。在大约一个小时多前，我也是下面的一员，憧憬着美好的漫展 <del>(Touhou-only)</del> 。不过，我还是不想要像之前之前坡上某些人那样，嘲讽下面人，这样确实不太好，还是不要把自己的负面情绪发泄到他人身上。<del>(先辈叫不算发泄到他人拉，是一起发泄)</del></p><p><img src="https://s2.loli.net/2023/05/02/e9Ms61jEgK5tcb7.jpg" alt="10:50,终于上坡了"></p><p><img src="https://s2.loli.net/2023/05/02/Yi83gHKvBVDydtG.jpg" alt="10:51,上坡时候激动的人群"></p><p><img src="https://s2.loli.net/2023/05/02/wgf6rMZz1Wxo3m9.jpg" alt="10:52,隔着围栏也能看到里面的情况"></p><h1 id="游览"><a href="#游览" class="headerlink" title="游览"></a>游览</h1><p>我的游览过程很无聊，主要想看看 LL(love live) , Vocaloid 和 东方 展区，买完核心后瞎逛逛。然而，最后还是基本集中在了东方展区，后面也将着重介绍车万展区。</p><p>由于笔者线上社牛但线下社恐，所以没敢找 coser 拍照或找人搭话，一直被人忽略，也没敢拍几张照片 (毕竟展区说了不让拍，我是个守规矩的公民捏)。不过摊主和游客们的强烈热情还是不难感受到的。</p><p><img src="https://s2.loli.net/2023/05/02/Yj1Fu2396dkypav.jpg" alt="11:00,到达展区!!!"></p><p>第一个逛的就是车万展区。不得不说你车居然还能独占一个巨大的区域，真的是挺出乎意料的的，期待 THO 会比现在人更多。</p><p>进场后直奔壹甲 60 二重不眠症的摊位。说实话，作为一个从他们建队就开始听的老粉丝，也确实应该买点实体专支持一下了，总不能一直在网易云音乐白嫖吧(笑)。最后买了 <a href="https://music.163.com/album?id=145225520">Helicon</a> 一张专，还顺带买了个鼠标垫(正好，不用买新的了)，以及两个拨片(话说我又不会吉他，为啥要买捏?)。期待新专 + 演出。</p><p><img src="https://s2.loli.net/2023/05/02/EPxg4DoTsn1yeLM.jpg" alt="11:20 收下了!"></p><p><img src="https://s2.loli.net/2023/05/02/qpMoRw79AZg1W6r.jpg" alt="晚上开箱! 孩子很喜欢"></p><p><img src="https://s2.loli.net/2023/05/02/zkOx9XrG6taZFUn.jpg" alt="鼠标垫很漂亮,就是阻力有点大,需要适应下(笑)"></p><p>随后逛了逛其他东方的店铺，主要帮同学和自己买了些周边，以及四个抱枕😍。当时从kk的店里面出来，感觉路人看我如看变态一样(笑)，<del>本来就是呀</del>。笑死了，想太多了，根本没人在乎你。</p><p><img src="https://s2.loli.net/2023/05/02/97bwUCFkBAEqQDr.jpg" alt="特地克制了点,避免陷入消费主义的陷阱"></p><p><img src="https://s2.loli.net/2023/05/02/5tq3VvRhacuOGbw.jpg" alt="抱枕,但两个是 hsfzLZH1 的"></p><p>然后帮 zhuoyue 买了些 V 周边，顺便逛了逛。笔者对 V 一直处于感兴趣，但是不深入坑的边缘状态，也不知道为什么，只有车万一下子就把我拉下水了。或许是车万的幻想属性，抓住了我大脑一片空白的那段时候(初三)，抑或是一个意外罢了。</p><p><img src="https://s2.loli.net/2023/05/02/a4qbifPVecUT1k8.jpg" alt="12:24"></p><p><img src="https://s2.loli.net/2023/05/02/eljnpcLKV2h4Y9Q.jpg" alt="看起来少,但是好™的重啊"></p><p>小插曲，见到了囧仙本人。由于太社恐，只敢偷拍捏。囧仙可爱捏，不过感觉好大一只，感觉三个我都打不过(误)。</p><p><img src="https://s2.loli.net/2023/05/02/1tgKd4NJUAwl2Za.jpg" alt="12:34,😍"></p><p><img src="https://s2.loli.net/2023/05/02/QL2dxbZETyIcS5t.jpg" alt="12:51,又见"></p><p>后面就是和 smarthehe 和他的同学们，以及我可爱的高中同学屌哥，大哥，MisakaVan，鼎汉，tzy 等人面基了。可惜的是照片没拍，不过最美好的回忆已经存在脑子里了捏 (人体硬盘)。</p><h1 id="润"><a href="#润" class="headerlink" title="润!"></a>润!</h1><p><img src="https://s2.loli.net/2023/05/02/IXGMziuDvtB63hY.jpg" alt="全部货物"></p><p>总消费控制在了 250 以内，取得阶段性胜利。不过帮同学搬运东西还是挺累的，东西好重，幸好包装得下，我也习惯了包里面一堆重物。</p><p>总结不想写不会写，因为作者阅历不足，头脑单线条。总之，各位辛苦了，Dark 玩的很开心，终于能支持一波自己喜欢的一些同人作者了捏，也终于感觉到真正地融入到了东方同人这个群体中，有参与感了捏。</p>]]></content>
    
    
    <summary type="html">关于 CP29 Day1 游览的一些个人情绪。</summary>
    
    
    
    <category term="随笔" scheme="http://darksharpness.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="随笔" scheme="http://darksharpness.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>关于 Minecraft Impart 服务器</title>
    <link href="http://darksharpness.github.io/mcImpart/"/>
    <id>http://darksharpness.github.io/mcImpart/</id>
    <published>2023-04-09T08:12:36.000Z</published>
    <updated>2023-06-05T06:56:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>2023 年 2 月，大一下学期刚开学。由于开学实在是太无聊了，于是在一群同学商量之后，便有了 Minecraft Impart 服务器。原始 idea 由 photoshopcc 和 chayso 想出 (疑似)，而服务器主体由 photoshopcc 维护 (其实就是租了一个服务器)。</p><h1 id="Impart-0-周目"><a href="#Impart-0-周目" class="headerlink" title="Impart 0 周目"></a>Impart 0 周目</h1><p>在最初的时候，Impart 只是一个生存 only 的 minecraft 服务器。当然，单纯的原版生存实在是太简单了，于是笔者便提议在原版的基础下做出了如下这些的改动:</p><ol><li>死亡掉落，而且保持永夜。</li><li>允许死后 tp 回到死亡位置捡尸。</li></ol><p>一开始，大家都玩的很开心。大家没有很强地目的性，只不过在随便跑跑图、杀杀怪物、偶尔下矿之类的，并没有很一个明确的目标(比如打龙或者pvp竞争)，大家也都玩的很开心。不过如此单调的游戏玩法还是持续不了太久，大概就过了1 ~ 2 天，大家就决定干点有意义的事，例如去打龙。在众人的努力下，龙很快就被打掉了，而没过多久，大家也都拿到了鞘翅。</p><p>问题再次出现: 在打完龙以后，还有什么有意义的事情值得我们去做吗 ? 这个问题其实不仅仅发生在 Impart , 在千千万万个服务器里面，玩家或多或少地都会遇到这样的问题。在打完龙、杀完凋、造完自己温馨的小家之后，你是否还有想过之后的路该怎么走 ? Minecraft 是一个极其开放的游戏，而也正因如此，玩家面多无限的选择的时候往往会变得不知所措。</p><p>笔者 DarkSharpness 的建议是去搞生存电路，研究红石电路之类的，但是这实在是太肝了，再加上后面两周学业负担逐渐加重，导致了 Impart 服务器最终关闭，Impart 0 周目至此落下帷幕。</p><p>这次企划只持续了短短一周，便在不知所措中草草收尾。笔者也由此不禁开始反思，究竟是 Minecraft 里面的什么吸引着我一直去玩它 ，而又是为什么，我们会不再被其所吸引 ? Minecraft 本身是一个极其开放的游戏，其有着几乎无限的可能。然而，许多玩家在通关以后却会茫然不知所措。笔者认为，这背后其实是一个游玩目的缺失。围绕着游戏的主线 —— 生存和成就 去玩的确是一种常见的玩法，但是主线任务是有限的，这相当于把游戏无限的可能局限在了一个很小的范围，自然容易让人厌烦。</p><h1 id="Impart-1-6-周目"><a href="#Impart-1-6-周目" class="headerlink" title="Impart 1 ~ 6 周目"></a>Impart 1 ~ 6 周目</h1><p>由于缺乏足够的记录 <del>其实笔者懒得翻记录，哼</del> ，所以前几周的活动就没具体记录了haha。</p><p>新的 Impart 企划 : EHC (Easy hardcore)，由笔者 (DarkSharpness) 发起，灵感来源是台湾实况主的那些 <a href="https://www.bilibili.com/video/BV1JW41137Jn/">UHC 活动</a> ，说起来也是挺怀念的。主要规则类似 UHC ，不过由于大家都太菜了，为了更好的游戏体验所以变成了允许回血(后续甚至允许复活)。具体规则看最后的附录。活动时间固定在周末前一天的晚上，当然其他时候偶尔也有加赛。</p><p>前几周大家都玩的非常不熟，经常会出现前 10 分钟就死一片的现象，也出现过各种搞笑的失误，比如珍珠飞出边界被挤压死、矿洞被僵尸灭队、被细雪干死、被猪灵蛮兵干死之类的。由于大家打的都挺菜的，所以玩的也很开心。</p><p>中间几周，大家都逐渐熟练起来，打法也逐渐趋向稳定。常见打法有直冲钻石层、矿洞速破、鱼骨到死，这个打法主要是 photoshopcc 和其他大部分人在用，效率挺高，不出意外的话，一个小时半可以钻石全套。DarkSharpness 本人一般喜欢走地狱打法，因为 Dark 本人之前玩过些速通 (玩的一坨答辩) ，对于地狱比较熟 (貌似基本上除了 Dark 以及其队员也没人去地狱)，所以敢于大胆冲。这种打法略吃运气，需要通过猪灵交易获得大量的光灵箭和丝，如果没有猪堡会非常难受。当然，自从 photoshopcc 和 xun_ying123 等人某次被 Dark 的装备压制打到绝望以后，大家也都意识到了装备压制的重要性，因此开始注重堆附魔，甚至是钓鱼等附魔书。</p><p>当然，中间几周，我们也尝试了 bingo 这个玩法，前几次 bingo 玩的还是很开心，不过玩多了确实容易腻。就我个人而言，我还是喜欢吃中长期策略发育的 EHC，这更加不吃运气，考验的是发育速度和原版游戏理解。</p><p>在第 4 周或是第 5 周的时候，一件事情极大的改变了游戏的进程 —— 重生锚。是的，Dark 凭借多年的水晶<del>外挂端</del>pvp的经验，拿出了原版大杀器，重生锚。其伤害在困难模式下可以稳定秒杀正常发育下任意装甲的人。在这周及后面一周的比赛中，重生锚两次出现，直接将 3 个满血玩家直接炸死，这惊动了我们所有人。考虑到这个东西实在是太破坏原版 pvp 的趣味性了，所以，在商榷之后，我们决定在 60min(即不能复活后) 为每个玩家发放一本爆炸保护 IV 的附魔书，并且将游戏难度下调至 normal。</p><p>最后两周，离谱的事情接踵而至，首先是我和 photoshopcc 各自拿到了一个附魔金苹果，然后 photoshopcc 又找到了一本力量 V 的附魔书，而最后一次甚至我和 photoshopcc 各自找到了一个古城 (虽然我这个古城穷成伞兵)。考虑到这些都是小概率事件，其实也不是不能接受，但是离谱还是真的离谱。</p><p><del>由于星穹铁道的影响，服务器快倒闭了，没玩家了，速来 qq 群: 808813297</del></p><h1 id="Impart-的未来-何去何从"><a href="#Impart-的未来-何去何从" class="headerlink" title="Impart 的未来,何去何从"></a>Impart 的未来,何去何从</h1><p>现在是 2023 年 6 月 4 号。Impart 已经顺利地度过了前 11 周目。目前，服务器的 EHC 项目的指令部分已经就几乎完成，经过了两周的测试之后也基本稳定。本学期基本已经结束，Impart 的活动恐怕也要告一段落了。</p><p>在暑假，由于愚蠢的 PPCA 项目，我们将不得不在学校待到 8 月份。好消息是，伴随着 <a href="https://github.com/xunying123">xun_ying</a> 的装机，我们暑期服务器有着落了，平时可以开着台式电脑，作为常用服务器。</p><p>因此，DarkSharpness 首先的规划是开一个中长期的生存档，具体内容可以是原版养老，也可以玩红石(生存电路/数字电路)，也可以玩玩建筑和跑酷什么的。当然，既然暑假有一点时间，Dark 也考虑过玩某些大型的 pve 地图，例如 Terra Restore。说起来，它可是承载了我半个初中的回忆啊，那时候一下课就回家打开电视，看搬运的舞秋风的大地复苏(Terra Restore)的视频。当然，大型的景观类生存地图，也是很不错的啦!</p><p>然后呢，Dark 还计划开一个小游戏项目。除了 Impart 的保留节目 EHC，可以重拾 manhunt,bingo,parkour tower 这些经典项目。当然，Dark 也想引入一些更加新颖的小游戏，例如烟花弩 pvp，又比如说mc fps(快速填充 V 的秒射箭)，或者是火球 pvp，鞘翅 pvp 等等……</p><p>值得一提的是，在这段时间里面，我也认识了 lytDark，另外一个服务器的腐竹。他们服务器也没人，所以现在有在打算合并(真的不是吞并吗)两个服务器啦……</p><p>总之，期待一下新的 Impart !</p><h1 id="Rules"><a href="#Rules" class="headerlink" title="Rules"></a>Rules</h1><p>具体规则请转向 <a href="https://github.com/DarkSharpness/DarkSharpness/blob/main/Game/Minecraft/Impart/rules.md">Github</a>。</p><p>如有问题或补充，欢迎在评论区留言!</p>]]></content>
    
    
    <summary type="html">Minecraft Impart 服务器的历史，以及活动策划的心路历程回忆录。</summary>
    
    
    
    <category term="Minecraft" scheme="http://darksharpness.github.io/categories/Minecraft/"/>
    
    <category term="服务器" scheme="http://darksharpness.github.io/categories/Minecraft/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
    <category term="随笔" scheme="http://darksharpness.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="Minecraft" scheme="http://darksharpness.github.io/tags/Minecraft/"/>
    
  </entry>
  
  <entry>
    <title>二项堆复杂度报告</title>
    <link href="http://darksharpness.github.io/BinoHeap/"/>
    <id>http://darksharpness.github.io/BinoHeap/</id>
    <published>2023-03-15T00:02:16.000Z</published>
    <updated>2023-03-15T07:30:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>前言: 二项堆复杂度分析是真的水。由于 DarkSharpness 实在是太懒了，所以图片全部来自 Wikipedia(所以要挂梯子).</p><p>先立个 Flag ，不用势能分析<del>(才不是不会呢)</del></p><p><strong>请不要用深色模式浏览本页，请点击右下角设置切换，否则图片会看不清</strong></p><p><strong>请不要用深色模式浏览本页，请点击右下角设置切换，否则图片会看不清</strong></p><p><strong>请不要用深色模式浏览本页，请点击右下角设置切换，否则图片会看不清</strong></p><h1 id="二项树"><a href="#二项树" class="headerlink" title="二项树"></a>二项树</h1><p>二项树如下递归定义:</p><p>$0$ 度的二项树只有 $1$ 个节点</p><p>$k(k \gt 0)$ 度的二项树包含 $1$ 个根节点，根节点下面有度数分别为 $k-1,k-2,\dots,0$ 的二项树，如图是一颗度数为 $0 ~ 3$ 的二项树:</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/c/cf/Binomial_Trees.svg" alt="(来自wikipedia)"></p><p>不难发现，一颗度数为 $k (k \ge 0)$ 的二项树有恰好 $2^k$ 个节点。也不难发现，合并两颗度数为 $k (k\ge 0)$ 的二叉树，我们只需将其中一颗树连接到另外一棵树的根节点下面，便可以得到一颗度数为 $k + 1$ 的树，理论上一次 merge 只需要最坏 $O(1)$ 的时间。</p><h1 id="二项堆"><a href="#二项堆" class="headerlink" title="二项堆"></a>二项堆</h1><p>二项堆是基于二项树实现的，每颗树维护一个堆结构，节点之间的连接可以用链表实现。本文默认分析的是小根堆，大根堆同理。<del>还是不会就爬。</del></p><p><strong>*特别提示: 本文提到的常数指的是指 复杂度表达式 f(n) 前面的系数，例如复杂度f(n) = O(n) 常数为 2 指的是</strong></p><script type="math/tex; mode=display">\lim_{n\rightarrow\infty} \frac{f(n)}{n} = 2</script><h2 id="基本性质"><a href="#基本性质" class="headerlink" title="基本性质"></a>基本性质</h2><p>对于一个二项堆，其存储了一些二项树，满足这些树的度数两两不相等，且每颗树及其子树满足堆结构，即节点是树中值最小的节点。</p><p>注意到一个度数为 $k$ 的二项树有恰好 $2^k$ 个节点，所以假设当前二项堆节点数量的二进制表示为 $\sum_{i=0}^n {a_i \cdot 2^i} (a_i = 0 \ or \ 1)$ (后文用 ${ a_n }$ 简记)，那么当前二项堆有一颗度数为 $i$ 的子树，当且仅当 $a_i = 1$ 。例如一个有 11 个节点的二项树，由于 11 的二进制表示为 $11 = (1011)_2$ ，那么这颗二项堆恰有度数为 $0,1,3$ 的三颗子树。</p><p>显然地，一个有 $n$ 个节点的二项堆，其含有的二项树的数量最多为 $\log_2(n) + 1$ 个，二项树的度数也不会超过 $\log_2(n)$.</p><h2 id="合并两棵树"><a href="#合并两棵树" class="headerlink" title="合并两棵树"></a>合并两棵树</h2><p>合并两棵树和之前提到的 merge 操作基本一致，不过需要特别注意，由于每颗树维护的是堆结构，因此我们需要把根节点值更大的树的根节点 连接到 根节点值更小的根节点下面，此时不难验证依然满足堆的性质。如下所示:</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/9/9f/Binomial_heap_merge1.svg/800px-Binomial_heap_merge1.svg.png" alt="合并节点"></p><p>显然地，该操作的最坏时间复杂度为 $O(1)$，常数取决于一次值比较所需的时间。</p><p><strong>我们称之为 merge_tree 操作</strong>.</p><h2 id="合并两个堆"><a href="#合并两个堆" class="headerlink" title="合并两个堆"></a>合并两个堆</h2><p>合并两个堆的过程类似两个整数的加法过程:</p><p>假设两个堆节点数的二进制表示分别为 ${a_n},{b_m}$ (特别地，对于 $i \gt n$ ，$a_i$ 记为 0)，那么合并过程大致如下，类似正整数加法:</p><p>首先合并两个二项堆 度数为 0 的二项树。如果当前只有 0 或 1 颗 度数为 0 的二项树，那么保留当前的 0 或 1 颗树，不用合并。如果当前有 2 颗 度数为 0 的二项树，那么合并为 1 颗 度数为 1 的二项树。此时，我们认为，合并完了两个二项堆度数 $&lt; 1$ 的二项树。</p><p>然后，假设已经合并完了两个二项堆 度数 $ &lt; k$ 的 二项树，那么此时，最多会有 1(第一个堆) + 1(第二个堆) + 1(下面合并产生的) 颗度数为 $k$ 的二项树 。类似地，当度数为 $k$ 的二项树总数为 0 或 1，那么什么都不做。如果总数为 2 或 3，那么随机合并其中两颗，合并出一颗度数为 $k + 1$ 的树。此时，合并完成了两个二项堆度数 $ &lt; k + 1 $ 的二项树。</p><p>不难发现，只有当两个堆的节点数，在从低到高二进制加法中出现进位的时候，才会执行 merge_tree 操作。例如当一个节点数为 7 的树和 一个节点数为 5 的树合并，我们首先写出两者的二进制表示 $7 = (111)_2 \ ,\  5=(101)_2 $。因此其执行的合并操作如下:</p><p>首先合并两个堆的 2 个度数为 0 的两颗二项树，得到 1 个 度数为 1 的二项树。再将其和第一个堆度数为 1 的二项树合并，得到一个度数为 2 的 二项树。现在，我们得到了三颗 度数为 2 的二项树，我们随机合并其中两颗，保留剩下那颗度数为 2 的二项树，得到一颗度数为 3 的二项树。最后，我们只有一颗度数未合并，而单独一颗无需处理。至此，操作结束，得到了 1 颗度数为 2 的二项树 和 一颗度数为 3 的二项树。再对比两个数字的二进制加法，最低位置 1 + 1 进位 一个 1 ，留下的是 0 。第二位 1 + 0 + 1(进位) ，进位一个 1 ，留下一个 0 。第三位 1 + 1 + 1(进位)，进位一个 1 ，留下一个 1 。最后最高位保留一个 1，结束计算。</p><p>很直观地可以看出，合并的次数等于节点数二进制加法时进位次数，而这样的操作最多会执行 $\log_2(n + m)$ 次。</p><p>因此，该操作的最坏时间复杂度为 $O(\log(n + m))$，常数取决于一次值比较所需的时间。</p><p><strong>我们称之为 merge_heap 操作</strong>。</p><h2 id="查询最小值"><a href="#查询最小值" class="headerlink" title="查询最小值"></a>查询最小值</h2><p>为了便于复杂度证明以及后续展开，这里先分析查询最小值的时间复杂度。</p><p>查询最小值，一个朴素的办法就是将每颗树的值最小的节点 (即根节点) 两两比较，假设当前二项堆节点数为 $n$ ，那么最多比较次数不会超过 $\log_2 n$ ，即查询最坏复杂度为 $O(\log n)$ ，常数取决于一次值比较所需的时间。</p><p>这样的实现显然是不友好的。事实上，我们可以进行针对性优化，我们保留一个指向最小值的指针。</p><p>每次插入一个节点的时候，我们只需额外比较一次插入值和当前最小值的大小，指针指向更小的那一个即可。这会给插入一个节点带来 $O(1)$ 的额外开销，常数取决于一次值比较所需的时间。</p><p>每次删除一个最小值节点的时候，我们等删除结束后再用朴素方法维护得到最小值的指针即可。这会给删除一个节点带来 $O(\log n) $ 的额外开销，常数取决于一次值比较所需的时间。</p><p>此时，查询最小值只需访问一次指针即可，查询最坏复杂度为 $O(1)$ 。</p><p><strong>我们称之为 top 操作</strong>。</p><h2 id="删除最小值节点"><a href="#删除最小值节点" class="headerlink" title="删除最小值节点"></a>删除最小值节点</h2><p>由前面的查询最小值操作，我们多维护了一个指向最小值的指针，从而避免了查询最小值的高开销，将其部分均摊到了插入和删除操作上。</p><p>借助这个指向最小值的指针，我们可以按如下方法实现删除最小值节点:</p><p>最小值节点必然是一颗二项树的根节点，我们将这个二项树从二项堆中拿出来，得到一个由单独的二项树构成的二项堆，和原来的二项堆。假设原来的二项堆有 $n$ 个节点，我们新建的二项堆含有的是一颗度数为 $k (k \le log_2n)$ 的二项树。</p><p>此时，我们删除新生成的二项堆的根节点，由定义，断开该节点相连的边以后，我们会得到度数分别为 $k-1,k-2,…,0$ 的 k 颗二项树，将其记为最新的二项堆。此时，我们将最新的二项堆和旧的二项堆合并即可，即可以用 merge_heap 操作解决。</p><p>最后，别忘了还有更新最小值指针的 $O(\log n)$ 的额外开销。</p><p>因此，由前面的分析，我们容易知道，删除所需的最坏时间复杂度为 $O(\log (n + 2^k) ) + O(\log n) = O(\log n)$ ，常数取决于一次值比较所需的时间。</p><p><strong>我们称之为 pop 操作</strong>。</p><h2 id="插入一个节点"><a href="#插入一个节点" class="headerlink" title="插入一个节点"></a>插入一个节点</h2><p>插入一个节点的过程简单来说如下:</p><ol><li>将单节点作为 仅含一个度数为 0 的二项树 的二项堆。</li><li>合并当前堆和新生成的二项堆。</li></ol><p>由前面对于合并堆的分析，我们不难看出，该操作所需的 merge_tree 操作次数取决于 $n$ 和 $1$ 做加法时候的进位次数，最坏时间复杂度为 $O(\log n)$ ，常数取决于一次值比较所需的时间。</p><p>但是若仅仅只有插入操作，那么假设一开始的节点数量为 $n$ ，进行了 $k$ 次连续的插入操作。分析单次加法操作，设 $x$ 和 $y$ 进行一次加法，$x$ 的二进制表示数位和 (后简称为数位和) 为 $s_x$ ，$y$ 的数位和为 $s_y$，若加法中进行了 $z$ 次进位，那么最后 $x + y$ 的数位和为 $s_x + s_y - z$ 。</p><p>因此从 $n$ 每次加一加到 $n + k$，设 $n$ 的数位和为 $s_1$，设 $n + k$ 的数位和为 $s_2$ ，而中间 $k$ 次加一，数位总和为 $k \times 1 = k$，因此进位次数为 $k + s_1 - s_2$ ，而易知，$s_1 \le \log_2 (n) + 1$ 。</p><p>因此，从节点数 $n$ 开始，连续插入 k 次的最坏时间复杂度为 $O(\log n + k)$ ，叠加上维护最小值的开销 $O(1)$，单次操作的平均最坏复杂度为</p><script type="math/tex; mode=display">O(\frac {\log {n}}{k} + 1) + O(1) = O(\frac {\log {n}}{k} + 1)</script><p>当 $k$ 足够大，或者初始 $n$ 足够小，或者 $k$ 和 $\log n$ 同一个数量级，那么单次只需要均摊 $O(1)$ 次的 merge_tree 操作 ，单次复杂度可以降低到 $O(1)$ 。</p><p>因此，单次插入操作的均摊复杂度为 $O(1)$ ，常数取决于连续插入次数 $k$ 、初始节点数 $n$ 以及一次值比较所需的时间。</p><p><strong>我们称之为 push 操作。</strong></p><h2 id="减小最小值"><a href="#减小最小值" class="headerlink" title="减小最小值"></a>减小最小值</h2><p>直接简化为一次删除 + 一次插入即可。易得最坏时间复杂度 $O(\log n)$，常数取决于一次值比较所需的时间。</p><p><strong>我们称之为 decrease_key 操作。</strong></p><h2 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h2><p>拷贝构造函数，可以通过遍历一遍节点，在 $O(m)$ 的时间内完成，其中 m 为被拷贝的二项堆的节点个数。。</p><p>析构函数，只需遍历一遍每个节点，在 $O(n)$ 的时间内完成，其中 n 为被拷贝的二项堆的节点个数。</p><p>拷贝赋值函数，可以通过先析构当前函数，再拷贝构造来实现。这样实现的时间复杂度为 $O(n + m)$ ，其中 n 为当前二项堆的节点个数，m 为被拷贝的二项堆的节点个数。</p><p>*如果实现了移动构造函数 (after C++ 11)，那么移动构造只需移走待移动对象的指针，所以时间复杂度为 $O(1)$ 。类似地，移动赋值函数只需在原地移动构造前先析构当前函数，因此其时间复杂度为 $O(n)$ (仅析构)。</p><h1 id="就这"><a href="#就这" class="headerlink" title="就这?"></a>就这?</h1><blockquote><p>就这? 你是啥fw? —— DarkSharpness</p></blockquote><p>如果在 push 中，夹杂了一些 pop / decrease_key / merge_heap 操作 (显然穿插 top 是只读函数，不改变堆的结构，不会影响均摊复杂度)，那还能保证单次插入均摊时间复杂度为 $O(1)$ 吗? 当然可以，回到之前的定义，初始 $n$ 个节点，连续插入 k 次的最坏时间复杂度为 $O(\log n + k)$ 。</p><p>*后文 merge 若无特殊指明，指代 merge_heap</p><h2 id="Decrease-key"><a href="#Decrease-key" class="headerlink" title="Decrease-key"></a>Decrease-key</h2><p>对于穿插的一次 decrease_key 操作，其本质上也不会改变堆的元素数量，拥有某个度数的二项树的情况和操作之前完全一致 (例如原本 3 个节点，只有度数为 0 和 1 的二项树，drecrease_key，那么新的二项堆，也只有度数为 0 和 1 的二项树)。因此，对于 push 的均摊分析完全没有影响。</p><h2 id="Pop-only"><a href="#Pop-only" class="headerlink" title="Pop-only"></a>Pop-only</h2><p>先不考虑 merge ，只考虑 pop。对于穿插的一次 pop 操作，设当前节点数为 $m$，若这次操作前面或之后存在一次 push 是节点数 $m - 1$ 增长到 $m$ ，我们可认为两次操作抵消掉，并且由于 push 单次最坏时间复杂度为 $O(\log n)$ ，我们可以把 push 的时间复杂度分摊到相抵消的 pop 上，pop 的最坏时间复杂度依然是 $O(\log n) + O(\log n) = O(\log n)$ ，但此时对应 push 的复杂度分摊给了 pop 降低为 O(1)。容易证明:</p><ul><li>当 push 次数不超过 pop 的次数的时候，每次节点数从 $m  - 1$ 上升为 $m$ 的 push 操作必然会对应一次节点数从 $m$ 下降的 $m - 1$ pop 操作。此时，每次 push 的复杂度都分摊给了 pop ，因此 pop 依然是最坏 $O(\log n)$ ，但是 push 降低为了均摊 $O(1)$。</li><li>当 push 次数超过 pop 的此时，每次节点数从 $m$ 下降的 $m - 1$ pop 操作必然会对应一次节点数从 $m  - 1$ 上升为 $m$ 的 push 操作，假设节点数从 $n$ 上升到了 $n + t$，push 了  $k = t + d \ (d \ge 0)$ 次，即有 d 次 抵消操作，那么所有 push 的最坏总复杂度为 $O(\log n + t) + d \times O(1) = O(\log n + k)$ ，类似之前 push 的分析，易得 pop 依然是最坏 $O(\log n)$ ，push 均摊 $O(1)$ 。</li></ul><p>总之，混杂了 pop 以后，push 操作依然可以均摊 $O(1)$ ，不过是把部分复杂度摊给了 pop 罢了。</p><blockquote><p>哪有什么岁月静好，不过是有人替你负重前行。</p></blockquote><h2 id="Merge-only"><a href="#Merge-only" class="headerlink" title="Merge-only"></a>Merge-only</h2><p>现在，我们只考虑 merge，不考虑 pop 操作。假设 merge 了 $m$ 次，push 了 $k$ 次，最后得到的堆的节点数为 $n$ 。那么，总操作的时间复杂度取决于 merge_tree 进行了多少次 (因此 merge_heap 和 push 的实现本质都是借助 merge_tree) 。因此，我们依然只需分析进位了多少次，假设 merge 的其他的二项堆的数位和 (前面说过了，默认二进制下的) 分别为 $s_1,s_2\dots s_m$ 的，堆的大小为 $x_1,x_2\dots x_m$，设初始节点数 $n_0$ 数位和为 $A$，最终节点数 $n$ 的数位和为 $B$ 。由此可知，进位数量最多为</p><script type="math/tex; mode=display">(\sum_{i = 1}^{m}{s_i}) + k + A - B。</script><p>注意到 $s_i \le \log_2(x_i + 1)$，因此有</p><script type="math/tex; mode=display">\sum_{i = 1}^{m}{s_i} \le \log_2(\prod_{i = 1}^m{(x_i + 1)}) \le \log_2 \{ {(\frac{\sum_{i=1}^{m}(x_i + 1)}{m}) ^ m} \} \le m\log_2(1 + \frac n m)</script><p>然后，发现这么搞做不出来…</p><blockquote><p>你是fvv —— DarkSharpness</p></blockquote><p>好吧，其实再认真看这一条:</p><script type="math/tex; mode=display">(\sum_{i = 1}^{m}{s_i}) + k + A - B。</script><p>以及，$s_i \le \log_2(x_i + 1)$ …… 等一下! 每一次两个节点数为 $n_1$ 和 $n_2$ 的二项堆的合并操作要求地最坏复杂度为 $O(\log (n_1 + n_2)) $ 。 因此对于每个 $s_i$ 次 merge_tree 的操作，我们可以将其直接分摊到 merge_heap 操作上。此时，不难发现，第 i 次合并的时间复杂度为 $\log_2(x_i + 1) \times O(1) \le O(\log (n_1 + n_2))$ ，没有破坏 merge 的性质，而分给 k 次 push 操作的总复杂度最坏为 $\log n_0 + k$，其中 $n_0$ 为初始节点数。因此，类似之前 push 的分析，我们可以得到 : push 操作依然是均摊 $O(1)$ 的时间复杂度。</p><blockquote><p>哪有什么岁月静好，不过是另外还有一个人替你负重前行。</p></blockquote><h2 id="Pop-Merge"><a href="#Pop-Merge" class="headerlink" title="Pop + Merge"></a>Pop + Merge</h2><p>pop 和 merge 操作结合起来其实也差不多，借用前面单独分析情况的思想即可。我们只需要考虑依然只要考虑二进制下数位和的变化即可。假设连续 k 次插入操作，穿插了一些删除操作，和合并操作。假设删除前的数字为 $y_i$，那么删除后，数位最多减少 $\log_2 y_i$ 。而假设合并的数为 $s_i$，那么最多进位 $\log_2 s_i$ 次。类似地，设初始节点数数位和为 $A$，最终节点数的数位和为 $B$。那么最终进位次数不会超过</p><script type="math/tex; mode=display">\sum_i{\log_2 y_i}+ \sum_i{s_i} + k + A - B</script><p>我们可以把每一项 $\log_2{y_i}$ 平摊到每次的 pop，而每一项 $s_i$ 平摊到 merge 操作上。借用前面的 pop-only 和 merge-only 的分析，我们不难得出，这不会破坏两者最坏 $O(\log n)$ 的性质。因此，此时，假设初始节点数为 n ，那么插入 k 次后，push 分到的最坏总复杂度为 $O(k + \log n)$ 。因此，借用前面的 push 的证明，我们可以得知，该情况下， push 操作的均摊复杂度为 $O(1)$ 。</p><blockquote><p>哪有什么岁月静好，不过是另外有一群人替你负重前行。</p></blockquote><h1 id="ENDING-总结"><a href="#ENDING-总结" class="headerlink" title="ENDING + 总结"></a>ENDING + 总结</h1><p>总结下来，无论怎样的操作顺序，push 的均摊复杂度为 $O(1)$ ，同时依然保证 pop 、decrease_key 和 merge_heap 是 $O(\log n)$ 的最坏复杂度。而拷贝构造、移动赋值，移动构造则是线性的最坏复杂度，移动构造是常数的复杂度。</p><p>文章水完了，不值得一看。认真分析还得用势能分析法，将二进制数位和作为势能即可。</p><p>感谢您浪费了 10 多分钟，看这篇乐色、没用势能分析法分析的文章。</p>]]></content>
    
    
    <summary type="html">学校的作业罢了，没啥好看的。</summary>
    
    
    
    <category term="算法" scheme="http://darksharpness.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="树形结构" scheme="http://darksharpness.github.io/categories/%E7%AE%97%E6%B3%95/%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84/"/>
    
    <category term="堆" scheme="http://darksharpness.github.io/categories/%E7%AE%97%E6%B3%95/%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84/%E5%A0%86/"/>
    
    
    <category term="树形结构" scheme="http://darksharpness.github.io/tags/%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84/"/>
    
    <category term="堆" scheme="http://darksharpness.github.io/tags/%E5%A0%86/"/>
    
  </entry>
  
</feed>
