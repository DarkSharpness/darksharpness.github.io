<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Compiler for Mx* 编译器随笔 | DarkSharpness's Dougeon</title><meta name="author" content="DarkSharpness"><meta name="copyright" content="DarkSharpness"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="一个简单语言的编译器的实现">
<meta property="og:type" content="article">
<meta property="og:title" content="Compiler for Mx* 编译器随笔">
<meta property="og:url" content="http://darksharpness.github.io/CompilerMx/index.html">
<meta property="og:site_name" content="DarkSharpness&#39;s Dougeon">
<meta property="og:description" content="一个简单语言的编译器的实现">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s3.bmp.ovh/imgs/2023/12/22/178d87936dac3770.png">
<meta property="article:published_time" content="2023-09-29T04:48:43.000Z">
<meta property="article:modified_time" content="2024-03-02T08:11:28.000Z">
<meta property="article:author" content="DarkSharpness">
<meta property="article:tag" content="编译器">
<meta property="article:tag" content="优化">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s3.bmp.ovh/imgs/2023/12/22/178d87936dac3770.png"><link rel="shortcut icon" href="https://s2.loli.net/2023/01/28/SnEi2v9sdczUuyG.png"><link rel="canonical" href="http://darksharpness.github.io/CompilerMx/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')
          
          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isAnchor: true,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Compiler for Mx* 编译器随笔',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><link rel="stylesheet" href="/css/user.css"><link rel="stylesheet" href="/css/font.css"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="DarkSharpness's Dougeon" type="application/atom+xml">
</head><body><div id="web_bg" style="background: black;"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2023/01/28/SnEi2v9sdczUuyG.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">31</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">24</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">24</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 文章</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-ellipsis-h"></i><span> 杂物</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/photo/"><i class="fa-fw fas fa-image"></i><span> 图床</span></a></li><li><a class="site-page child" href="/diary/"><i class="fa-fw fas fa-book"></i><span> 日记</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://s3.bmp.ovh/imgs/2023/12/22/178d87936dac3770.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2023/01/28/SnEi2v9sdczUuyG.png" alt="Logo"><span class="site-name">DarkSharpness's Dougeon</span></a><a class="nav-page-title" href="/"><span class="site-name">Compiler for Mx* 编译器随笔</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 文章</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-ellipsis-h"></i><span> 杂物</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/photo/"><i class="fa-fw fas fa-image"></i><span> 图床</span></a></li><li><a class="site-page child" href="/diary/"><i class="fa-fw fas fa-book"></i><span> 日记</span></a></li></ul></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Compiler for Mx* 编译器随笔</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-09-29T04:48:43.000Z" title="发表于 2023-09-29 12:48:43">2023-09-29</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-03-02T08:11:28.000Z" title="更新于 2024-03-02 16:11:28">2024-03-02</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BC%96%E8%AF%91%E5%99%A8/">编译器</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>26分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>注: 本文于 2024-03-02 更新循环相关优化部分，其他部分稍作修改。</p>
<p>课程要求，写了一个简单语言 Mx* 的编译器，语法规则<a target="_blank" rel="noopener" href="https://github.com/ACMClassCourses/Compiler-Design-Implementation">请点击这里</a> 。笔者写的很烂，而且项目还烂尾了，所以不放自己写的链接了。</p>
<p>其简单来说是一个残疾版 Java + C ，拥有类似 Java 的对象模型，所有 class 都是引用类型 (笔者汇编实现其实就是指针)，且有最基本的构造函数和成员函数 ，但没有复杂的面向对象特性 (比如继承，虚函数等等) ，甚至连常见关键词如 static 什么的都没有。当然，解决一些简单的问题还是绰绰有余的。</p>
<p>编译器最后生成汇编代码的目标平台是 RISC-V 32bit, Integer Extended , 测评使用的是 <a target="_blank" rel="noopener" href="https://github.com/Engineev/ravel">ravel 模拟器</a> <del>不过bug(feature)还不少</del> 。</p>
<h1 id="AST"><a href="#AST" class="headerlink" title="AST"></a>AST</h1><p>笔者前端使用的是 antlr ，通过自己编写 g4 实现 Lexer/Parser 的功能 ，基本属于是自动生成。这部分个人感觉难度不高，除了语法检查有很多细枝末节要考虑，其他基本没啥值得讲的。不过其实在这一部分，其实已经有可以优化的空间了，例如对于无副作用的一些恒等表达式，以及无用的数组 new 。当然，由于笔者实在是没空，在 AST 上我没有做任何优化。</p>
<h1 id="IR"><a href="#IR" class="headerlink" title="IR"></a>IR</h1><p>IR 上的优化可以说是编译器优化的核心。可以说我 90% 的优化都是作用在 IR 上的。</p>
<p>笔者的 IR 采用的是简化版本的 llvm IR (至少生成的.ll 可以用 clang 编译运行且不会出错)。下面将会简单讲讲笔者在 IR 上具体写了那些玄学优化，以及计划(但实际没写)的那些优化。</p>
<h2 id="mem2reg-SSA"><a href="#mem2reg-SSA" class="headerlink" title="mem2reg-SSA"></a>mem2reg-SSA</h2><p>前置知识: <a target="_blank" rel="noopener" href="https://oi-wiki.org/graph/dominator-tree/">支配树</a> 。</p>
<p>SSA(Static single assign) 是指满足虚拟寄存器只会被被单一赋值的 IR ，在 SSA 上，许多的优化可以被简化，且时间复杂度会更优。显然，内存是不能也不需要保证 SSA 的。而局部变量，其可能被多次赋值，不一定能满足 SSA 的条件，所以在生成 IR 的时候一般会用 alloc 申请栈空间用于其值的存储。</p>
<p>但是实际上，很多时候，寄存器是充足的，我们期望可以把局部变量的值放在寄存器(在 IR 中呈现为虚拟寄存器) 里面，从而避免了高开销的内存读写操作。但是前面也说了，局部变量可以被重复赋值，比如在不同分支中有不同的取值，导致不一定能放入虚拟寄存器。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">bool</span> cond)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> z;</span><br><span class="line">    <span class="keyword">if</span>(cond) &#123;</span><br><span class="line">        z = <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        z = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是，mem2reg 为我们提供了一种消除 SSA 形式 IR 中部分 alloc 的方法。其思路大致如下:</p>
<p>我们把每条指令看作图中的一个节点。除了分支指令有两个后继 (即出边)，其他指令有唯一后继。如果一个局部变量 x 在一条指令的位置被赋值，那么在这条指令所支配 (此处指的是支配树的支配关系) 的范围内，在下一次被赋值之前，其值不会改变，这是由支配树的性质所保证的。但是在其支配边界上，到达该位置的 x 可能就不止来自这个方向的赋值。还可能存在其他方向的赋值，这也很符合支配 “边界” 的直观。为了保险起见，我们要根据其来的方向，为这个 “边界” 上的指令进行值合并。在这里，llvm IR 为我们提供了一个工具函数: phi 函数。其不是真正的函数调用(call) 指令，其作用是根据跳转的分支为一个变量赋值。例如，对于上面那段 C++ 代码，其可以生成类似如下的 llvm IR 代码:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">entry:</span><br><span class="line">    br i1 %cond-0, label %if-0-true-0, label %if-0-false-0</span><br><span class="line"></span><br><span class="line">if-0-true-0:</span><br><span class="line">    br label %if-0-end</span><br><span class="line"></span><br><span class="line">if-0-false-0:</span><br><span class="line">    br label %if-0-end</span><br><span class="line"></span><br><span class="line">if-0-end:</span><br><span class="line">    %z-1.mem.0 = phi i32 [ 1 , %if-0-true-0 ] , [ 2 , %if-0-false-0 ]</span><br><span class="line">    ret i32 %z-1.mem.0</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>简而言之，phi 函数可以用来合并来自不同分支的赋值，类似维护了变量的不同版本，从而保证了 SSA 的形式。这也带来了 mem2reg 这一优化，其可以把所有没有被取地址，且不是 volatile 的局部变量转化为虚拟寄存器，进而消除相关的 load/store。由于 Mx* 的语言特性，其天然不存在取地址，因此所有天然的 alloca 理论上都能被消除，</p>
<p>mem2reg 首先建立一个函数的控制流图，然后对于所有的局部变量 (alloca 产生)，对每个对这个局部变量的赋值 (目前只含 store 指令)，我们在其支配边界标记插入关于该变量的 phi 函数 (注意，phi 函数也是关于这个变量的赋值。我的解决方案是先处理原来的 store，第二遍再处理 phi 产生的赋值)。</p>
<p>通过扫描，我们容易确定每个块结束后，一个局部变量在当前块结束时候的值。对于每个新插入的 phi 以及其对应的原本的局部变量 x ，我们只需去每个前驱块或许该局部变量的值并且填入 phi 即可。</p>
<p>当然，既然讲到了 phi 函数，就需要特别地说明一下，phi 函数的赋值是并行进行的，即一个块里面所有 phi 同时赋值，例如下面的 两个 phi 语句会交换 x 和 y 的值 (当从 %BB1 跳过来的时候):</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%x = phi i32 [ 0 , %entry ] , [ %y , %BB1 ]</span><br><span class="line">%y = phi i32 [ 1 , %entry ] , [ %y , %BB1 ]</span><br></pre></td></tr></table></figure>
<p>在后文的关于 IR 优化讨论中，我们都假定是在 SSA 形式的 IR 上进行。</p>
<h2 id="DCE-amp-ADCE"><a href="#DCE-amp-ADCE" class="headerlink" title="DCE&amp;ADCE"></a>DCE&amp;ADCE</h2><p>死代码消除是一个非常常见的优化。在程序中，难免会出现一些无效的死代码。事实上，在上一步 mem2reg 之后，由于其保守地在每个支配边界都会插入 phi，这可能会导致出现一些无效的 phi (即结果在后面用不到，但是由于 mem2reg 维护了变量在每个块的不同版本，保证正确性，因此插入了不必要的 phi)。这时候，死代码消除就能很好的简化生成的 IR 。</p>
<p>死代码消除有很多种，笔者想出的一个最基础的版本大致如下:</p>
<ul>
<li>没被标记为副作用的指令都是无用的。</li>
<li>有副作用的指令用到的变量，其定值(因为 SSA ，所以有且仅有一次定值(即被定义)) 语句是有副作用的。</li>
<li>内置的 IO 函数 / 存在全局影响的函数 是有副作用的</li>
<li>store  指令认为是有副作用的</li>
<li>branch 指令认为是有副作用的</li>
<li>return 指令认为有副作用的</li>
</ul>
<p>通过沿着 def-use 链条前向传播 (依赖 SSA!)，我们可以在线性时间内确定所有的活指令，从而删除死指令。这个死代码消除相当的 naive ，也不能消除空循环这种无效代码，不过好处是其跑的非常快，只需要线性的时间很小的常数就能跑完，且不会修改控制流图，因此被我用来作为其他所有优化结束后顺便跑掉的一个 pass 。</p>
<p>真正的死代码消除，应该能够识别那些没有副作用的分支，从而把那些无效分支清除干净 (包括死循环) 。事实上，基础版本的死代码优化对于分支估计还是过于保守。ADCE (Aggressive Dead Code Elimination) ，可以通过控制流图分析来确定那些有效的分支，不过需要的是反向流图的支配关系。过程大致如下:</p>
<ul>
<li>所有基本块初始认为是死的</li>
<li>有副作用的指令的块都是活块</li>
<li>内置的 IO 函数 / 存在全局影响的函数 是有副作用的</li>
<li>store  指令认为是有副作用的</li>
<li>return 指令认为是有副作用的</li>
<li>jump   指令到活块认为是有副作用</li>
<li>branch 指令，只有当其处于某个活块的反向支配边界上，其才是存活的。</li>
</ul>
<p>ADCE 比起 DCE，虽然依赖反向流图的支配关系 (这个东西的建立特别费时) ，但是可以消除那些无效的分支 (例如空循环或无效循环)，的确对的上 “Aggressive” 这个名字。</p>
<h2 id="SCCP"><a href="#SCCP" class="headerlink" title="SCCP"></a>SCCP</h2><p>常量传播也是非常常见的一个优化。其<del>降低程序员的心智负担，让其大胆写出更多烂代码</del>主要是优化一些表示常数的变量(其实就是临时寄存器)<del>所以为什么不引入 const</del> ，将其在使用处直接替换为对应的常数，这便是最基本的常量传播。</p>
<p>当然，如果两个 SSA 的变量表示相同的数值 (例如 x = y + 0，显然 x = y)，那么显然我们也可以把 x 在所有使用处替换为 y 。注意，其正确性其实并不 trivial。SSA 要求每个变量只能在其支配的基本块内出现，x 支配的块 y 也一定支配，这并不 trivial 。但是注意到 x = y + 0 ，说明 y 必然支配 x 所在位置，因此 x 所支配的块 y 也必然支配 (看看支配的定义即可)。</p>
<p>对于分支和 phi 函数，常量传播依然可以进行下去: 我们先从入口出发。如果遇到 phi 函数，我们先按照来的方向给赋值，如果之后从别的方向来并产生了矛盾，那么再标记这个值不是常量 (或者其他固定值) 。如果遇到一个分支，显然，branch 语句的 condition 的值肯定已经确定是常量或者不是常量。如果是常量，我们就根据 condition 走对应的分支。如果不是常量，我们只能假定两个分支都会走。</p>
<p>因此，常量传播流程大致如下:</p>
<p>首先标记所有的变量 (临时寄存器) 的状态为未知。变量状态有三种: 未知(Unknown) ， 已知 (Known，必须是常量或者其他固定值)，非常量 (Non-const)。状态合并规则如下:</p>
<ul>
<li>Unknown   + any   = any.</li>
<li>Non-const + any   = Non-const</li>
<li>Known_i + Known_i = Known_i</li>
<li>Known_i + Known_j = Non-const (i,j 不同)</li>
</ul>
<p>然后，我们从入口出发(把入口加入块的工作列表 work_list_1)。</p>
<p>对于 work_list_1 的块，我们按顺序遍历当前工作的块。对于 jump 指令，我们将其目标块加入 work_list_1。对于 branch ，按照之前所讲处理即可。对于其他语句，我们正常进行赋值，并且将 赋值结果 与 结果变量的当前状态 进行合并。如果发现合并结果发生改变，那么我们把这个变量所有被使用的地方(指令)加入 work_list_2 (指令工作列表)。</p>
<p>对于 work_list_2 的指令，我们尝试对其重新计算，并且将 赋值结果 与 结果变量的当前状态 进行合并。如果发生改变，那么类似地，那么我们把这个变量所有被使用的地方(指令)加入 work_list_2 。</p>
<p>我们一直执行，直到两个 work_list 都被清空。由于状态合并最多改变两次 (Unknown-&gt;known-&gt;non_const 的过程是单向不可逆)，所以不用担心该操作的复杂度爆炸。不过要特别注意的是，我们沿着某一条边进入一个块，遍历一个块的所有语句，这个操作只会执行至多一次，因为后面如果产生了更新，那么肯定会通过 work_list_2 更新过来，所以不用再 visit 一遍。而同时，一个块除了 phi 语句之外的其他语句至多只需要 visit 一遍，在第二次从 work_list_1 取出的时候，只需要重新 visit 那些 phi 函数就行了。如果存在依赖的改变，那么自然会从 work_list_2 更新过来；如果不存在依赖 (比如两个常数的和) ，那么第一次 visit 的时候的结果就自然是正确的了。</p>
<p>这部分的证明还是不难但也不 trivial 的，建议读者自行思考各种 corner case 下的正确性。如果有任何疑问，可以参考<a target="_blank" rel="noopener" href="https://dl.acm.org/doi/pdf/10.1145/103135.103136">原始论文</a>。(不过主体部分还是很好想到的，事实上笔者一开始基本就是按照自己的理解搓了一个几乎差不多的 SCCP，不过论文还考虑了各种优化，包括哪些只 visit 一次，的确人类智慧)。</p>
<h2 id="CFG"><a href="#CFG" class="headerlink" title="CFG"></a>CFG</h2><p>流图化简，即 CFG 上的化简，是一个完全由我自己构思的优化 (其实是没看到类似的论文 <del>其实还是懒得找</del> )。其可以尽可能地消除无效的 jump ，同时消除部分 phi 语句 (不过笔者还没 100% 实现)。</p>
<h3 id="Jump-Elimination"><a href="#Jump-Elimination" class="headerlink" title="Jump-Elimination"></a>Jump-Elimination</h3><p>在前面这几个不痛不痒的小优化之后，我们会发现出现了很多基本块的体积减少了一点，很多甚至只剩下一个 jump 语句。在极端的情况下，我们可以看到一堆由连续重复 jump 指令，例如:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">BB0:</span><br><span class="line">    br label BB4</span><br><span class="line">BB1:</span><br><span class="line">    br label BB2</span><br><span class="line">BB2:</span><br><span class="line">    br label BB3</span><br><span class="line">BB3:</span><br><span class="line">    br label BB4</span><br><span class="line">BB4:</span><br><span class="line">    br label exit</span><br><span class="line">exit:</span><br><span class="line">    ret void</span><br></pre></td></tr></table></figure>
<p>事实上，这些无效的 jump 都可以被直接压缩为一条语句: <code>ret void</code> 。你可能觉得这不过是常数级别的优化。的确，jump 的确太快了，这些优化显得略有点没用。但是如果 jump 多达几百个呢，这好像就不仅仅是常数了吧。</p>
<h3 id="Condition-Phi-Elimination"><a href="#Condition-Phi-Elimination" class="headerlink" title="Condition-Phi-Elimination"></a>Condition-Phi-Elimination</h3><p>考虑如下语句:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BB2:</span><br><span class="line">    %cond = phi i1 [ false , %BB0 ] , [ true , %BB1 ]</span><br><span class="line">    br i1 %cond BB2, label %BB3, label %BB4</span><br></pre></td></tr></table></figure>
<p>如果从 %BB0 过来，那么显然只会跳到 %BB4 。如果 %cond 只在当前条件语句被使用到，那么我们甚至可以直接消除这个 %cond 变量，将这个条件分支直接压缩没了。要知道条件分支对于现代 CPU 的流水线可是一个很糟糕的东西，分支预测错误可是会带来流水线的中断等一系列后果，其速度很慢。因此，我们可以考虑把条件分支顺便也压缩了。</p>
<h3 id="Tail-Phi-Elimination"><a href="#Tail-Phi-Elimination" class="headerlink" title="Tail-Phi-Elimination"></a>Tail-Phi-Elimination</h3><p>特别地，如果一个 phi 语句后面紧跟 ret 语句，那么显然其与 ret 的返回值相关(否则，之前的死代码消除将会干碎这个无效 phi)。那么，我们可以把当前块拆开，不同块跳过来的时候直接 return 不同的值。这个操作几乎无法消除多少 phi ，看起来没啥大用处，但是其可以为尾递归优化留下空间。考虑以下的 C++ 代码:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">tail</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n &lt; <span class="number">0</span> ? n : <span class="built_in">tail</span>(n - <span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在正常的 IR 生成中，我们会用 phi 来合并三目运算符的结果。但是这并不利于尾递归优化。当我们手动拆开 phi，相当于将原来的 C++ 代码拆成如下形式:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">tail</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">tail</span>(n - <span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显然，这种形式的代码看起来就可以尾递归优化 (甚至是再把尾递归优化为循环)。这也是这个优化的另一个好处。</p>
<h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>以上就是我个人想到的 CFG 上几处小优化。Jump-Elimination 可用于清除并简化其他优化之后复杂的流图，Condition-Phi-Elimination 则对于 复杂短路逻辑表达式 的优化有奇效，Tail-Phi-Elimination 则能帮助尾递归优化。</p>
<h2 id="Local-optimization"><a href="#Local-optimization" class="headerlink" title="Local-optimization"></a>Local-optimization</h2><p>这里面涉及了很多块内的优化。这些优化不需要复杂的控制流图，只需要逐块分析即可，不过全是人类智慧。当然，该优化其实可以 global 化，但是由于笔者实在是太累了，所以暂时只写了局部的版本。</p>
<h3 id="Arithmetic-Simplification"><a href="#Arithmetic-Simplification" class="headerlink" title="Arithmetic-Simplification"></a>Arithmetic-Simplification</h3><p>算术化简是最常见的一个优化了。在 IR 层级，能做的算术化简其实已经所剩无几了。换句话说，该优化其实本应该在 AST 就做掉不少，至少笔者是这么认为的。</p>
<p>尽管 IR 上处处受限，但是我们依然可以发现以下这些比较 trivial 的表达式优化 (以下摘自笔者的破烂代码的注释):</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Swap operands if the left one is a constant</span></span><br><span class="line"><span class="comment"> * for those symmetric operators: + * &amp; | ^ </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Strength reduction and replacement:</span></span><br><span class="line"><span class="comment"> * X - C        --&gt; X + (-C)</span></span><br><span class="line"><span class="comment"> * X + X        --&gt; X &lt;&lt; 1</span></span><br><span class="line"><span class="comment"> * X * pow(2,n) --&gt; X &lt;&lt; n</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Negative elimination rule:</span></span><br><span class="line"><span class="comment"> * 0 - Y        --&gt; (-Y)</span></span><br><span class="line"><span class="comment"> * X + (-Y)     --&gt; X - Y</span></span><br><span class="line"><span class="comment"> * (-Y) + X     --&gt; X - Y</span></span><br><span class="line"><span class="comment"> * X - (-Y)     --&gt; X + Y</span></span><br><span class="line"><span class="comment"> * (-X) * C     --&gt; X * (-C)    // iff non-power-of-2 C</span></span><br><span class="line"><span class="comment"> * (-X) * (-Y)  --&gt; X * Y</span></span><br><span class="line"><span class="comment"> * (-X) / C     --&gt; X / (-C)</span></span><br><span class="line"><span class="comment"> * C / (-X)     --&gt; (-C) / X</span></span><br><span class="line"><span class="comment"> * (-X) / (-Y)  --&gt; X / Y</span></span><br><span class="line"><span class="comment"> * X % (-Y)     --&gt; X % Y</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Merge operators to try generate deadcode (to be removed~):</span></span><br><span class="line"><span class="comment"> *  Bitwise:</span></span><br><span class="line"><span class="comment"> * (X &amp; C1) &amp; C2    --&gt; X &amp; (C1 &amp; C2)</span></span><br><span class="line"><span class="comment"> * (X | C1) | C2    --&gt; X | (C1 | C2)</span></span><br><span class="line"><span class="comment"> * (X ^ C1) ^ C2    --&gt; X ^ (C1 ^ C2)</span></span><br><span class="line"><span class="comment"> *  Add or Sub:</span></span><br><span class="line"><span class="comment"> * (X + C1) + C2    --&gt; X + (C1 + C2)</span></span><br><span class="line"><span class="comment"> * (X - C1) + C2    --&gt; X + (C2 - C1)</span></span><br><span class="line"><span class="comment"> *  Mult or Div:</span></span><br><span class="line"><span class="comment"> * (X &lt;&lt; C1) * C2   --&gt; X * (C2 &lt;&lt; C1)</span></span><br><span class="line"><span class="comment"> * (X *  C1) * C2   --&gt; X * (C1 * C2)</span></span><br><span class="line"><span class="comment"> * (X *  C1) / C2   --&gt; X * (C1 / C2)        // iff C2 divides C1</span></span><br><span class="line"><span class="comment"> * (X *  C1) % C2   --&gt; 0 + 0 = 0            // iff C2 divides C1</span></span><br><span class="line"><span class="comment"> * (X &lt;&lt; C1) % C2   --&gt; 0 + 0 = 0            // iff C2 divides pow(2,C1)</span></span><br><span class="line"><span class="comment"> *  Shift:</span></span><br><span class="line"><span class="comment"> * (X &lt;&lt; C1) &lt;&lt; C2  --&gt; X &lt;&lt; (C1 + C2)</span></span><br><span class="line"><span class="comment"> * (X &gt;&gt; C1) &gt;&gt; C2  --&gt; X &gt;&gt; (C1 + C2)</span></span><br><span class="line"><span class="comment"> * (X &lt;&lt; C1) &gt;&gt; C2  --&gt; X &lt;&lt; (C1 - C2) or X &gt;&gt; (C2 - C1)</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Special case in merging operators.</span></span><br><span class="line"><span class="comment"> * (C1 - X) + C2    --&gt; (C1 + C2) - X</span></span><br><span class="line"><span class="comment"> * C1 - (X + C2)    --&gt; (C1 - C2) - X</span></span><br><span class="line"><span class="comment"> * C1 - (C2 - X)    --&gt; (C1 - C2) + X</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Maybe I will write this: (Actually not).</span></span><br><span class="line"><span class="comment"> * (0 - X) / X      --&gt; 0 + -1 = -1</span></span><br><span class="line"><span class="comment"> * (0 - X) % X      --&gt; 0 + 0 = 0</span></span><br><span class="line"><span class="comment"> * X / (0 - X)      --&gt; 0 + -1 = -1</span></span><br><span class="line"><span class="comment"> * X % (0 - X)      --&gt; 0 + 0 = 0</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Special case for non-constant test:</span></span><br><span class="line"><span class="comment"> * (X ^ Y) ^ X      --&gt; Y + 0 = Y</span></span><br><span class="line"><span class="comment"> * (X | Y) &amp; X      --&gt; X + 0 = X</span></span><br><span class="line"><span class="comment"> * (X &amp; Y) | X      --&gt; X + 0 = X</span></span><br><span class="line"><span class="comment"> * (X | Y) | X      --&gt; X | Y</span></span><br><span class="line"><span class="comment"> * (X &amp; Y) &amp; X      --&gt; X &amp; Y</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * (X - Y) + Y      --&gt; X + 0 = X</span></span><br><span class="line"><span class="comment"> * (X + Y) - X      --&gt; Y + 0 = Y</span></span><br><span class="line"><span class="comment"> * (X * Y) / X      --&gt; Y + 0 = Y</span></span><br><span class="line"><span class="comment"> * (X * Y) % X      --&gt; 0 + 0 = 0</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Negative generation rule:</span></span><br><span class="line"><span class="comment"> * 0 - X        --&gt; (-X)</span></span><br><span class="line"><span class="comment"> * X * (-1)     --&gt; (-X)</span></span><br><span class="line"><span class="comment"> * X / (-1)     --&gt; (-X)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>这些优化单独来看几乎没啥用，但是结合其他的会有奇效。</p>
<h3 id="CSE"><a href="#CSE" class="headerlink" title="CSE"></a>CSE</h3><p>公共子表达式消除是一个常见的优化。对于公共子表达式，我们可以用前者在后者使用处替换。但是，这并不一定是好事情。因为如果这个计算过程是非常廉价的，且计算结果的寿命并不长，那么你重复使用第一次的计算结果，可能会导致一个无效的寄存器占用，甚至不如每次都重新计算。不过由于是在块内，所以一般来说还是 ok 的，不会带来过多的副作用。</p>
<h3 id="UB-elimination"><a href="#UB-elimination" class="headerlink" title="UB-elimination"></a>UB-elimination</h3><p>在代码优化的过程中，我们可能会遇到一些含有未定义行为的语句。例如: 整数除以 0 ，一个没有控制流的基本块 (常见于函数无返回值)，读写空指针…… 由于我们可以假定程序是正确的，因此我们可以直接消除这些未定义行为的语句，但这是远远不够的。事实上，到达这些基本块的途径都应当是非法的 (因为假定没有未定义行为)，因此，我们可以把这个基本块从控制流图中直接移除。</p>
<p>具体流程大致如下: 首先标记所有含 UB 的块为不可达。然后直接分析控制流图，其中入口为第一个基本块，出口为所有含 return 的基本块。我们分别从出口/入口进行 bfs/dfs 。只有当一个块可以从入口到达，并且可以从出口到达，我们才认为这个块是可达的。最后，我们把所有不可达的块从控制流图中移除。</p>
<p>特别地，对于那些跳往不可达块的分支，需要把分支转化为无条件跳转。同时，对于 phi 节点中不可达块跳过来的那个格子，其也需要被清空。简而言之，注意下细节即可。</p>
<h3 id="Load-Store-tracing"><a href="#Load-Store-tracing" class="headerlink" title="Load/Store tracing"></a>Load/Store tracing</h3><p>这个技术其实理论上需要用到更加复杂内存追踪技术，例如 equalSet 什么的，但是笔者实在是太忙了，所以没写这么多。笔者实现的简单版本如下:</p>
<p>核心思路是维护同一个地址的 load 和 store ，同一个地址后面的 load 一定是上一次 store 的结果。只有当出现了地址可能重叠的 store ，我们才认为这个位置的 load 是不安全。当然，由于 Mx<em> 里面不存在 reinterpret_cast, void </em> 等危险指针操作，所有类型都是可以追溯的，因此我们可以根据 load/store 的类型来判断是否安全。同时，如果 load/store 的是一个类的成员，那么同一个类的不同成员的地址也是不会重叠的。如果不能保证不会重叠，那么我们只能做最坏假设: 认为已经重叠，该值可能失效。当然，全局变量之间肯定不会重叠。因为没有取地址操作，这也使得整个优化可以变得更加激进一些，不用考虑各种阴间 corner cases.</p>
<h2 id="Inlining"><a href="#Inlining" class="headerlink" title="Inlining"></a>Inlining</h2><p>inline 是老熟人了，这里也就不多说啥了，简单来说就是把部分函数代码内嵌到当前位置。不过，inline 还是有不少细节的 (花了我整整6个小时的说) 。首先是要跑函数调用图。由于函数之间可能会互相调用，因此我们需要先用 tarjan 算法缩点，把那些环形的调用关系缩成一个点。在此之后，函数调用图 call-graph 满足 DAG 。我们可以在 DAG 上按照拓扑序逐一 inline 各个函数。当然，每次 inline 完，我们也需要跑一遍优化 pass，因为 inline 完往往能产生新的优化点。例如:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123; <span class="keyword">return</span> x + y; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">100</span>;</span><br><span class="line">    <span class="type">int</span> y = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">add</span>(x,-y); <span class="comment">// inline + 常量传播直接变成 90</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="loop-related"><a href="#loop-related" class="headerlink" title="loop-related"></a>loop-related</h2><p>由于 Dark 有空了,这一部分又出来了。</p>
<p>在寒假中，笔者重构了自己的编译器。</p>
<h3 id="loop-nest-tree"><a href="#loop-nest-tree" class="headerlink" title="loop-nest-tree"></a>loop-nest-tree</h3><p>首先，需要获得循环信息。<del>一个简单可行的方法是直接在 build IR 的时候往标准块上记录一些 metadata</del> 对于一个 general 的 natural loop (换句话说，没有 goto 带来一些奇怪的控制流)，其有这些显著特征:</p>
<ul>
<li>循环的入口唯一存在，称作 loop header。其支配了所有循环内的块。</li>
<li>循环必定存在至少一个 back-edge，即从循环体的某个块跳到 loop header。</li>
<li>循环之间要么嵌套，要么完全不相交。</li>
</ul>
<p>因此，我们可以简单的寻找所有的 back-edge (即从一个块 A ，跳到一个支配块 A 的块 B) ，记录所有的 B ，即为所有的 loop header，同时把 A 记录为 loop body 的一部分。然后，对于所有的 loop header ，我们从目前 loop body 开始，沿着 <strong>反向流图</strong> bfs/dfs ，直到遇到 loop header ，这样我们就找到了这个循环所有的 loop body 块。</p>
<p>循环之间可能存在嵌套关系，我们可以用一个树形结构来表征这种关系。注意到，两个循环只可能嵌套或完全不相交，不存在其他的情况。因此，我们之前得到的 loop body 两两之间，要么一个完全被另一个包含，要么完全不相交。通过简单的枚举 (但实际笔者的实践借助了支配关系稍稍优化) 即可构建出嵌套关系的树，即为 loop-nest-tree 。</p>
<h3 id="loop-invariant-code-motion"><a href="#loop-invariant-code-motion" class="headerlink" title="loop-invariant-code-motion"></a>loop-invariant-code-motion</h3><p>事实上，笔者并没有写这个，而是实现了一个更加 general 的 pass: global code motion。具体细节可参考那篇经典的 GCM/GVN 的论文。</p>
<p>回想一下所谓的 LICM ，其所做的不过是把一些语句移动到了其他的地方。而之所以可以这么做，是因为在 SSA 形式上，只要一个语句 use 在到达这个语句之前都已经被定义了，其即为合法。除了内存操作/函数调用/输入输出 等含有副作用的语句，其他语句都是可以安全的交换顺序，只要满足了合法性。因此，我们可以考虑激进地移动部分语句。</p>
<p>具体而言，我们先固定那些含副作用的语句 (load/store/call/控制流相关)，然后根据 use-&gt;def 关系后序去遍历所有的指令，确定每个语句可以被定义的最早的位置 (以基本块为单位)。对于任意基本块 A 中某一语句，我们只需保证该语句所有的 use，其所被定义时所在的块支配了块 A 即可。这个过程被称作 scheduleEarly，伪代码如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">scheduleEarly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">markFixed</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> block : blocks)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> inst : block-&gt;insts)</span><br><span class="line">            <span class="built_in">dfs</span>(inst);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">markFixed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> block : blocks)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> inst : block-&gt;insts)</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isFixed</span>(inst))</span><br><span class="line">                first[inst] = block;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                first[inst] = entry;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Post-order dfs.</span></span><br><span class="line"><span class="comment"> * First work out all uses of an inst.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(instruction *inst)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isFixed</span>(inst)) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (visited[inst]) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    visited[inst] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">auto</span> block = entry;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> use : inst-&gt;uses) &#123; </span><br><span class="line">        <span class="built_in">dfs</span>(use);</span><br><span class="line">        <span class="comment">// Choose the deepest one in the dominator tree.</span></span><br><span class="line">        <span class="keyword">if</span> (first[use]-&gt;depth &gt; block-&gt;depth)</span><br><span class="line">            block = first[use];</span><br><span class="line">    &#125;</span><br><span class="line">    first[inst] = block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同理，我们也可以对应的 scheduleLate，即为确定每个语句可以被定义的最晚的位置。我们只需根据 def-&gt;use 关系，保证 def 被用到的地方都被 def 所在的块所支配即可。换言之，def 所在块是其所有 use 可以处于的最晚的块的 LCA (最近公共祖先) 即可，代码几乎完全一致，这里就不再赘述。</p>
<p>在上面 scheduleLate 的 dfs 函数返回之前，我们得到了每条指令可以位于的最早的块 first 和最晚的块 last (事实上，其是支配树上连续的一段树链，沿着 last 往上跳可以跳到 first)。因此，我们可以尝试规划每条指令所处于的位置。首先，我们显然会让其 loop-nest 的深度尽可能地浅。我们挑选 first 到 last 中最浅地一个块即可。这样的块可能有很多，我们选择就近原则，即尽可能晚地放置这条指令。最后，选择这个循环嵌套深度最浅，且在这个深度上最晚的块，作为真正的 last 返回并记录。</p>
<p>具体细节建议参考论文，当然论文里面貌似伪代码是错的，建议结合支配关系好好想明白后再动手。</p>
<h3 id="loop-induction-variable"><a href="#loop-induction-variable" class="headerlink" title="loop-induction-variable"></a>loop-induction-variable</h3><p>很多循环都存在归纳变量，即在一次循环过程中，仅仅加或乘一个常数。而对于常量加上循环变量，其很容易带来一些强度下降，并且给我们带来更多的循环信息(比如循环的次数等等)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">(<span class="type">int</span> *x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i) x[i] = i % <span class="number">32</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> *x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, *y = x; i &lt; <span class="number">100</span>; ++i) *(y++) = i % <span class="number">32</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上例，两个函数是完全一样的，但是后者在循环内会少一次左移操作 (用来求数组的偏移量)，这便是因为 IR 中 getelementpr 指令的基地址是循环不变量，而偏移量又是归纳变量，我们知道其改变规律。因此我们可以不用借助归纳变量，直接操纵基地址，这样可以减少一次左移操作，而每次循环少一次操作，这个优化力度是很大的。</p>
<p>同时，由于我们知道了 i 的范围，i 一定是非负的，因此 i % 32 可以进一步的被优化为 i &amp; 31 ，这样可以减少一次取模操作，这个优化力度也是很大的，而且非常常见、通用。</p>
<p>以上是归纳变量优化的基本运用。进阶优化还有很多，例如循环展开、把循环连续拷贝改为 memcpy/memmove 等等。极端的优化甚至可以直接把循环求和优化为等差数列求和公式，但是针对性较强，且比较复杂，笔者暂时没有实现。</p>
<h2 id="Scalar-replacement"><a href="#Scalar-replacement" class="headerlink" title="Scalar-replacement"></a>Scalar-replacement</h2><p>标量替换指的是把一个没有用到取地址操作的类直接拆成几个标量。例如把一个含有两个 int 的类拆成两个 int 局部变量。</p>
<p>然而，由于 Mx * 类似 Java 的语法，这导致所有类都是引用类型，而且成员函数 (包括构造函数) 都是需要用到地址(指针)的，标量替换的前提看似很难满足。但是，我们可以一步一步来。</p>
<p>首先，我们可以通过分析函数调用关系，我们容易得到哪些 new 出来的类 (其实就是 malloc 的空间) 是已经泄露的。泄露指的是这个分配的空间被存到了其他的地方，导致其离开当前函数作用域之后依然可能被访问到，直接泄露的形式有 ret 和 store ，其也可能通过函数调用，phi 函数传播。</p>
<p>对于那些没有泄露的变量，有一个非常显然的小优化: 我们可以把 malloc 优化为 alloca 。是的，因为其在函数作用域结束后不再会被访问，所以我们可以用更加紧密的栈空间代替堆空间，其可以增加缓存命中率，防止污染缓存，效果还是很好的，尤其是对于那些不是特别大的中小类型。</p>
<p>然后，再注意到我们其实有 inline 优化，因此很多时候我们会把短的成员函数直接内联了，从而实际上最后我们对于一个类指针的操作仅限于 getelementptr 。在这样的情况下，我们便可以把这个类标量替换，拆为其各个成员。显然，聪明的您肯定也发现了，那些可能被潜在标量替换的变量，一定也是 malloc 优化成为的 alloca 变量。</p>
<p>以上便是本人标量替换的主体思路。由于时间限制，笔者只完成了标量替换的第一步: 把未泄露的小类型的 malloc 语句替换为了 alloca 。在特定的测试函数中，其性能能提升 10 倍甚至是 9 倍，当然核心原因还是因为其对缓存友好，且避免了费时的 malloc。</p>
<h2 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h2><p>其他小优化还有一大堆，但是时间限制暂时不详细写了。包括但不限于:</p>
<ul>
<li>尾递归优化</li>
<li>Mx *语言特性优化</li>
<li>buitlin 函数内联</li>
<li>UB 信息利用</li>
</ul>
<h1 id="ASM"><a href="#ASM" class="headerlink" title="ASM"></a>ASM</h1><p>暂时先摸了。计划讲讲线性染色 Linear scan register allocation 。事实上，笔者写的超级烂，现在还在改，之前写的 Linear scan 可以说是完美结合了 Linear scan 质量低的缺点和 Graph coloring 非线性的缺点。</p>
<p>计划改为 SSA 上寄存器分配，其不仅线性而且质量不低。不过前提是我的有空啊啊啊</p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p><del>没人会看到这里的吧</del>我也不知道为什么，但是这次编译器写的我很累，可能是因为自己真的去证明了很多优化的正确性以及复杂度，同时还自己构思了很多优化(虽然基本都是论文里面的弱化版)，或许以后不应该浪费这么多时间自己瞎想。写的真的挺烂的，烂的不能再烂了，收集了一堆信息却几乎没用上多少，最后榜一还是偷上来的……唯一的好处，或许是对于 C++ 工程代码的经验积攒了不少。</p>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%BC%96%E8%AF%91%E5%99%A8/">编译器</a><a class="post-meta__tags" href="/tags/%E4%BC%98%E5%8C%96/">优化</a></div><div class="post-share"><div class="social-share" data-image="https://s3.bmp.ovh/imgs/2023/12/22/178d87936dac3770.png" data-sites="facebook,twitter,wechat,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://vdse.bdstatic.com//192d9a98d782d9c74c96f09db9378d93.mp4" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2023/02/17/bNFrOglBCW6ZaUq.png" alt="Wechat"/></a><div class="post-qr-code-desc">Wechat</div></li></ul></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/optimize2/" title="玄学优化和语言知识 2.0"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s3.bmp.ovh/imgs/2023/12/22/1a16727b353555b1.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">玄学优化和语言知识 2.0</div></div><div class="info-2"><div class="info-item-1">编译器写的。</div></div></div></a><a class="pagination-related" href="/SHTHO11/" title="第十一届上海 THO · 东方露明境 游记"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s3.bmp.ovh/imgs/2023/12/22/403f04fec31e5b99.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">第十一届上海 THO · 东方露明境 游记</div></div><div class="info-2"><div class="info-item-1">新人，第一次参加 THO~</div></div></div></a></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="giscus-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2023/01/28/SnEi2v9sdczUuyG.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">DarkSharpness</div><div class="author-info-description">逸一时，误一世!</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">31</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">24</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">24</div></a></div><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/DarkSharpness" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://space.bilibili.com/396961987" target="_blank" title="Bilibili"><i class="iconfont icon-bilibili"></i></a><a class="social-icon" href="https://www.zhihu.com/people/darksharpness" target="_blank" title="Zhihu"><i class="iconfont icon-zhihu"></i></a><a class="social-icon" href="https://music.163.com/#/user/home?id=8335592513" target="_blank" title="Cloudmusic"><i class="fa-solid fa-music"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">we will go certainly, till the end !</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#AST"><span class="toc-number">1.</span> <span class="toc-text">AST</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#IR"><span class="toc-number">2.</span> <span class="toc-text">IR</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#mem2reg-SSA"><span class="toc-number">2.1.</span> <span class="toc-text">mem2reg-SSA</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DCE-amp-ADCE"><span class="toc-number">2.2.</span> <span class="toc-text">DCE&amp;ADCE</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SCCP"><span class="toc-number">2.3.</span> <span class="toc-text">SCCP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CFG"><span class="toc-number">2.4.</span> <span class="toc-text">CFG</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Jump-Elimination"><span class="toc-number">2.4.1.</span> <span class="toc-text">Jump-Elimination</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Condition-Phi-Elimination"><span class="toc-number">2.4.2.</span> <span class="toc-text">Condition-Phi-Elimination</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Tail-Phi-Elimination"><span class="toc-number">2.4.3.</span> <span class="toc-text">Tail-Phi-Elimination</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Summary"><span class="toc-number">2.4.4.</span> <span class="toc-text">Summary</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Local-optimization"><span class="toc-number">2.5.</span> <span class="toc-text">Local-optimization</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Arithmetic-Simplification"><span class="toc-number">2.5.1.</span> <span class="toc-text">Arithmetic-Simplification</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CSE"><span class="toc-number">2.5.2.</span> <span class="toc-text">CSE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UB-elimination"><span class="toc-number">2.5.3.</span> <span class="toc-text">UB-elimination</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Load-Store-tracing"><span class="toc-number">2.5.4.</span> <span class="toc-text">Load&#x2F;Store tracing</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Inlining"><span class="toc-number">2.6.</span> <span class="toc-text">Inlining</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#loop-related"><span class="toc-number">2.7.</span> <span class="toc-text">loop-related</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#loop-nest-tree"><span class="toc-number">2.7.1.</span> <span class="toc-text">loop-nest-tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#loop-invariant-code-motion"><span class="toc-number">2.7.2.</span> <span class="toc-text">loop-invariant-code-motion</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#loop-induction-variable"><span class="toc-number">2.7.3.</span> <span class="toc-text">loop-induction-variable</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Scalar-replacement"><span class="toc-number">2.8.</span> <span class="toc-text">Scalar-replacement</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Others"><span class="toc-number">2.9.</span> <span class="toc-text">Others</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ASM"><span class="toc-number">3.</span> <span class="toc-text">ASM</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%90%8E%E8%AE%B0"><span class="toc-number">4.</span> <span class="toc-text">后记</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/torch/" title="dispatcher is all you need"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s3.bmp.ovh/imgs/2024/11/27/3e28dd3239526ce1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="dispatcher is all you need"/></a><div class="content"><a class="title" href="/torch/" title="dispatcher is all you need">dispatcher is all you need</a><time datetime="2024-11-26T18:08:43.000Z" title="发表于 2024-11-27 02:08:43">2024-11-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/misc/" title="杂七杂八的东西 - 大三上小结"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://static.zerochan.net/Hatsune.Miku.full.1661213.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="杂七杂八的东西 - 大三上小结"/></a><div class="content"><a class="title" href="/misc/" title="杂七杂八的东西 - 大三上小结">杂七杂八的东西 - 大三上小结</a><time datetime="2024-11-04T09:10:49.000Z" title="发表于 2024-11-04 17:10:49">2024-11-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/env/" title="我讨厌配环境"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s3.bmp.ovh/imgs/2024/07/27/3a45622b731f9c3d.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="我讨厌配环境"/></a><div class="content"><a class="title" href="/env/" title="我讨厌配环境">我讨厌配环境</a><time datetime="2024-07-25T12:51:42.000Z" title="发表于 2024-07-25 20:51:42">2024-07-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/cpp/" title="(Modern) C++ 小技巧汇总"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s3.bmp.ovh/imgs/2024/06/10/16be8fd59a1768c7.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="(Modern) C++ 小技巧汇总"/></a><div class="content"><a class="title" href="/cpp/" title="(Modern) C++ 小技巧汇总">(Modern) C++ 小技巧汇总</a><time datetime="2024-06-09T15:01:00.000Z" title="发表于 2024-06-09 23:01:00">2024-06-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/gdb/" title="GDB 使用笔记"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s3.bmp.ovh/imgs/2024/02/19/42c9a6adfd88c991.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="GDB 使用笔记"/></a><div class="content"><a class="title" href="/gdb/" title="GDB 使用笔记">GDB 使用笔记</a><time datetime="2024-03-02T04:05:14.000Z" title="发表于 2024-03-02 12:05:14">2024-03-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/optimize2/" title="玄学优化和语言知识 2.0"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s3.bmp.ovh/imgs/2023/12/22/1a16727b353555b1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="玄学优化和语言知识 2.0"/></a><div class="content"><a class="title" href="/optimize2/" title="玄学优化和语言知识 2.0">玄学优化和语言知识 2.0</a><time datetime="2023-11-11T03:11:11.000Z" title="发表于 2023-11-11 11:11:11">2023-11-11</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2025 By DarkSharpness</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">DarkSharpness welcomes you!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button><button id="blur_toggle" type="button" title="切换背景模糊"><i class="fas fa-cloud"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.isShuoshuo
  const option = null

  const getGiscusTheme = theme => theme === 'dark' ? 'dark' : 'light'

  const createScriptElement = config => {
    const ele = document.createElement('script')
    Object.entries(config).forEach(([key, value]) => {
      ele.setAttribute(key, value)
    })
    return ele
  }

  const loadGiscus = (el = document, key) => {
    const mappingConfig = isShuoshuo
      ? { 'data-mapping': 'specific', 'data-term': key }
      : { 'data-mapping': (option && option['data-mapping']) || 'pathname' }

    const giscusConfig = {
      src: 'https://giscus.app/client.js',
      'data-repo': 'DarkSharpness/DarkSharpness.github.io',
      'data-repo-id': 'MDEwOlJlcG9zaXRvcnkzNDE1Nzc5NDY=',
      'data-category-id': 'DIC_kwDOFFwQ2s4CT2jG',
      'data-theme': getGiscusTheme(document.documentElement.getAttribute('data-theme')),
      'data-reactions-enabled': '1',
      crossorigin: 'anonymous',
      async: true,
      ...option,
      ...mappingConfig
    }

    const scriptElement = createScriptElement(giscusConfig)

    el.querySelector('#giscus-wrap').appendChild(scriptElement)

    if (isShuoshuo) {
      window.shuoshuoComment.destroyGiscus = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }
  }

  const changeGiscusTheme = theme => {
    const iframe = document.querySelector('#giscus-wrap iframe')
    if (iframe) {
      const message = {
        giscus: {
          setConfig: {
            theme: getGiscusTheme(theme)
          }
        }
      }
      iframe.contentWindow.postMessage(message, 'https://giscus.app')
    }
  }

  btf.addGlobalFn('themeChange', changeGiscusTheme, 'giscus')

  if (isShuoshuo) {
    'Giscus' === 'Giscus'
      ? window.shuoshuoComment = { loadComment: loadGiscus }
      : window.loadOtherComment = loadGiscus
    return
  }

  if ('Giscus' === 'Giscus' || !true) {
    if (true) btf.loadComment(document.getElementById('giscus-wrap'), loadGiscus)
    else loadGiscus()
  } else {
    window.loadOtherComment = loadGiscus
  }
})()</script></div><script src="/js/meting.min.js"></script><script src="/js/user.js"></script><div class="aplayer no-destroy" data-volume="0.1" data-id="8149615949" data-autoplay="false" data-server="netease" data-type="playlist" data-loop="all" data-order="random" data-fixed="true" mutex="true"> </div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script>(() => {
  const destroyAplayer = () => {
    if (window.aplayers) {
      for (let i = 0; i < window.aplayers.length; i++) {
        if (!window.aplayers[i].options.fixed) {
          window.aplayers[i].destroy()
        }
      }
    }
  }

  const runMetingJS = () => {
    typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()
  }

  btf.addGlobalFn('pjaxSend', destroyAplayer, 'destroyAplayer')
  btf.addGlobalFn('pjaxComplete', loadMeting, 'runMetingJS')
})()</script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["link[rel=\"canonical\"]","meta[property=\"og:image\"]","meta[property=\"og:title\"]","meta[property=\"og:url\"]","head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => fn())
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      pjax.loadUrl('/404.html')
    }
  })
})()</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>